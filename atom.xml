<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拉姆的小树屋</title>
  
  
  <link href="https://sherry14love.github.io/atom.xml" rel="self"/>
  
  <link href="https://sherry14love.github.io/"/>
  <updated>2025-05-16T04:40:34.726Z</updated>
  <id>https://sherry14love.github.io/</id>
  
  <author>
    <name>戴诺斯·拉姆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕设</title>
    <link href="https://sherry14love.github.io/2025/04/28/learn/bishe/"/>
    <id>https://sherry14love.github.io/2025/04/28/learn/bishe/</id>
    <published>2025-04-27T16:00:00.000Z</published>
    <updated>2025-05-16T04:40:34.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目简介"><a class="markdownIt-Anchor" href="#项目简介"></a> 项目简介</h3><p>本项目是一个基于Vue3作前端，Flask框架作后端的毕设作品。该作品在过了答辩之后（预计六月份）进行开源。</p><h3 id="环境要求"><a class="markdownIt-Anchor" href="#环境要求"></a> 环境要求</h3><ul><li>Python 3.6+</li><li>Node.js 14+</li><li>npm 7+</li><li>postgresql 12+</li></ul><h3 id="项目配置"><a class="markdownIt-Anchor" href="#项目配置"></a> 项目配置</h3><p>如果在本地运行项目，需更改backend文件夹下的.env文件，配置正确的数据库连接信息。</p><p>在backend文件夹下，有一个名为config的文件夹，该文件夹下有一个名为metabase.yml的文件，该文件是metabase的配置文件，需要根据自己的需求进行配置。</p><p>系统会自动从<code>database/mock_data</code>目录读取空间时序分析所需的模拟数据。如果该目录为空，请运行以下命令生成模拟数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python database/generate_mock_data.py</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h3><p>在终端运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py</span><br></pre></td></tr></table></figure><h3 id="本地访问"><a class="markdownIt-Anchor" href="#本地访问"></a> 本地访问</h3><blockquote><p><a href="http://localhost:8080/">http://localhost:8080/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;项目简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#项目简介&quot;&gt;&lt;/a&gt; 项目简介&lt;/h3&gt;
&lt;p&gt;本项目是一个基于Vue3作前端，Flask框架作后端的毕设作品。该作品在过了答辩之后（预计六月份）进行开源。&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>拾词-叁</title>
    <link href="https://sherry14love.github.io/2025/04/06/Poem/there/"/>
    <id>https://sherry14love.github.io/2025/04/06/Poem/there/</id>
    <published>2025-04-05T16:00:00.000Z</published>
    <updated>2025-04-09T07:01:43.184Z</updated>
    
    <content type="html"><![CDATA[<p>Chronos会让我理所当然的遇见死亡，也会悄无声息得变成尘埃，那么晚安，倒霉的拉姆先生🐾</p><!-- 人生是一场概率学的游戏，我与死亡邂逅的概率是100%，我与爱情相遇的概率可以无限接近于0‰，也可以在某一刻 --><p><strong>2025-4-9</strong></p><!-- 分花拂柳浅笑， --><p>分花拂柳海棠东，日暖莺啼春杏红。<br />蓦见佳人含笑处，回首寻觅芳丛中。 <!-- 回首忽见浅笑眸，佳人怯入芳丛中。 --></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chronos会让我理所当然的遇见死亡，也会悄无声息得变成尘埃，那么晚安，倒霉的拉姆先生🐾&lt;/p&gt;
&lt;!-- 人生是一场概率学的游戏，我与死亡邂逅的概率是100%，我与爱情相遇的概率可以无限接近于0‰，也可以在某一刻 --&gt;
&lt;p&gt;&lt;strong&gt;2025-4-9&lt;/st</summary>
      
    
    
    
    <category term="诗词" scheme="https://sherry14love.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
    
    <category term="拾词" scheme="https://sherry14love.github.io/tags/%E6%8B%BE%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>PromQL食用指南</title>
    <link href="https://sherry14love.github.io/2025/04/03/learn/promql/"/>
    <id>https://sherry14love.github.io/2025/04/03/learn/promql/</id>
    <published>2025-04-02T16:00:00.000Z</published>
    <updated>2025-04-11T02:50:57.047Z</updated>
    
    <content type="html"><![CDATA[<p>PromQL（Prometheus Query Language）是 Prometheus 监控系统中使用的一种查询语言。</p><p>它是一种专门设计用于从 Prometheus 时间序列数据库中提取、处理和分析监控数据的语言。PromQL 提供了强大的表达能力，可以对时间序列数据进行复杂的过滤、聚合和计算操作。</p><p>ps：PromQL 类似于 SQL 语言，但它是专门为时间序列数据设计的。</p><blockquote><p>Prometheus 译名<code>普罗米修斯</code>，是一个开源的监控和警报工具，用于收集、存储和分析时间序列数据。还有一个名为Thanos的扩展组件，中文译名 <code>灭霸</code>🧐</p></blockquote><h2 id="promql-基础概念"><a class="markdownIt-Anchor" href="#promql-基础概念"></a> PromQL 基础概念</h2><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><ul><li><strong>瞬时向量 (Instant Vector)</strong>：某一时刻的指标快照（如 <code>node_cpu_seconds_total</code>）</li><li><strong>区间向量 (Range Vector)</strong>：一段时间范围内的指标数据（如 <code>node_cpu_seconds_total[5m]</code>）</li><li><strong>标量 (Scalar)</strong>：单一数值（如 <code>count(node_cpu_seconds_total)</code>）</li><li><strong>字符串 (String)</strong>：字符串常量（日常使用较少）</li></ul><h3 id="时间序列选择器"><a class="markdownIt-Anchor" href="#时间序列选择器"></a> 时间序列选择器</h3><h4 id="瞬时向量选择器"><a class="markdownIt-Anchor" href="#瞬时向量选择器"></a> 瞬时向量选择器</h4><p>匹配 job 为 api-server 且状态码非 4xx 的请求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job<span class="operator">=</span>&quot;api-server&quot;, status<span class="operator">!</span><span class="operator">~</span>&quot;4..&quot;&#125;  </span><br></pre></td></tr></table></figure><h4 id="区间向量选择器"><a class="markdownIt-Anchor" href="#区间向量选择器"></a> 区间向量选择器</h4><p>获取最近 5 分钟的数据点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total[<span class="number">5</span>m]  </span><br></pre></td></tr></table></figure><h3 id="过滤器运算符"><a class="markdownIt-Anchor" href="#过滤器运算符"></a> 过滤器运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>=</code></td><td>完全匹配</td><td><code>&#123;status=&quot;500&quot;&#125;</code></td></tr><tr><td><code>!=</code></td><td>不等于</td><td><code>&#123;method!=&quot;GET&quot;&#125;</code></td></tr><tr><td><code>=~</code></td><td>正则匹配</td><td><code>&#123;path=~&quot;/api/.*&quot;&#125;</code></td></tr><tr><td><code>!~</code></td><td>正则排除</td><td><code>&#123;instance!~&quot;10.0.0.1:.*&quot;&#125;</code></td></tr></tbody></table><hr /><h3 id="核心操作符"><a class="markdownIt-Anchor" href="#核心操作符"></a> 核心操作符</h3><h4 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h4><p>计算内存空闲百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes <span class="operator">/</span> node_memory_total_bytes <span class="operator">*</span> <span class="number">100</span>  </span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> 比较运算符</h4><p>筛选请求量超过 1000 的序列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total <span class="operator">&gt;</span> <span class="number">1000</span>  </span><br></pre></td></tr></table></figure><h4 id="聚合运算符"><a class="markdownIt-Anchor" href="#聚合运算符"></a> 聚合运算符</h4><p>按服务维度聚合总请求量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total) <span class="keyword">by</span> (service)  </span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h4><p>实例宕机或磁盘将在1小时内写满</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">or</span> predict_linear(node_filesystem_free_bytes[<span class="number">1</span>h], <span class="number">3600</span>) <span class="operator">&lt;</span> <span class="number">0</span>  </span><br></pre></td></tr></table></figure><h3 id="常用函数"><a class="markdownIt-Anchor" href="#常用函数"></a> 常用函数</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>rate()</code></td><td>计算每秒增长率</td><td><code>rate(http_requests_total[5m])</code></td></tr><tr><td><code>increase()</code></td><td>计算区间增长量</td><td><code>increase(node_network_bytes[1h])</code></td></tr><tr><td><code>sum_over_time()</code></td><td>区间内数值求和</td><td><code>sum_over_time(log_entries[24h])</code></td></tr><tr><td><code>histogram_quantile()</code></td><td>计算分位数</td><td><code>histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))</code></td></tr><tr><td><code>label_replace()</code></td><td>动态修改标签</td><td><code>label_replace(up, &quot;new_label&quot;, &quot;$1&quot;, &quot;instance&quot;, &quot;(.*):.*&quot;)</code></td></tr></tbody></table><h2 id="实际应用示例"><a class="markdownIt-Anchor" href="#实际应用示例"></a> 实际应用示例</h2><h3 id="匹配指标名称"><a class="markdownIt-Anchor" href="#匹配指标名称"></a> 匹配指标名称</h3><p>匹配所有具有非空指标名称的时间序列:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__<span class="operator">=</span><span class="operator">~</span>&quot;.+&quot;&#125;</span><br></pre></td></tr></table></figure><p>基于这行命令，我们可以得到：</p><ol><li><code>&#123;__name__=~&quot;http_.*&quot;&#125;</code> ：匹配以 http_ 开头的指标</li><li><code>&#123;__name__=~&quot;node_.*&quot;&#125;</code> ：匹配以 node_ 开头的指标</li><li><code>&#123;__name__=~&quot;.+&quot;&#125; and &#123;endpoint=&quot;https&quot;&#125;</code> ：匹配所有具有非空指标名称且端点为HTTPS的时间序列</li></ol><p>再进一步，我们可以使用 <code>!=</code> 来排除某些指标，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__<span class="operator">=</span><span class="operator">~</span>&quot;http_.*&quot;&#125; <span class="operator">!=</span> &#123;__name__<span class="operator">=</span>&quot;http_requests_total&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="错误率计算"><a class="markdownIt-Anchor" href="#错误率计算"></a> 错误率计算</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(rate(http_requests_total&#123;status<span class="operator">=</span><span class="operator">~</span>&quot;5..&quot;&#125;[<span class="number">5</span>m])) </span><br><span class="line"><span class="operator">/</span> </span><br><span class="line">(<span class="built_in">sum</span>(rate(http_requests_total[<span class="number">5</span>m]))) </span><br><span class="line"><span class="operator">*</span> <span class="number">100</span>  # 计算 <span class="number">5</span>xx 错误率百分比</span><br></pre></td></tr></table></figure><h3 id="预测磁盘写满时间"><a class="markdownIt-Anchor" href="#预测磁盘写满时间"></a> 预测磁盘写满时间</h3><p>预测 1 小时后磁盘是否写满</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free_bytes[<span class="number">1</span>h], <span class="number">3600</span>) <span class="operator">&lt;</span> <span class="number">0</span>  </span><br></pre></td></tr></table></figure><h3 id="cpu-使用率"><a class="markdownIt-Anchor" href="#cpu-使用率"></a> CPU 使用率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="operator">-</span> (avg <span class="keyword">by</span> (instance)(rate(node_cpu_seconds_total&#123;mode<span class="operator">=</span>&quot;idle&quot;&#125;[<span class="number">5</span>m])) <span class="operator">*</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="调试技巧"><a class="markdownIt-Anchor" href="#调试技巧"></a> 调试技巧</h2><ol><li><strong>快速验证指标存在性</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(up)  # 返回监控目标数量</span><br><span class="line"><span class="built_in">count</span>(up <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) # 筛选出所有在线的设备</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看最新数据点</strong><br />查看 1 分钟前的数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total <span class="keyword">offset</span> <span class="number">1</span>m  </span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多条件组合查询</strong><br />联查生产环境非 Redis 容器内存</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__<span class="operator">=</span><span class="operator">~</span>&quot;node_.*&quot;, environment<span class="operator">=</span>&quot;prod&quot;&#125; </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">ON</span> (instance) </span><br><span class="line">container_memory_usage_bytes&#123;image<span class="operator">!</span><span class="operator">~</span>&quot;redis.*&quot;&#125;  </span><br></pre></td></tr></table></figure><hr /><p>未完待续~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PromQL（Prometheus Query Language）是 Prometheus 监控系统中使用的一种查询语言。&lt;/p&gt;
&lt;p&gt;它是一种专门设计用于从 Prometheus 时间序列数据库中提取、处理和分析监控数据的语言。PromQL 提供了强大的表达能力，可以对</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>Pycharm快捷键食用指南</title>
    <link href="https://sherry14love.github.io/2024/11/29/learn/pycharm/"/>
    <id>https://sherry14love.github.io/2024/11/29/learn/pycharm/</id>
    <published>2024-11-28T16:00:00.000Z</published>
    <updated>2025-04-11T02:51:23.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键指令"><a class="markdownIt-Anchor" href="#快捷键指令"></a> 快捷键指令：</h2><h3 id="代码重构与质量检测"><a class="markdownIt-Anchor" href="#代码重构与质量检测"></a> 代码重构与质量检测</h3><ul><li><strong>Ctrl + Alt + Shift + T</strong>: 打开重构菜单</li><li><strong>Ctrl + Alt + L</strong>: 自动格式化代码</li><li><strong>Alt + Enter</strong>: 查看代码检查修复建议</li></ul><h3 id="文件搜索与快速导航"><a class="markdownIt-Anchor" href="#文件搜索与快速导航"></a> 文件搜索与快速导航</h3><ul><li><strong>Ctrl + N</strong>: 搜索类名</li><li><strong>Ctrl + Shift + N</strong>: 搜索文件</li><li><strong>Ctrl + E</strong>: 查看最近打开的文件</li></ul><h3 id="自动补全与重构快捷键"><a class="markdownIt-Anchor" href="#自动补全与重构快捷键"></a> 自动补全与重构快捷键</h3><ul><li><strong>Alt + Enter</strong>: 修复错误</li><li><strong>Shift + F6</strong>: 重命名变量或函数</li></ul><h3 id="代码块与行操作"><a class="markdownIt-Anchor" href="#代码块与行操作"></a> 代码块与行操作</h3><ul><li><strong>Ctrl + Y</strong>: 删除当前行</li><li><strong>Ctrl + D</strong>: 复制当前行</li><li><strong>Ctrl + /</strong>: 快速注释/取消注释</li></ul><h3 id="代码管理与调试功能"><a class="markdownIt-Anchor" href="#代码管理与调试功能"></a> 代码管理与调试功能</h3><ul><li><strong>Shift + F9</strong>: 启动调试模式</li><li><strong>F8</strong>: 逐步执行代码</li><li><strong>F9</strong>: 跳至下一个断点</li></ul><h3 id="编辑器操作"><a class="markdownIt-Anchor" href="#编辑器操作"></a> 编辑器操作</h3><ul><li><strong>Ctrl + Z</strong>: 撤销</li><li><strong>Ctrl + Shift + Z</strong>: 重做</li><li><strong>Ctrl + X</strong>: 剪切当前行或选中的内容</li><li><strong>Ctrl + C</strong>: 复制当前行或选中的内容</li><li><strong>Ctrl + V</strong>: 粘贴</li><li><strong>Ctrl + Shift + V</strong>: 从剪贴板历史中选择粘贴内容</li><li><strong>Ctrl + W</strong>: 扩展选中范围</li><li><strong>Ctrl + Shift + W</strong>: 缩小选中范围</li><li><strong>Ctrl + Shift + U</strong>: 大小写转换</li><li><strong>Ctrl + Shift + J</strong>: 合并行</li><li><strong>Ctrl + Shift + Enter</strong>: 补全当前语句</li></ul><h3 id="导航与搜索"><a class="markdownIt-Anchor" href="#导航与搜索"></a> 导航与搜索</h3><ul><li><strong>Ctrl + B</strong>: 跳转到声明（变量、函数、类等）</li><li><strong>Ctrl + Alt + B</strong>: 跳转到实现</li><li><strong>Ctrl + Shift + B</strong>: 跳转到类型声明</li><li><strong>Ctrl + U</strong>: 跳转到父类或父方法</li><li><strong>Ctrl + Alt + Left/Right</strong>: 导航回退/前进</li><li><strong>Ctrl + Shift + Backspace</strong>: 跳转到上次编辑位置</li><li><strong>Ctrl + Shift + F7</strong>: 高亮显示当前文件中的变量</li><li><strong>Ctrl + Alt + F7</strong>: 显示使用情况</li></ul><h3 id="代码生成与重构"><a class="markdownIt-Anchor" href="#代码生成与重构"></a> 代码生成与重构</h3><ul><li><strong>Alt + Insert</strong>: 生成代码（构造函数、getter/setter、toString等）</li><li><strong>Ctrl + Alt + M</strong>: 提取方法</li><li><strong>Ctrl + Alt + V</strong>: 提取变量</li><li><strong>Ctrl + Alt + F</strong>: 提取字段</li><li><strong>Ctrl + Alt + C</strong>: 提取常量</li><li><strong>Ctrl + Alt + P</strong>: 提取参数</li></ul><h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3><ul><li><strong>Ctrl + F8</strong>: 切换断点</li><li><strong>Ctrl + Shift + F8</strong>: 查看所有断点</li><li><strong>Alt + F8</strong>: 在调试时计算表达式</li><li><strong>F7</strong>: 进入方法内部</li><li><strong>Shift + F7</strong>: 智能进入方法内部</li><li><strong>F9</strong>: 恢复程序执行</li><li><strong>Ctrl + F2</strong>: 停止调试</li></ul><h3 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h3><ul><li><strong>Ctrl + K</strong>: 提交更改</li><li><strong>Ctrl + T</strong>: 更新项目</li><li><strong>Alt + `</strong>: 打开版本控制操作菜单</li></ul><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li><strong>Ctrl + Alt + S</strong>: 打开设置</li><li><strong>Ctrl + Alt + Shift + S</strong>: 打开项目结构</li><li><strong>Ctrl + Shift + A</strong>: 查找操作</li><li><strong>Ctrl + Tab</strong>: 切换编辑器选项卡</li><li><strong>Ctrl + Shift + F12</strong>: 最大化编辑器窗口</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快捷键指令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快捷键指令&quot;&gt;&lt;/a&gt; 快捷键指令：&lt;/h2&gt;
&lt;h3 id=&quot;代码重构与质量检测&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码重构与质量检测&quot;</summary>
      
    
    
    
    <category term="Tool" scheme="https://sherry14love.github.io/categories/Tool/"/>
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/Tool/learn/"/>
    
    
    <category term="GPT" scheme="https://sherry14love.github.io/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>初遇·冬日北平</title>
    <link href="https://sherry14love.github.io/2024/11/22/diary/2024senior/"/>
    <id>https://sherry14love.github.io/2024/11/22/diary/2024senior/</id>
    <published>2024-11-21T16:00:00.000Z</published>
    <updated>2025-04-03T03:32:09.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拾序"><a class="markdownIt-Anchor" href="#拾序"></a> 拾序</h2><p>辞了颜色与交替，杨柳依旧沾青云<br />新旧故尘无处寻，只得冬日梦染身</p><h2 id="思来旧绪饮茶论平生"><a class="markdownIt-Anchor" href="#思来旧绪饮茶论平生"></a> 思来旧绪，饮茶论平生</h2><p><em>论不清与寒风相拥的刺骨，道不明这颠沛流离的道路，东西奔走，是讲不透的辛苦盈盈，南北漂往，是说不来的苦海相逢。</em></p><p>有时候，我独自一人，会陷入一种荒诞与矛盾的哲学思考之中，在不断的自我剖析中去不断的否定自己、不断的厌恶自己，既没有苏格拉底的认识自己，也没有尼采的成为自己，这样来看，我部署的人生，无疑是糟糕无趣的。</p><h2 id="青春将逝荒唐一场梦"><a class="markdownIt-Anchor" href="#青春将逝荒唐一场梦"></a> 青春将逝，荒唐一场梦</h2><p>这时候，我总会怀念起初一的时光，或许是因为，那时候的我，不会为学业担忧，更不会有来自社会的压力，还记得班级第二永远在换人，而班级第一永远都是我 <em><code>窃喜一下下啦嗯~ o(*￣▽￣*)o</code></em></p><p>那时候在课上，很喜欢发呆，也会赶在假期前写完作业然后疯玩，课间偶尔会和前桌打闹，午休的时候看些闲书，这样的时光，好似梦幻般，美好。</p><p>我还记得当时喜欢看<code>《怪物大师》《查理九世》</code>，他们的冒险故事是我的童年与青春。</p><p>当然，我也记得我那时的班主任是一位男老师，生物老师，他总是笑眯眯的，五官端正立体，真说起来，有点像乌克兰的总统小泽。</p><p>班主任说，有的大学很大很大，需要每天赶公交才能到教室。当时我就在想，我未来是不是也这样。</p><p>但其实，我的大学很小，虽说刚开始有点失落，但后来我七点五十七起床，八点能踩点到教室的时候，我觉得，这或许也不错。</p><h2 id="辞往日心敬来日微呡"><a class="markdownIt-Anchor" href="#辞往日心敬来日微呡"></a> 辞往日心，敬来日微呡</h2><p>当我坐在公交车上，听着音乐，看着窗外的雪，有一瞬间，失了神。似乎迷茫，又似乎释然。</p><p>有时候，人对某个陌生的场景会感到很熟悉，彷佛是前世，又像是来生。</p><p>记忆中的走走停停，或许并不是心的流浪，也不是灵魂的漂泊，只是走累了，停下来，歇一会。</p><p>歇好之后，再去漫游，无论何处，时间总会，把我们带到，最初的终点。</p><hr /><p><strong>2024-12-22</strong></p><!-- 三千语，四万言，寥寥思绪笔墨怜 --><p>三千言，四万语，寥寥思绪笔墨聚</p><p><strong>2025-3-11</strong><br />记北京小雨<br />柔不见骨美如梦，意不知君风不冷<br />风不冷、花不争，静心寻道春无声</p><p>PS:<strong>2025-3-17</strong>，终于把这个拖了115天的博文写好了！！！<code>快夸拉姆q(≧▽≦q)</code></p><p><strong>2025-3-30</strong></p><p>清河边，桃花艳，风扶杨柳春拂面<br />与同窗，看人间，青橙粉紫最流连<br />醉流连，意盎然，且赴诗篇笔墨悬<br />笔墨悬，兴未阑，往日种种尽笑谈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拾序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#拾序&quot;&gt;&lt;/a&gt; 拾序&lt;/h2&gt;
&lt;p&gt;辞了颜色与交替，杨柳依旧沾青云&lt;br /&gt;
新旧故尘无处寻，只得冬日梦染身&lt;/p&gt;
&lt;h2 id=&quot;思来旧绪饮茶论平生&quot;&gt;&lt;a class=&quot;m</summary>
      
    
    
    
    <category term="dairy" scheme="https://sherry14love.github.io/categories/dairy/"/>
    
    <category term="诗词" scheme="https://sherry14love.github.io/categories/dairy/%E8%AF%97%E8%AF%8D/"/>
    
    
    <category term="拾词" scheme="https://sherry14love.github.io/tags/%E6%8B%BE%E8%AF%8D/"/>
    
    <category term="日记" scheme="https://sherry14love.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>人体姿势识别：openpose与yolov8_pose使用心得</title>
    <link href="https://sherry14love.github.io/2024/11/13/learn/openpose/"/>
    <id>https://sherry14love.github.io/2024/11/13/learn/openpose/</id>
    <published>2024-11-12T16:00:00.000Z</published>
    <updated>2024-11-19T06:04:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址1：<a href="https://www.codewithgpu.com/i/CMU-Perceptual-Computing-Lab/openpose/openpose">openpose镜像，需要在云服务器上微调</a></p><p>项目地址2：<a href="https://github.com/Mrjianning/yolov8_pose_judge">GitHub上大佬项目，在本地部署调试即可</a></p><h2 id="openpose的使用"><a class="markdownIt-Anchor" href="#openpose的使用"></a> openpose的使用</h2><p>CodeWithGPU里的镜像只支持3090及其以上的GPU部署运行，在终端输入下面命令即可运行查看项目情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openpose</span><br><span class="line">./build/examples/openpose/openpose.bin --video ~/test.mp4 --write_json ~/output_json --write_video ~/output.mp4 -display 0 -face -hand</span><br></pre></td></tr></table></figure><p>下面让我们继续微调，在<strong>根目录</strong>下面，创建两个文件夹，一个test，一个test_run，放入我们的测试图片和输出图片。</p><p>再在<strong>根目录</strong>创建一个python文件，detect_pose函数里有着我们的判断算法（不过我当时写的时候感觉有点奇怪，效果也一般般，需要你自己调整）</p><p>main函数里还有需要一个SimHei.ttf，也就是中文字体，需要自己下载，放在<strong>根目录</strong>里，记得名称要对喔，拉姆当时就是因为下载的是SimHei.ttf，但是代码里写的是<code>font_path = &quot;simhei.ttf&quot;</code>，导致拉姆修了半个小时的bug（悲）</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&#x27;/root/openpose/build/python&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> openpose <span class="keyword">import</span> pyopenpose <span class="keyword">as</span> op</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_angle</span>(<span class="params">point1, point2, point3</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算三个点形成的角度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> (point1[<span class="number">2</span>], point2[<span class="number">2</span>], point3[<span class="number">2</span>]):  <span class="comment"># 如果置信度为0，表示点没有被检测到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    a = np.array([point1[<span class="number">0</span>], point1[<span class="number">1</span>]])</span><br><span class="line">    b = np.array([point2[<span class="number">0</span>], point2[<span class="number">1</span>]])</span><br><span class="line">    c = np.array([point3[<span class="number">0</span>], point3[<span class="number">1</span>]])</span><br><span class="line">    </span><br><span class="line">    ba = a - b</span><br><span class="line">    bc = c - b</span><br><span class="line">    </span><br><span class="line">    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))</span><br><span class="line">    angle = np.arccos(cosine_angle)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> np.degrees(angle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_pose</span>(<span class="params">pose_keypoints</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于关键点判断姿势</span></span><br><span class="line"><span class="string">    返回姿势名称和置信度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> pose_keypoints <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(pose_keypoints) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No person detected&quot;</span>, <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 提取关键点</span></span><br><span class="line">    <span class="comment"># 鼻子和颈部</span></span><br><span class="line">    nose = pose_keypoints[<span class="number">0</span>]</span><br><span class="line">    neck = pose_keypoints[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 臀部中心点</span></span><br><span class="line">    hip_center = pose_keypoints[<span class="number">8</span>]</span><br><span class="line">    <span class="comment"># 左右臀部</span></span><br><span class="line">    left_hip = pose_keypoints[<span class="number">12</span>]</span><br><span class="line">    right_hip = pose_keypoints[<span class="number">9</span>]</span><br><span class="line">    <span class="comment"># 左右膝盖</span></span><br><span class="line">    left_knee = pose_keypoints[<span class="number">13</span>]</span><br><span class="line">    right_knee = pose_keypoints[<span class="number">10</span>]</span><br><span class="line">    <span class="comment"># 左右脚踝</span></span><br><span class="line">    left_ankle = pose_keypoints[<span class="number">14</span>]</span><br><span class="line">    right_ankle = pose_keypoints[<span class="number">11</span>]</span><br><span class="line">    <span class="comment"># 左右肩膀</span></span><br><span class="line">    left_shoulder = pose_keypoints[<span class="number">5</span>]</span><br><span class="line">    right_shoulder = pose_keypoints[<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 左右肘部</span></span><br><span class="line">    left_elbow = pose_keypoints[<span class="number">6</span>]</span><br><span class="line">    right_elbow = pose_keypoints[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 左右手腕</span></span><br><span class="line">    left_wrist = pose_keypoints[<span class="number">7</span>]</span><br><span class="line">    right_wrist = pose_keypoints[<span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算膝盖角度</span></span><br><span class="line">    left_knee_angle = calculate_angle(left_hip, left_knee, left_ankle)</span><br><span class="line">    right_knee_angle = calculate_angle(right_hip, right_knee, right_ankle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取髋部高度（相对于脚踝）</span></span><br><span class="line">    hip_height = <span class="built_in">abs</span>(hip_center[<span class="number">1</span>] - left_ankle[<span class="number">1</span>] + hip_center[<span class="number">1</span>] - right_ankle[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算鼻子和脚高度（身高）</span></span><br><span class="line">    body_height = <span class="built_in">abs</span>(nose[<span class="number">1</span>]-left_ankle[<span class="number">1</span>])</span><br><span class="line">    bo_height = <span class="built_in">abs</span>(left_shoulder [<span class="number">1</span>]-right_hip[<span class="number">1</span>])</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 姿态判断逻辑</span></span><br><span class="line">    <span class="keyword">if</span> left_knee_angle <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_knee_angle <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> hip_height <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;关键点缺失&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 站立判断：膝盖角度接近180度</span></span><br><span class="line">    <span class="keyword">if</span> (left_knee_angle &gt; <span class="number">160</span> <span class="keyword">and</span> right_knee_angle &gt; <span class="number">160</span>): </span><br><span class="line">        <span class="keyword">if</span> (body_height &gt; <span class="number">2</span> * bo_height):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;站立&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;平躺&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># # 关键点判断</span></span><br><span class="line">    <span class="comment"># if nose is None and neck is None:</span></span><br><span class="line">    <span class="comment">#     return &quot;关键点缺失&quot;, 0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># # 姿态判断逻辑</span></span><br><span class="line">    <span class="comment"># if left_knee_angle is None or right_knee_angle is None or hip_height is None:</span></span><br><span class="line">    <span class="comment">#     return &quot;关键点缺失&quot;, 0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 蹲下判断：膝盖角度小于120度且髋部降低</span></span><br><span class="line">    <span class="keyword">if</span> (left_knee_angle &lt; <span class="number">120</span> <span class="keyword">and</span> right_knee_angle &lt; <span class="number">120</span>):</span><br><span class="line">        confidence = (<span class="number">120</span> - <span class="built_in">max</span>(left_knee_angle, right_knee_angle)) / <span class="number">60</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;蹲下&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 抬腿判断：一条腿的膝盖角度明显小于另一条腿</span></span><br><span class="line">    knee_angle_diff = <span class="built_in">abs</span>(left_knee_angle - right_knee_angle)</span><br><span class="line">    <span class="keyword">if</span> (knee_angle_diff &gt; <span class="number">30</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抬腿&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双腿抬起判断：两条腿的膝盖角度都小于某个阈值（例如120度）</span></span><br><span class="line">    <span class="keyword">if</span> (left_knee_angle &lt; <span class="number">120</span> <span class="keyword">and</span> right_knee_angle &lt; <span class="number">120</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;双腿抬起&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 举手判断：手腕和肩膀的高度</span></span><br><span class="line">    <span class="keyword">if</span> (left_wrist[<span class="number">1</span>] &lt; left_shoulder[<span class="number">1</span>] <span class="keyword">or</span> right_wrist[<span class="number">1</span>] &lt; right_shoulder[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;手部举起&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;未检测到正确动作&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 图像进行测试    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># OpenPose参数配置</span></span><br><span class="line">    params = <span class="built_in">dict</span>()</span><br><span class="line">    params[<span class="string">&quot;face&quot;</span>] = <span class="literal">True</span></span><br><span class="line">    params[<span class="string">&quot;hand&quot;</span>] = <span class="literal">True</span> </span><br><span class="line">    params[<span class="string">&quot;model_folder&quot;</span>] = <span class="string">&quot;/root/openpose/models/&quot;</span></span><br><span class="line">    <span class="comment"># 初始化OpenPose</span></span><br><span class="line">    opWrapper = op.WrapperPython()</span><br><span class="line">    opWrapper.configure(params)</span><br><span class="line">    opWrapper.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 图像文件夹路径</span></span><br><span class="line">    img_folder = <span class="string">&quot;./test&quot;</span>  <span class="comment"># 替换为你的图像文件夹路径</span></span><br><span class="line">    test_folder = <span class="string">&quot;./test_run&quot;</span>  <span class="comment"># 替换为你的输出文件夹路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保输出文件夹存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_folder):</span><br><span class="line">        os.makedirs(test_folder)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取图像文件列表</span></span><br><span class="line">    image_paths = [os.path.join(img_folder, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(img_folder) <span class="keyword">if</span> f.endswith((<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span>))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> image_path <span class="keyword">in</span> image_paths:</span><br><span class="line">        <span class="comment"># 读取图像文件</span></span><br><span class="line">        frame = cv2.imread(image_path)</span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: Could not read image <span class="subst">&#123;image_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 准备OpenPose输入</span></span><br><span class="line">        datum = op.Datum()</span><br><span class="line">        datum.cvInputData = frame</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># OpenPose处理</span></span><br><span class="line">        opWrapper.emplaceAndPop(op.VectorDatum([datum]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取姿态预测</span></span><br><span class="line">        <span class="keyword">if</span> datum.poseKeypoints <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(datum.poseKeypoints) &gt; <span class="number">0</span>:</span><br><span class="line">            pose, confidence = detect_pose(datum.poseKeypoints[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在图像上绘制关键点和框框</span></span><br><span class="line">            <span class="keyword">for</span> keypoints <span class="keyword">in</span> datum.poseKeypoints:</span><br><span class="line">                <span class="keyword">for</span> i, keypoint <span class="keyword">in</span> <span class="built_in">enumerate</span>(keypoints):</span><br><span class="line">                    x, y, confidence = keypoint</span><br><span class="line">                    <span class="keyword">if</span> confidence &gt; <span class="number">0.1</span>:  <span class="comment"># 只绘制置信度大于0.1的关键点</span></span><br><span class="line">                        cv2.circle(frame, (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">                        cv2.putText(frame, <span class="built_in">str</span>(i), (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用PIL库在图像上显示中文字符</span></span><br><span class="line">            pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))</span><br><span class="line">            draw = ImageDraw.Draw(pil_image)</span><br><span class="line">            font_path = <span class="string">&quot;SimHei.ttf&quot;</span>  <span class="comment"># 字体文件与脚本文件在同一目录下</span></span><br><span class="line">            font = ImageFont.truetype(font_path, <span class="number">24</span>) </span><br><span class="line">            draw.text((<span class="number">50</span>, <span class="number">50</span>), <span class="string">f&quot;<span class="subst">&#123;pose&#125;</span> (<span class="subst">&#123;confidence:<span class="number">.2</span>f&#125;</span>)&quot;</span>, font=font, fill=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="keyword">if</span> confidence &gt; <span class="number">0.5</span> <span class="keyword">else</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">            frame = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存处理后的图像</span></span><br><span class="line">        output_path = os.path.join(test_folder, os.path.basename(image_path))</span><br><span class="line">        cv2.imwrite(output_path, frame)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Processed image saved to <span class="subst">&#123;output_path&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 释放资源</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>祝使用愉快/记得要自己修判断算法逻辑喔</p><h2 id="yolov8_pose的使用"><a class="markdownIt-Anchor" href="#yolov8_pose的使用"></a> yolov8_pose的使用</h2><p>安装指令：<br />首先克隆这个仓库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Mrjianning/yolov8_pose_judge.git</span><br><span class="line"><span class="built_in">cd</span> yolov8_pose_judge</span><br></pre></td></tr></table></figure><p>安装所需的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>快速开始:<br />运行以下命令以启动姿态检测：<code>python main.py</code></p><p>没有问题的话，我们在<code>根目录</code>下创建一个python文件</p><p>python代码里有三个实现，分别是针对于图片的静态识别，针对于视频的动态识别，以及调用摄像头的实时动态识别</p><p>当然，determine_pose函数中姿态识别的算法逻辑代码，拉姆这边还是有一些问题的，请你自己修改喔~</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ultralytics.data.augment <span class="keyword">import</span> LetterBox</span><br><span class="line"><span class="keyword">from</span> ultralytics.utils <span class="keyword">import</span> ops</span><br><span class="line"><span class="keyword">from</span> ultralytics.engine.results <span class="keyword">import</span> Results</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.stdout.reconfigure(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOLOv8Pose</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model_path, device=<span class="string">&#x27;cpu&#x27;</span>, conf=<span class="number">0.25</span>, iou=<span class="number">0.7</span></span>):</span><br><span class="line">        self.device = device</span><br><span class="line">        self.conf = conf</span><br><span class="line">        self.iou = iou</span><br><span class="line">        self.model = self.load_model(model_path)</span><br><span class="line">        self.letterbox = LetterBox([<span class="number">640</span>, <span class="number">640</span>], auto=<span class="literal">True</span>, stride=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_model</span>(<span class="params">self, model_path</span>):</span><br><span class="line">        ckpt = torch.load(model_path, map_location=self.device)</span><br><span class="line">        model = ckpt[<span class="string">&#x27;model&#x27;</span>].to(self.device).<span class="built_in">float</span>()</span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">self, img_path</span>):</span><br><span class="line">        im = cv.imread(img_path)</span><br><span class="line">        im = [im]</span><br><span class="line">        orig_imgs = copy.deepcopy(im)</span><br><span class="line">        im = [self.letterbox(image=x) <span class="keyword">for</span> x <span class="keyword">in</span> im]</span><br><span class="line">        im = im[<span class="number">0</span>][<span class="literal">None</span>]</span><br><span class="line">        im = im[..., ::-<span class="number">1</span>].transpose((<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        im = np.ascontiguousarray(im)</span><br><span class="line">        im = torch.from_numpy(im)</span><br><span class="line">        img = im.to(self.device)</span><br><span class="line">        img = img.<span class="built_in">float</span>()</span><br><span class="line">        img /= <span class="number">255</span></span><br><span class="line">        <span class="keyword">return</span> img, orig_imgs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">self, img</span>):</span><br><span class="line">        preds = self.model(img)</span><br><span class="line">        prediction = ops.non_max_suppression(preds, self.conf, self.iou, agnostic=<span class="literal">False</span>, max_det=<span class="number">300</span>, classes=<span class="literal">None</span>,</span><br><span class="line">                                             nc=<span class="built_in">len</span>(self.model.names))</span><br><span class="line">        <span class="keyword">return</span> prediction</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postprocess</span>(<span class="params">self, prediction, orig_imgs, img_shape, img_path</span>):</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> i, pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(prediction):</span><br><span class="line">            orig_img = orig_imgs[i] <span class="keyword">if</span> <span class="built_in">isinstance</span>(orig_imgs, <span class="built_in">list</span>) <span class="keyword">else</span> orig_imgs</span><br><span class="line">            shape = orig_img.shape</span><br><span class="line">            pred[:, :<span class="number">4</span>] = ops.scale_boxes(img_shape, pred[:, :<span class="number">4</span>], shape).<span class="built_in">round</span>()</span><br><span class="line">            pred_kpts = pred[:, <span class="number">6</span>:].view(<span class="built_in">len</span>(pred), *self.model.kpt_shape) <span class="keyword">if</span> <span class="built_in">len</span>(pred) <span class="keyword">else</span> pred[:, <span class="number">6</span>:]</span><br><span class="line">            pred_kpts = ops.scale_coords(img_shape, pred_kpts, shape)</span><br><span class="line"></span><br><span class="line">            results.append(</span><br><span class="line">                Results(orig_img=orig_img,</span><br><span class="line">                        path=img_path,</span><br><span class="line">                        names=self.model.names,</span><br><span class="line">                        boxes=pred[:, :<span class="number">6</span>],</span><br><span class="line">                        keypoints=pred_kpts))</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">self, results, img</span>):</span><br><span class="line">        plot_args = &#123;<span class="string">&#x27;line_width&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;boxes&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;conf&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;labels&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        plot_args[<span class="string">&#x27;im_gpu&#x27;</span>] = img[<span class="number">0</span>]</span><br><span class="line">        result = results[<span class="number">0</span>]</span><br><span class="line">        plotted_img = result.plot(**plot_args)</span><br><span class="line">        <span class="keyword">return</span> plotted_img</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect</span>(<span class="params">self, img_path</span>):</span><br><span class="line">        img, orig_imgs = self.preprocess(img_path)</span><br><span class="line">        prediction = self.infer(img)</span><br><span class="line">        results = self.postprocess(prediction, orig_imgs, img.shape[<span class="number">2</span>:], img_path)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_results</span>(<span class="params">self, results, img_path</span>):</span><br><span class="line">        img, _ = self.preprocess(img_path)</span><br><span class="line">        plotted_img = self.plot_results(results, img)</span><br><span class="line"></span><br><span class="line">        cv.imshow(<span class="string">&#x27;plotted_img&#x27;</span>, plotted_img)</span><br><span class="line">        cv.waitKey(<span class="number">0</span>)</span><br><span class="line">        cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">determine_pose</span>(<span class="params">self, keypoints</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据关键点确定人体姿态。</span></span><br><span class="line"><span class="string">        :param keypoints: 包含每个关键点的坐标和置信度的元组列表，例如 [(x1, y1, conf1), ...]</span></span><br><span class="line"><span class="string">        :return: 姿态类别：&#x27;站立&#x27;,&#x27;抬腿&#x27;,&#x27;平躺&#x27;,&quot;抬胳膊&quot;,&quot;蹲下&quot;,&quot;举左手&quot;,&quot;举右手&quot;,&quot;腿弯曲&quot;,&#x27;未检测到正确动作&#x27;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义关键点索引</span></span><br><span class="line">        left_ankle, right_ankle = keypoints[<span class="number">15</span>], keypoints[<span class="number">16</span>]</span><br><span class="line">        left_knee, right_knee = keypoints[<span class="number">13</span>], keypoints[<span class="number">14</span>]</span><br><span class="line">        left_hip, right_hip = keypoints[<span class="number">11</span>], keypoints[<span class="number">12</span>]</span><br><span class="line">        left_shoulder, right_shoulder = keypoints[<span class="number">5</span>], keypoints[<span class="number">6</span>]</span><br><span class="line">        left_elbow, right_elbow = keypoints[<span class="number">7</span>], keypoints[<span class="number">8</span>]</span><br><span class="line">        left_wrist, right_wrist = keypoints[<span class="number">9</span>], keypoints[<span class="number">10</span>]</span><br><span class="line">        nose = keypoints[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查置信度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(conf &lt; <span class="number">0</span> <span class="keyword">for</span> _, _, conf <span class="keyword">in</span></span><br><span class="line">               [left_ankle, right_ankle, left_knee, right_knee, left_hip, right_hip, left_shoulder, right_shoulder]):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;xxx未检测到正确动作&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calculate_angle</span>(<span class="params">point1, point2, point3</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;计算由三个点形成的角度。&quot;&quot;&quot;</span></span><br><span class="line">            vector1 = (point2[<span class="number">0</span>] - point1[<span class="number">0</span>], point2[<span class="number">1</span>] - point1[<span class="number">1</span>])</span><br><span class="line">            vector2 = (point3[<span class="number">0</span>] - point2[<span class="number">0</span>], point3[<span class="number">1</span>] - point2[<span class="number">1</span>])</span><br><span class="line">            dot_product = vector1[<span class="number">0</span>] * vector2[<span class="number">0</span>] + vector1[<span class="number">1</span>] * vector2[<span class="number">1</span>]</span><br><span class="line">            magnitude1 = math.sqrt(vector1[<span class="number">0</span>] ** <span class="number">2</span> + vector1[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">            magnitude2 = math.sqrt(vector2[<span class="number">0</span>] ** <span class="number">2</span> + vector2[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> magnitude1 * magnitude2 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cos_theta = <span class="built_in">max</span>(-<span class="number">1</span>, <span class="built_in">min</span>(<span class="number">1</span>, dot_product / (magnitude1 * magnitude2)))</span><br><span class="line">            <span class="keyword">return</span> math.degrees(math.acos(cos_theta))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算关键角度</span></span><br><span class="line">        left_knee_angle = calculate_angle(left_hip, left_knee, left_ankle)</span><br><span class="line">        right_knee_angle = calculate_angle(right_hip, right_knee, right_ankle)</span><br><span class="line">        left_hip_angle = calculate_angle(left_shoulder, left_hip, left_knee)</span><br><span class="line">        right_hip_angle = calculate_angle(right_shoulder, right_hip, right_knee)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算关键位置关系</span></span><br><span class="line">        body_height = <span class="built_in">abs</span>(nose[<span class="number">1</span>] - left_ankle[<span class="number">1</span>])</span><br><span class="line">        bo_height = <span class="built_in">abs</span>(left_ankle[<span class="number">1</span>] - right_hip[<span class="number">1</span>])</span><br><span class="line">        ankle_distance = <span class="built_in">abs</span>(left_ankle[<span class="number">0</span>] - right_ankle[<span class="number">0</span>])</span><br><span class="line">        knee_distance = <span class="built_in">abs</span>(left_knee[<span class="number">0</span>] - right_knee[<span class="number">0</span>])</span><br><span class="line">        avg_hip_height = (left_hip[<span class="number">1</span>] + right_hip[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">        avg_shoulder_height = (left_shoulder[<span class="number">1</span>] + right_shoulder[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">        avg_knee_height = (left_knee[<span class="number">1</span>] + right_knee[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">        avg_ankle_height = (left_ankle[<span class="number">1</span>] + right_ankle[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">        shoulder_to_hip_dist = <span class="built_in">abs</span>((left_shoulder[<span class="number">1</span>] + right_shoulder[<span class="number">1</span>]) / <span class="number">2</span> -(left_hip[<span class="number">1</span>] + right_hip[<span class="number">1</span>]) / <span class="number">2</span>)</span><br><span class="line">        hip_to_ankle_dist = <span class="built_in">abs</span>((left_hip[<span class="number">1</span>] + right_hip[<span class="number">1</span>]) / <span class="number">2</span> -(left_ankle[<span class="number">1</span>] + right_ankle[<span class="number">1</span>]) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if (left_shoulder[1] &lt; left_hip[1] &lt; left_knee[1] &lt; left_ankle[1] and</span></span><br><span class="line">        <span class="comment">#         right_shoulder[1] &lt; right_hip[1] &lt; right_knee[1] &lt; right_ankle[1]):</span></span><br><span class="line">        <span class="comment">#     # 确保身体没有抬起，适用于完全平躺的场景</span></span><br><span class="line">        <span class="comment">#     if (body_height &gt; 2 * bo_height):</span></span><br><span class="line">        <span class="comment">#         return &quot;1站立&quot;</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#     shoulder_to_hip_dist = abs((left_shoulder[1] + right_shoulder[1]) / 2 -</span></span><br><span class="line">        <span class="comment">#                                (left_hip[1] + right_hip[1]) / 2)</span></span><br><span class="line">        <span class="comment">#     hip_to_ankle_dist = abs((left_hip[1] + right_hip[1]) / 2 -</span></span><br><span class="line">        <span class="comment">#                             (left_ankle[1] + right_ankle[1]) / 2)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#     if shoulder_to_hip_dist &gt; hip_to_ankle_dist * 0.5:</span></span><br><span class="line">        <span class="comment">#         if left_ankle[0]&gt;left_knee[0]:</span></span><br><span class="line">        <span class="comment">#             return &#x27;2站立&#x27;</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             return &quot;平躺&quot;</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         if (left_knee[1] &gt;= avg_hip_height and right_knee[1] &gt;= avg_hip_height) or (</span></span><br><span class="line">        <span class="comment">#                 left_knee_angle &gt;= 120 and right_knee_angle &gt;= 120):</span></span><br><span class="line">        <span class="comment">#             return &#x27;平躺&#x27;</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             return &#x27;可能抬腿&#x27;</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># # 抬腿动作检测，要在其他条件下做进一步细化</span></span><br><span class="line">        <span class="comment"># knee_angle_diff = abs(left_knee_angle - right_knee_angle)</span></span><br><span class="line">        <span class="comment"># if (left_knee[1] &lt; avg_hip_height or right_knee[1] &lt; avg_hip_height) and (</span></span><br><span class="line">        <span class="comment">#         left_knee_angle &lt; 120 or right_knee_angle &lt; 120) or (knee_angle_diff &gt; 30):</span></span><br><span class="line">        <span class="comment">#     return &#x27;抬腿&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left_shoulder[<span class="number">1</span>] &lt; left_hip[<span class="number">1</span>] &lt; left_knee[<span class="number">1</span>] &lt; left_ankle[<span class="number">1</span>] <span class="keyword">and</span></span><br><span class="line">                right_shoulder[<span class="number">1</span>] &lt; right_hip[<span class="number">1</span>] &lt; right_knee[<span class="number">1</span>] &lt; right_ankle[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> (body_height &gt; <span class="number">2</span> * bo_height):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;1站立&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果肩膀到髋部的距离大于一定比例，判定为站立</span></span><br><span class="line">            <span class="keyword">if</span> shoulder_to_hip_dist &gt; hip_to_ankle_dist * <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;2站立&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;平躺&#x27;</span></span><br><span class="line"></span><br><span class="line">        knee_angle_diff = <span class="built_in">abs</span>(left_knee_angle - right_knee_angle)</span><br><span class="line">        <span class="comment"># 2. 抬腿动作检测</span></span><br><span class="line">        <span class="keyword">if</span> (left_knee[<span class="number">1</span>] &lt; avg_hip_height <span class="keyword">or</span> right_knee[<span class="number">1</span>] &lt; avg_hip_height) <span class="keyword">and</span> (</span><br><span class="line">                left_knee_angle &lt; <span class="number">120</span> <span class="keyword">or</span> right_knee_angle &lt; <span class="number">120</span>) <span class="keyword">or</span> (knee_angle_diff &gt; <span class="number">30</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;抬腿&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 蹲下检测</span></span><br><span class="line">        <span class="keyword">if</span> (avg_knee_height &lt; avg_hip_height <span class="keyword">and</span> left_knee_angle &lt; <span class="number">150</span></span><br><span class="line">                <span class="keyword">and</span> right_knee_angle &lt; <span class="number">150</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;蹲下&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 举手判断：手腕和肩膀的高度</span></span><br><span class="line">        <span class="keyword">if</span> (left_wrist[<span class="number">1</span>] &lt; left_shoulder[<span class="number">1</span>] <span class="keyword">or</span> right_wrist[<span class="number">1</span>] &lt; right_shoulder[<span class="number">1</span>] <span class="keyword">or</span></span><br><span class="line">                left_elbow[<span class="number">1</span>] &lt; left_shoulder[<span class="number">1</span>] <span class="keyword">or</span> right_elbow[<span class="number">1</span>] &lt; right_shoulder[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;手部举起&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;未检测到正确动作&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_results_as_dicts</span>(<span class="params">self, results</span>):</span><br><span class="line">        results_list = []</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            <span class="keyword">for</span> i, box <span class="keyword">in</span> <span class="built_in">enumerate</span>(result.boxes.data):</span><br><span class="line">                cls_id = result.boxes.cls[i].item()  <span class="comment"># 获取类别ID</span></span><br><span class="line">                class_name = result.names.get(cls_id)</span><br><span class="line">                confidence = result.boxes.conf[i].item()  <span class="comment"># 获取置信度</span></span><br><span class="line">                bbox = box[:<span class="number">4</span>].tolist()  <span class="comment"># 获取边框坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 准备关键点信息</span></span><br><span class="line">                keypoints = []</span><br><span class="line">                <span class="keyword">if</span> result.keypoints.has_visible:</span><br><span class="line">                    <span class="keyword">for</span> kpt <span class="keyword">in</span> result.keypoints.data:</span><br><span class="line">                        <span class="keyword">for</span> point <span class="keyword">in</span> kpt:</span><br><span class="line">                            x, y, conf = point.tolist()</span><br><span class="line">                            keypoints.append((x, y, conf))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断姿态</span></span><br><span class="line">                pose = self.determine_pose(keypoints)</span><br><span class="line"></span><br><span class="line">                result_dict = &#123;</span><br><span class="line">                    <span class="string">&quot;class_name&quot;</span>: class_name,</span><br><span class="line">                    <span class="string">&quot;boxes&quot;</span>: bbox,</span><br><span class="line">                    <span class="string">&quot;confidence&quot;</span>: confidence,</span><br><span class="line">                    <span class="string">&quot;keypoints&quot;</span>: keypoints,</span><br><span class="line">                    <span class="string">&quot;pose&quot;</span>: pose  <span class="comment"># 增加姿态信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                results_list.append(result_dict)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键点的连接关系（COCO数据集的例子）</span></span><br><span class="line">skeleton = [</span><br><span class="line">    (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">4</span>, <span class="number">6</span>),  <span class="comment"># 头部到身体</span></span><br><span class="line">    (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">5</span>, <span class="number">7</span>), (<span class="number">7</span>, <span class="number">9</span>), (<span class="number">6</span>, <span class="number">8</span>), (<span class="number">8</span>, <span class="number">10</span>),  <span class="comment"># 身体到手臂</span></span><br><span class="line">    (<span class="number">5</span>, <span class="number">11</span>), (<span class="number">6</span>, <span class="number">12</span>), (<span class="number">11</span>, <span class="number">12</span>),  <span class="comment"># 躯干</span></span><br><span class="line">    (<span class="number">11</span>, <span class="number">13</span>), (<span class="number">12</span>, <span class="number">14</span>), (<span class="number">13</span>, <span class="number">15</span>), (<span class="number">14</span>, <span class="number">16</span>)  <span class="comment"># 躯干到腿</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv绘制结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_results</span>(<span class="params">image, results</span>):</span><br><span class="line">    height, width, _ = image.shape</span><br><span class="line">    scale_factor = height / <span class="number">500</span>  <span class="comment"># 假设基准高度为500像素</span></span><br><span class="line"></span><br><span class="line">    line_thickness = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">2</span> * scale_factor))  <span class="comment"># 线条粗细至少为1</span></span><br><span class="line">    font_scale = <span class="built_in">max</span>(<span class="number">0.5</span>, <span class="number">0.5</span> * scale_factor)  <span class="comment"># 字体缩放至少为0.5</span></span><br><span class="line">    circle_radius = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">3</span> * scale_factor))  <span class="comment"># 圆点半径至少为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">        <span class="comment"># 绘制边框和类别名</span></span><br><span class="line">        bbox = res[<span class="string">&#x27;boxes&#x27;</span>]</span><br><span class="line">        confidence = res[<span class="string">&#x27;confidence&#x27;</span>]</span><br><span class="line">        class_name = res[<span class="string">&#x27;class_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        start_point = (<span class="built_in">int</span>(bbox[<span class="number">0</span>]), <span class="built_in">int</span>(bbox[<span class="number">1</span>]))</span><br><span class="line">        end_point = (<span class="built_in">int</span>(bbox[<span class="number">2</span>]), <span class="built_in">int</span>(bbox[<span class="number">3</span>]))</span><br><span class="line">        cv.rectangle(image, start_point, end_point, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">        label = <span class="string">f&quot;<span class="subst">&#123;class_name&#125;</span>: <span class="subst">&#123;confidence:<span class="number">.2</span>f&#125;</span>&quot;</span></span><br><span class="line">        cv.putText(image, label, (start_point[<span class="number">0</span>], start_point[<span class="number">1</span>] - <span class="number">10</span>), cv.FONT_HERSHEY_SIMPLEX, font_scale,</span><br><span class="line">                   (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制关键点</span></span><br><span class="line">        keypoints = [(<span class="built_in">int</span>(kpt[<span class="number">0</span>]), <span class="built_in">int</span>(kpt[<span class="number">1</span>]), kpt[<span class="number">2</span>]) <span class="keyword">for</span> kpt <span class="keyword">in</span> res[<span class="string">&#x27;keypoints&#x27;</span>]]</span><br><span class="line">        <span class="keyword">for</span> idx, (x, y, conf) <span class="keyword">in</span> <span class="built_in">enumerate</span>(keypoints):</span><br><span class="line">            <span class="keyword">if</span> conf &gt; <span class="number">0.5</span>:</span><br><span class="line">                cv.circle(image, (x, y), circle_radius, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">                cv.putText(image, <span class="built_in">str</span>(idx), (x + <span class="number">5</span>, y + <span class="number">5</span>), cv.FONT_HERSHEY_SIMPLEX, font_scale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">                           line_thickness)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制骨架</span></span><br><span class="line">        <span class="keyword">for</span> start_idx, end_idx <span class="keyword">in</span> skeleton:</span><br><span class="line">            start_point = keypoints[start_idx]</span><br><span class="line">            end_point = keypoints[end_idx]</span><br><span class="line">            <span class="keyword">if</span> start_point[<span class="number">2</span>] &gt; <span class="number">0.5</span> <span class="keyword">and</span> end_point[<span class="number">2</span>] &gt; <span class="number">0.5</span>:</span><br><span class="line">                cv.line(image, (start_point[<span class="number">0</span>], start_point[<span class="number">1</span>]), (end_point[<span class="number">0</span>], end_point[<span class="number">1</span>]), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">                        line_thickness)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示姿态信息</span></span><br><span class="line">        pose_label = <span class="string">f&quot;姿态: <span class="subst">&#123;res[<span class="string">&#x27;pose&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># cv.putText(image, pose_label, (start_point[0], start_point[1] - 30), cv.FONT_HERSHEY_SIMPLEX, font_scale, (255, 255, 255), line_thickness)</span></span><br><span class="line"></span><br><span class="line">        image = draw_chinese_text(image, pose_label, (<span class="number">50</span>, <span class="number">50</span>), <span class="string">&quot;./STSONG.TTF&quot;</span>, <span class="number">48</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_chinese_text</span>(<span class="params">image, text, position, font_path, font_size, color</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在图像上绘制中文文本</span></span><br><span class="line"><span class="string">    :param image: OpenCV 图像</span></span><br><span class="line"><span class="string">    :param text: 要绘制的中文文本</span></span><br><span class="line"><span class="string">    :param position: 文本绘制位置 (x, y)</span></span><br><span class="line"><span class="string">    :param font_path: 字体文件路径</span></span><br><span class="line"><span class="string">    :param font_size: 字体大小</span></span><br><span class="line"><span class="string">    :param color: 文本颜色 (B, G, R)</span></span><br><span class="line"><span class="string">    :return: 绘制中文文本后的图像</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将 OpenCV 图像转换为 PIL 图像</span></span><br><span class="line">    image_pil = Image.fromarray(cv.cvtColor(image, cv.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(image_pil)</span><br><span class="line">    font = ImageFont.truetype(font_path, font_size, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制中文文本</span></span><br><span class="line">    draw.text(position, text, font=font, fill=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 PIL 图像转换回 OpenCV 图像</span></span><br><span class="line">    image = cv.cvtColor(np.array(image_pil), cv.COLOR_RGB2BGR)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频检测</span></span><br><span class="line"><span class="comment"># 修复绘制中文文本函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_chinese_text</span>(<span class="params">image, text, position, font_path, font_size, color</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在图像上绘制中文文本</span></span><br><span class="line"><span class="string">    :param image: OpenCV 图像</span></span><br><span class="line"><span class="string">    :param text: 要绘制的中文文本</span></span><br><span class="line"><span class="string">    :param position: 文本绘制位置 (x, y)</span></span><br><span class="line"><span class="string">    :param font_path: 字体文件路径</span></span><br><span class="line"><span class="string">    :param font_size: 字体大小</span></span><br><span class="line"><span class="string">    :param color: 文本颜色 (B, G, R)</span></span><br><span class="line"><span class="string">    :return: 绘制中文文本后的图像</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将 OpenCV 图像转换为 PIL 图像</span></span><br><span class="line">    image_pil = Image.fromarray(cv.cvtColor(image, cv.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(image_pil)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        font = ImageFont.truetype(font_path, font_size, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;字体加载错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果字体加载失败，返回原图</span></span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制中文文本</span></span><br><span class="line">    draw.text(position, text, font=font, fill=color[::-<span class="number">1</span>])  <span class="comment"># 颜色需要转换BGR到RGB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 PIL 图像转换回 OpenCV 图像并返回</span></span><br><span class="line">    <span class="keyword">return</span> cv.cvtColor(np.array(image_pil), cv.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复绘制结果函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_results</span>(<span class="params">image, results</span>):</span><br><span class="line">    <span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(image.shape) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无效的输入图像&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    height, width, _ = image.shape</span><br><span class="line">    scale_factor = height / <span class="number">500</span>  <span class="comment"># 假设基准高度为500像素</span></span><br><span class="line"></span><br><span class="line">    line_thickness = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">2</span> * scale_factor))  <span class="comment"># 线条粗细至少为1</span></span><br><span class="line">    font_scale = <span class="built_in">max</span>(<span class="number">0.5</span>, <span class="number">0.5</span> * scale_factor)  <span class="comment"># 字体缩放至少为0.5</span></span><br><span class="line">    circle_radius = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">3</span> * scale_factor))  <span class="comment"># 圆点半径至少为1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建图像副本以避免修改原图</span></span><br><span class="line">    image_with_results = image.copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 绘制边框和类别名</span></span><br><span class="line">            bbox = res[<span class="string">&#x27;boxes&#x27;</span>]</span><br><span class="line">            confidence = res[<span class="string">&#x27;confidence&#x27;</span>]</span><br><span class="line">            class_name = res[<span class="string">&#x27;class_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            start_point = (<span class="built_in">int</span>(bbox[<span class="number">0</span>]), <span class="built_in">int</span>(bbox[<span class="number">1</span>]))</span><br><span class="line">            end_point = (<span class="built_in">int</span>(bbox[<span class="number">2</span>]), <span class="built_in">int</span>(bbox[<span class="number">3</span>]))</span><br><span class="line">            cv.rectangle(image_with_results, start_point, end_point, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">            label = <span class="string">f&quot;<span class="subst">&#123;class_name&#125;</span>: <span class="subst">&#123;confidence:<span class="number">.2</span>f&#125;</span>&quot;</span></span><br><span class="line">            cv.putText(image_with_results, label, (start_point[<span class="number">0</span>], start_point[<span class="number">1</span>] - <span class="number">10</span>),</span><br><span class="line">                       cv.FONT_HERSHEY_SIMPLEX, font_scale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绘制关键点</span></span><br><span class="line">            keypoints = [(<span class="built_in">int</span>(kpt[<span class="number">0</span>]), <span class="built_in">int</span>(kpt[<span class="number">1</span>]), kpt[<span class="number">2</span>]) <span class="keyword">for</span> kpt <span class="keyword">in</span> res[<span class="string">&#x27;keypoints&#x27;</span>]]</span><br><span class="line">            <span class="keyword">for</span> idx, (x, y, conf) <span class="keyword">in</span> <span class="built_in">enumerate</span>(keypoints):</span><br><span class="line">                <span class="keyword">if</span> conf &gt; <span class="number">0.2</span>:</span><br><span class="line">                    cv.circle(image_with_results, (x, y), circle_radius, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">                    cv.putText(image_with_results, <span class="built_in">str</span>(idx), (x + <span class="number">5</span>, y + <span class="number">5</span>),</span><br><span class="line">                               cv.FONT_HERSHEY_SIMPLEX, font_scale, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绘制骨架</span></span><br><span class="line">            <span class="keyword">for</span> start_idx, end_idx <span class="keyword">in</span> skeleton:</span><br><span class="line">                start_point = keypoints[start_idx]</span><br><span class="line">                end_point = keypoints[end_idx]</span><br><span class="line">                <span class="keyword">if</span> start_point[<span class="number">2</span>] &gt; <span class="number">0.5</span> <span class="keyword">and</span> end_point[<span class="number">2</span>] &gt; <span class="number">0.5</span>:</span><br><span class="line">                    cv.line(image_with_results, (start_point[<span class="number">0</span>], start_point[<span class="number">1</span>]),</span><br><span class="line">                            (end_point[<span class="number">0</span>], end_point[<span class="number">1</span>]), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), line_thickness)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 显示姿态信息</span></span><br><span class="line">            pose_label = <span class="string">f&quot;姿态: <span class="subst">&#123;res[<span class="string">&#x27;pose&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">            <span class="comment"># 使用修复后的draw_chinese_text函数</span></span><br><span class="line">            image_with_results = draw_chinese_text(</span><br><span class="line">                image_with_results,</span><br><span class="line">                pose_label,</span><br><span class="line">                (<span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">                <span class="string">&quot;./STSONG.TTF&quot;</span>,</span><br><span class="line">                <span class="number">48</span>,</span><br><span class="line">                (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;绘制结果时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_with_results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片检测</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    yolov8 = YOLOv8Pose(model_path=<span class="string">&#x27;yolov8x-pose.pt&#x27;</span>, device=<span class="string">&#x27;cpu&#x27;</span>, conf=<span class="number">0.25</span>, iou=<span class="number">0.7</span>)</span><br><span class="line">    <span class="comment"># imgs = [&quot;img_2.png&quot;]</span></span><br><span class="line">    img_folder = <span class="string">&quot;./test/&quot;</span></span><br><span class="line">    output_folder = <span class="string">&quot;./test_run/&quot;</span></span><br><span class="line"></span><br><span class="line">    imgs = [os.path.join(img_folder, img) <span class="keyword">for</span> img <span class="keyword">in</span> os.listdir(img_folder) <span class="keyword">if</span> img.endswith((<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span>))]</span><br><span class="line">    <span class="comment"># 存储处理后的图片结果</span></span><br><span class="line">    processed_images = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理每张图片并存储结果</span></span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> imgs:</span><br><span class="line">        img = cv.imread(img_path)</span><br><span class="line">        results = yolov8.detect(img_path)</span><br><span class="line">        results_ = yolov8.get_results_as_dicts(results)</span><br><span class="line">        img_with_results = draw_results(img, results_)</span><br><span class="line">        processed_images.append(img_with_results)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存处理后的图片到输出文件夹</span></span><br><span class="line">        output_path = os.path.join(output_folder, os.path.basename(img_path))</span><br><span class="line">        cv.imwrite(output_path, img_with_results)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每张图片的显示尺寸</span></span><br><span class="line">    max_width = <span class="number">600</span></span><br><span class="line">    <span class="keyword">for</span> idx, img_result <span class="keyword">in</span> <span class="built_in">enumerate</span>(processed_images):</span><br><span class="line">        height = <span class="built_in">int</span>(img_result.shape[<span class="number">0</span>] * (max_width / img_result.shape[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> height &gt; <span class="number">900</span>:</span><br><span class="line">            height = <span class="number">900</span></span><br><span class="line">            max_width = <span class="built_in">int</span>(img_result.shape[<span class="number">1</span>] * (height / img_result.shape[<span class="number">0</span>]))</span><br><span class="line">        processed_images[idx] = cv.resize(img_result, (max_width, height))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示每张图片的处理结果在独立窗口中</span></span><br><span class="line">    <span class="keyword">for</span> idx, img_result <span class="keyword">in</span> <span class="built_in">enumerate</span>(processed_images):</span><br><span class="line">        cv.imshow(<span class="string">f&#x27;Processed Image <span class="subst">&#123;idx + <span class="number">1</span>&#125;</span>&#x27;</span>, img_result)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 视频处理主函数</span></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     # 初始化模型</span></span><br><span class="line"><span class="comment">#     yolov8 = YOLOv8Pose(model_path=&#x27;yolov8x-pose.pt&#x27;, device=&#x27;cpu&#x27;, conf=0.25, iou=0.7)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 设置输入和输出视频路径</span></span><br><span class="line"><span class="comment">#     input_video_path = &quot;test.mp4&quot;  # 替换为你的输入视频路径</span></span><br><span class="line"><span class="comment">#     output_video_path = &quot;output_video.mp4&quot;  # 输出视频的保存路径</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 打开视频文件</span></span><br><span class="line"><span class="comment">#     cap = cv.VideoCapture(input_video_path)</span></span><br><span class="line"><span class="comment">#     if not cap.isOpened():</span></span><br><span class="line"><span class="comment">#         print(f&quot;无法打开视频文件: &#123;input_video_path&#125;&quot;)</span></span><br><span class="line"><span class="comment">#         exit()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 获取视频的基本信息</span></span><br><span class="line"><span class="comment">#     frame_width = int(cap.get(cv.CAP_PROP_FRAME_WIDTH))</span></span><br><span class="line"><span class="comment">#     frame_height = int(cap.get(cv.CAP_PROP_FRAME_HEIGHT))</span></span><br><span class="line"><span class="comment">#     fps = int(cap.get(cv.CAP_PROP_FPS))</span></span><br><span class="line"><span class="comment">#     total_frames = int(cap.get(cv.CAP_PROP_FRAME_COUNT))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     print(f&quot;视频信息: &#123;frame_width&#125;x&#123;frame_height&#125; @ &#123;fps&#125;fps, 总帧数: &#123;total_frames&#125;&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 创建视频写入器</span></span><br><span class="line"><span class="comment">#     fourcc = cv.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span></span><br><span class="line"><span class="comment">#     out = cv.VideoWriter(output_video_path, fourcc, fps, (frame_width, frame_height))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     processed_frames = 0</span></span><br><span class="line"><span class="comment">#     temp_img_path = &quot;temp_frame.jpg&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         while cap.isOpened():</span></span><br><span class="line"><span class="comment">#             ret, frame = cap.read()</span></span><br><span class="line"><span class="comment">#             if not ret:</span></span><br><span class="line"><span class="comment">#                 print(&quot;\n到达视频结尾&quot;)</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             try:</span></span><br><span class="line"><span class="comment">#                 # 确保帧是有效的</span></span><br><span class="line"><span class="comment">#                 if frame is None or frame.size == 0:</span></span><br><span class="line"><span class="comment">#                     print(f&quot;\n无效帧 &#123;processed_frames&#125;&quot;)</span></span><br><span class="line"><span class="comment">#                     processed_frames += 1</span></span><br><span class="line"><span class="comment">#                     continue</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                 # 保存和处理当前帧</span></span><br><span class="line"><span class="comment">#                 cv.imwrite(temp_img_path, frame)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                 # 检查临时文件是否成功创建</span></span><br><span class="line"><span class="comment">#                 if not os.path.exists(temp_img_path):</span></span><br><span class="line"><span class="comment">#                     print(f&quot;\n临时文件创建失败，跳过帧 &#123;processed_frames&#125;&quot;)</span></span><br><span class="line"><span class="comment">#                     processed_frames += 1</span></span><br><span class="line"><span class="comment">#                     continue</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                 # 进行检测</span></span><br><span class="line"><span class="comment">#                 results = yolov8.detect(temp_img_path)</span></span><br><span class="line"><span class="comment">#                 results_ = yolov8.get_results_as_dicts(results)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                 # 绘制结果</span></span><br><span class="line"><span class="comment">#                 frame_with_results = draw_results(frame, results_)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                 if frame_with_results is not None:</span></span><br><span class="line"><span class="comment">#                     # 写入处理后的帧</span></span><br><span class="line"><span class="comment">#                     out.write(frame_with_results)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                     # 显示处理进度</span></span><br><span class="line"><span class="comment">#                     processed_frames += 1</span></span><br><span class="line"><span class="comment">#                     progress = (processed_frames / total_frames) * 100</span></span><br><span class="line"><span class="comment">#                     print(f&quot;\r处理进度: &#123;progress:.2f&#125;%&quot;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                     # 显示预览</span></span><br><span class="line"><span class="comment">#                     cv.imshow(&#x27;Video Processing&#x27;, frame_with_results)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                     if cv.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;):</span></span><br><span class="line"><span class="comment">#                         print(&quot;\n用户中断处理&quot;)</span></span><br><span class="line"><span class="comment">#                         break</span></span><br><span class="line"><span class="comment">#                 else:</span></span><br><span class="line"><span class="comment">#                     print(f&quot;\n帧 &#123;processed_frames&#125; 处理失败&quot;)</span></span><br><span class="line"><span class="comment">#                     processed_frames += 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             except Exception as e:</span></span><br><span class="line"><span class="comment">#                 print(f&quot;\n处理帧 &#123;processed_frames&#125; 时发生错误: &#123;str(e)&#125;&quot;)</span></span><br><span class="line"><span class="comment">#                 processed_frames += 1</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     except Exception as e:</span></span><br><span class="line"><span class="comment">#         print(f&quot;\n处理视频时发生错误: &#123;str(e)&#125;&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     finally:</span></span><br><span class="line"><span class="comment">#         # 清理资源</span></span><br><span class="line"><span class="comment">#         print(f&quot;\n处理完成，共处理 &#123;processed_frames&#125; 帧&quot;)</span></span><br><span class="line"><span class="comment">#         cap.release()</span></span><br><span class="line"><span class="comment">#         out.release()</span></span><br><span class="line"><span class="comment">#         cv.destroyAllWindows()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 删除临时文件</span></span><br><span class="line"><span class="comment">#         if os.path.exists(temp_img_path):</span></span><br><span class="line"><span class="comment">#             try:</span></span><br><span class="line"><span class="comment">#                 os.remove(temp_img_path)</span></span><br><span class="line"><span class="comment">#             except Exception as e:</span></span><br><span class="line"><span class="comment">#                 print(f&quot;删除临时文件时发生错误: &#123;str(e)&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 摄像头检测</span></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     # 初始化模型</span></span><br><span class="line"><span class="comment">#     yolov8 = YOLOv8Pose(model_path=&#x27;yolov8n-pose.pt&#x27;, device=&#x27;cpu&#x27;, conf=0.25, iou=0.7)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 打开摄像头</span></span><br><span class="line"><span class="comment">#     cap = cv.VideoCapture(0)  # 使用默认摄像头，如果有多个摄像头可以改变参数</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         # 读取摄像头帧</span></span><br><span class="line"><span class="comment">#         ret, frame = cap.read()</span></span><br><span class="line"><span class="comment">#         if not ret:</span></span><br><span class="line"><span class="comment">#             print(&quot;无法读取摄像头画面&quot;)</span></span><br><span class="line"><span class="comment">#             break</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 保存当前帧到临时文件</span></span><br><span class="line"><span class="comment">#         temp_img_path = &quot;temp_frame.jpg&quot;</span></span><br><span class="line"><span class="comment">#         cv.imwrite(temp_img_path, frame)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 进行检测</span></span><br><span class="line"><span class="comment">#         results = yolov8.detect(temp_img_path)</span></span><br><span class="line"><span class="comment">#         results_ = yolov8.get_results_as_dicts(results)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 绘制结果</span></span><br><span class="line"><span class="comment">#         frame_with_results = draw_results(frame, results_)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 显示结果</span></span><br><span class="line"><span class="comment">#         cv.imshow(&#x27;实时姿态检测&#x27;, frame_with_results)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         # 按&#x27;q&#x27;键退出</span></span><br><span class="line"><span class="comment">#         if cv.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;):</span></span><br><span class="line"><span class="comment">#             break</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # 释放资源</span></span><br><span class="line"><span class="comment">#     cap.release()</span></span><br><span class="line"><span class="comment">#     cv.destroyAllWindows()</span></span><br></pre></td></tr></table></figure><p>此外，里面用到的<code>yolov8l-pose.pt、 yolov8n-pose.pt、 yolov8x-pose.pt</code>这几个模型，可以自己进行训练或者更替为其他模型，这几个模型可以在网上自己下载喔~</p><p>那么，祝你用餐愉快~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目地址1：&lt;a href=&quot;https://www.codewithgpu.com/i/CMU-Perceptual-Computing-Lab/openpose/openpose&quot;&gt;openpose镜像，需要在云服务器上微调&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址2：&lt;a hr</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>yolov8使用心得/包含类别ID转换脚本</title>
    <link href="https://sherry14love.github.io/2024/11/09/learn/yolov8/"/>
    <id>https://sherry14love.github.io/2024/11/09/learn/yolov8/</id>
    <published>2024-11-08T16:00:00.000Z</published>
    <updated>2024-11-13T01:44:05.048Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://www.codewithgpu.com/i/ultralytics/ultralytics/yolov8">yolov8镜像一键部署运行与云服务器</a></p><h2 id="数据标注工具"><a class="markdownIt-Anchor" href="#数据标注工具"></a> 数据标注工具</h2><p>针对与yolo系列模型，拉姆推荐使用LabelImg，而框框可以旋转的roLabelImg或者多边形标记的labelme拉姆都不推荐，因为到最后的yolo格式需要自己转换，并且效果不好</p><p><s>仅针对于拉姆自己数据集的测试</s></p><blockquote><p>YOLO格式:类别ID和边界框坐标（中心x, 中心y, 宽度, 高度）</p></blockquote><p>对于标签类别ID，有的时候会很乱，比如，person的ID应该为83，但实际上，在使用LabelImg标签标记的时候是0，所以，可以用下面的脚本来创建一个字典映射进行更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义字符映射字典</span></span><br><span class="line">char_mapping = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;83&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;84&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入和输出文件夹路径</span></span><br><span class="line">input_folder = <span class="string">r&#x27;F:\work\1&#x27;</span> <span class="comment"># 请改成自己的输入路径</span></span><br><span class="line">output_folder = <span class="string">r&#x27;F:\work\2&#x27;</span> <span class="comment"># 请改成自己的输出路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保输出文件夹存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_folder):</span><br><span class="line">    os.makedirs(output_folder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输入文件夹中的所有.txt文件</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(input_folder):</span><br><span class="line">    <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">        input_file_path = os.path.join(input_folder, filename)</span><br><span class="line">        output_file_path = os.path.join(output_folder, filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件内容</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            lines = file.readlines()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理每一行从第一个字符到第一个空格结束的部分</span></span><br><span class="line">        modified_lines = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="comment"># 查找第一个空格的位置</span></span><br><span class="line">            space_index = line.find(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> space_index != -<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 获取从第一个字符到第一个空格的部分</span></span><br><span class="line">                first_part = line[:space_index]</span><br><span class="line">                <span class="comment"># 进行映射替换</span></span><br><span class="line">                modified_first_part = char_mapping.get(first_part, first_part)</span><br><span class="line">                <span class="comment"># 替换并添加到修改后的行列表中</span></span><br><span class="line">                modified_line = modified_first_part + line[space_index:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有空格，直接进行映射替换</span></span><br><span class="line">                modified_line = char_mapping.get(line.strip(), line.strip())</span><br><span class="line">            modified_lines.append(modified_line)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将修改后的内容写入输出文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.writelines(modified_lines)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;处理完成，结果已保存到&quot;</span>, output_folder)</span><br></pre></td></tr></table></figure><p><em>注意更改为自己的路径哦~</em></p><p>当然你如果想用多边形标记工具labelme（这个只能保存为json格式）</p><p>拉姆也有两个脚本，可以进行转正为yolo模型可以识别的相对路径txt格式：</p><p>脚本一：将json转换成txt格式，因为labelme标签ID为自己输入的字母或者其他字符而不是类别ID，所以还需要脚本二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_folder_path = <span class="string">r&#x27;F:\work\1\images&#x27;</span>  <span class="comment"># 图片存放文件夹</span></span><br><span class="line">folder_path = <span class="string">r&quot;F:\work\1\label&quot;</span>  <span class="comment"># 标注数据的文件地址</span></span><br><span class="line">txt_folder_path = <span class="string">r&quot;F:\work\1\txt&quot;</span>  <span class="comment"># 转换后的txt标签文件存放的文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为相对坐标形式 :label x_center y_center w h</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relative_coordinate_txt</span>(<span class="params">img_name, json_d, img_path</span>):</span><br><span class="line">    src_img = cv2.imread(img_path)</span><br><span class="line">    <span class="keyword">if</span> src_img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Failed to read image: <span class="subst">&#123;img_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    h, w = src_img.shape[:<span class="number">2</span>]</span><br><span class="line">    txt_name = img_name.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;.txt&quot;</span></span><br><span class="line">    txt_path = os.path.join(txt_folder_path, txt_name)</span><br><span class="line">    <span class="built_in">print</span>(txt_path)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(txt_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> json_d[<span class="string">&quot;shapes&quot;</span>]:</span><br><span class="line">            point = item[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line">            <span class="comment"># 确保 point[0] 和 point[1] 的坐标值正确</span></span><br><span class="line">            x1, y1 = point[<span class="number">0</span>]</span><br><span class="line">            x2, y2 = point[<span class="number">1</span>]</span><br><span class="line">            x_min = <span class="built_in">min</span>(x1, x2)</span><br><span class="line">            x_max = <span class="built_in">max</span>(x1, x2)</span><br><span class="line">            y_min = <span class="built_in">min</span>(y1, y2)</span><br><span class="line">            y_max = <span class="built_in">max</span>(y1, y2)</span><br><span class="line"></span><br><span class="line">            x_center = (x_min + x_max) / <span class="number">2</span></span><br><span class="line">            y_center = (y_min + y_max) / <span class="number">2</span></span><br><span class="line">            width = x_max - x_min</span><br><span class="line">            height = y_max - y_min</span><br><span class="line"></span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(item[<span class="string">&#x27;label&#x27;</span>]))</span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(x_center / w))</span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(y_center / h))</span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(width / w))</span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125; &quot;</span>.<span class="built_in">format</span>(height / h))</span><br><span class="line">            f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> jsonfile <span class="keyword">in</span> os.listdir(folder_path):</span><br><span class="line">    temp_path = os.path.join(folder_path, jsonfile)</span><br><span class="line"></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># if i &gt; 5:</span></span><br><span class="line">    <span class="comment">#     break</span></span><br><span class="line">    <span class="comment"># 如果是一个子目录就继续</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(temp_path):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;json_path:\t&quot;</span>, temp_path)</span><br><span class="line">    jsonfile_path = temp_path</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(jsonfile_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json_d = json.load(f)</span><br><span class="line">        <span class="comment"># 保留原始扩展名，而不是强制转换为.jpeg，支持各类图片的格式</span></span><br><span class="line">        img_name = json_d[<span class="string">&#x27;imagePath&#x27;</span>].split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">        img_path = os.path.join(img_folder_path, img_name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;img_path:\t&quot;</span>, img_path)</span><br><span class="line">        relative_coordinate_txt(img_name, json_d, img_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>脚本二：处理labelme标签ID，将其转换为类别ID</p><!-- 脚本二：读取类别ID为字母而非数字的txt并改成可以被识别yolo格式 --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_label_files</span>(<span class="params">input_dir, output_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理标签文件，将特定标签名称转换为数字编号</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_dir: 输入文件夹路径</span></span><br><span class="line"><span class="string">        output_dir: 输出文件夹路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建标签映射字典</span></span><br><span class="line">    label_mapping = &#123;</span><br><span class="line">        <span class="string">&#x27;person&#x27;</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ECGmonitor&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;patientBed&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;bedsideTable&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;patient&#x27;</span>: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">        <span class="comment"># 可以根据需要添加更多映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">        os.makedirs(output_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历输入目录中的所有txt文件</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(input_dir):</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            input_path = os.path.join(input_dir, filename)</span><br><span class="line">            output_path = os.path.join(output_dir, filename)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 读取并处理文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(input_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                lines = f.readlines()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理每一行</span></span><br><span class="line">            processed_lines = []</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                parts = line.strip().split()</span><br><span class="line">                <span class="keyword">if</span> parts:  <span class="comment"># 确保行不为空</span></span><br><span class="line">                    <span class="comment"># 替换标签</span></span><br><span class="line">                    <span class="keyword">if</span> parts[<span class="number">0</span>] <span class="keyword">in</span> label_mapping:</span><br><span class="line">                        parts[<span class="number">0</span>] = label_mapping[parts[<span class="number">0</span>]]</span><br><span class="line">                    processed_line = <span class="string">&#x27; &#x27;</span>.join(parts)</span><br><span class="line">                    processed_lines.append(processed_line + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 写入新文件</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.writelines(processed_lines)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径更改</span></span><br><span class="line">input_directory = <span class="string">r&#x27;F:\work\1&#x27;</span> <span class="comment"># 改为自己的输入路径</span></span><br><span class="line">output_directory = <span class="string">r&#x27;F:\work\2&#x27;</span> <span class="comment"># 改为自己的输出路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process_label_files(input_directory, output_directory)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;处理完成！文件已保存到: <span class="subst">&#123;output_directory&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;处理过程中出现错误: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a class="markdownIt-Anchor" href="#训练模型"></a> 训练模型</h2><ol><li>首先在终端进入目录：ultralytics-8.3.27，在终端输入命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ultralytics-8.3.27</span><br></pre></td></tr></table></figure><ol start="2"><li>在ultralytics-8.3.27里找到train_v8.py文件，更改其代码：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">opt</span>):</span><br><span class="line">    yaml_path = opt.cfg</span><br><span class="line">    weights = opt.weights</span><br><span class="line">    config_path = opt.config</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加载配置文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(config_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        config = yaml.safe_load(f)</span><br><span class="line">    </span><br><span class="line">    model = YOLO(yaml_path).load(weights)</span><br><span class="line">    model.info()</span><br><span class="line">    </span><br><span class="line">    results = model.train(**config)  <span class="comment"># 使用配置文件中的所有参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_opt</span>(<span class="params">known=<span class="literal">False</span></span>):</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--cfg&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;ultralytics/cfg/models/v8/yolov8.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;model.yaml path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weights&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;weights path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--config&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;config.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;training config file&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    opt = parser.parse_known_args()[<span class="number">0</span>] <span class="keyword">if</span> known <span class="keyword">else</span> parser.parse_args()</span><br><span class="line">    <span class="keyword">return</span> opt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    opt = parse_opt()</span><br><span class="line">    main(opt)</span><br></pre></td></tr></table></figure><ol start="3"><li>在ultralytics-8.3.27上传配置文件coco128.yaml(可以根据自己的需求进行更改)</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集位置</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">../datasets/coco128</span> <span class="comment"># dataset root dir</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train2017</span> <span class="comment"># train images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/train2017</span> <span class="comment"># val images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">test:</span> <span class="comment"># test images (optional)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签数量</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">86</span> </span><br><span class="line"><span class="comment"># 标签名字</span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;motorcycle&#x27;</span>, <span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;traffic light&#x27;</span>, <span class="string">&#x27;fire hydrant&#x27;</span>, <span class="string">&#x27;stop sign&#x27;</span>, <span class="string">&#x27;parking meter&#x27;</span>, <span class="string">&#x27;bench&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>, <span class="string">&#x27;backpack&#x27;</span>, <span class="string">&#x27;umbrella&#x27;</span>, <span class="string">&#x27;handbag&#x27;</span>, <span class="string">&#x27;tie&#x27;</span>, <span class="string">&#x27;suitcase&#x27;</span>, <span class="string">&#x27;frisbee&#x27;</span>, <span class="string">&#x27;skis&#x27;</span>, <span class="string">&#x27;snowboard&#x27;</span>, <span class="string">&#x27;sports ball&#x27;</span>, <span class="string">&#x27;kite&#x27;</span>, <span class="string">&#x27;baseball bat&#x27;</span>, <span class="string">&#x27;baseball glove&#x27;</span>, <span class="string">&#x27;skateboard&#x27;</span>, <span class="string">&#x27;surfboard&#x27;</span>, <span class="string">&#x27;tennis racket&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;wine glass&#x27;</span>, <span class="string">&#x27;cup&#x27;</span>, <span class="string">&#x27;fork&#x27;</span>, <span class="string">&#x27;knife&#x27;</span>, <span class="string">&#x27;spoon&#x27;</span>, <span class="string">&#x27;bowl&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;sandwich&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>, <span class="string">&#x27;hot dog&#x27;</span>, <span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;donut&#x27;</span>, <span class="string">&#x27;cake&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;couch&#x27;</span>, <span class="string">&#x27;potted plant&#x27;</span>, <span class="string">&#x27;patientBed&#x27;</span>, <span class="string">&#x27;dining table&#x27;</span>, <span class="string">&#x27;toilet&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>, <span class="string">&#x27;laptop&#x27;</span>, <span class="string">&#x27;mouse&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>, <span class="string">&#x27;keyboard&#x27;</span>, <span class="string">&#x27;cell phone&#x27;</span>, <span class="string">&#x27;microwave&#x27;</span>, <span class="string">&#x27;oven&#x27;</span>, <span class="string">&#x27;toaster&#x27;</span>, <span class="string">&#x27;sink&#x27;</span>, <span class="string">&#x27;refrigerator&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">&#x27;vase&#x27;</span>, <span class="string">&#x27;scissors&#x27;</span>, <span class="string">&#x27;teddy bear&#x27;</span>, <span class="string">&#x27;hair drier&#x27;</span>, <span class="string">&#x27;toothbrush&#x27;</span>, <span class="string">&#x27;patient&#x27;</span>, <span class="string">&#x27;bedsideTable&#x27;</span>, <span class="string">&#x27;ECGmonitor&#x27;</span>, <span class="string">&#x27;curtain&#x27;</span>, <span class="string">&#x27;barcode&#x27;</span>,<span class="string">&#x27;QRcode&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>在ultralytics-8.3.27上传配置文件config.yaml</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任务类型：目标检测</span></span><br><span class="line"><span class="attr">task:</span> <span class="string">detect</span></span><br><span class="line"><span class="comment"># 运行模式：训练</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">train</span></span><br><span class="line"><span class="comment"># 预训练模型：YOLOv8 Nano版本</span></span><br><span class="line"><span class="attr">model:</span> <span class="string">yolov8n.pt</span></span><br><span class="line"><span class="comment"># 数据集配置文件：COCO128数据集</span></span><br><span class="line"><span class="attr">data:</span> <span class="string">coco128.yaml</span></span><br><span class="line"><span class="comment"># 训练轮数：300轮</span></span><br><span class="line"><span class="attr">epochs:</span> <span class="number">300</span></span><br><span class="line"><span class="comment"># 输入图像尺寸：640x640像素</span></span><br><span class="line"><span class="attr">imgsz:</span> <span class="number">640</span></span><br><span class="line"><span class="comment"># 数据加载线程数：8个</span></span><br><span class="line"><span class="attr">workers:</span> <span class="number">8</span></span><br><span class="line"><span class="comment"># 批次样本数量：8个</span></span><br><span class="line"><span class="attr">batch:</span> <span class="number">8</span></span><br><span class="line"><span class="comment"># 初始学习率：0.0005</span></span><br><span class="line"><span class="attr">lr0:</span> <span class="number">0.0005</span></span><br><span class="line"><span class="comment"># 最终学习率：0.0005</span></span><br><span class="line"><span class="attr">lrf:</span> <span class="number">0.0005</span></span><br><span class="line"><span class="comment"># 动量参数：0.937</span></span><br><span class="line"><span class="attr">momentum:</span> <span class="number">0.937</span></span><br><span class="line"><span class="comment"># 权重衰减系数：0.0005</span></span><br><span class="line"><span class="attr">weight_decay:</span> <span class="number">0.0005</span></span><br><span class="line"><span class="comment"># 学习率预热轮数：3轮</span></span><br><span class="line"><span class="attr">warmup_epochs:</span> <span class="number">3.0</span></span><br><span class="line"><span class="comment"># 预热阶段动量参数：0.8</span></span><br><span class="line"><span class="attr">warmup_momentum:</span> <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 预热阶段偏置项学习率：0.0001</span></span><br><span class="line"><span class="attr">warmup_bias_lr:</span> <span class="number">0.0001</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p>记得更改ultralytics-8.3.27/ultralytics/cfg/models/v8/目录下的yolov8.yaml，将nc：80改成nc: 86（也就是你自己的标签数量）</p></li><li><p>最后进行模型的训练，在终端命令输入训练命令：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_v8.py --cfg ultralytics/cfg/models/v8/yolov8.yaml --weights yolov8n.pt --config config.yaml</span><br></pre></td></tr></table></figure><h2 id="模型预测"><a class="markdownIt-Anchor" href="#模型预测"></a> 模型预测</h2><ol><li>在ultralytics-8.3.27里找到predict.py文件，我们需要把进行一点路径更改：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = YOLO(<span class="string">&#x27;runs/detect/train/weights/best.pt&#x27;</span>)  <span class="comment"># 训练好的模型位置</span></span><br><span class="line">model.predict(<span class="string">&#x27;datasets/coco128/images/train2017/&#x27;</span>, save=<span class="literal">True</span>, imgsz=<span class="number">640</span>, conf=<span class="number">0.5</span>) <span class="comment"># 你的预测数据的位置</span></span><br></pre></td></tr></table></figure><ol start="2"><li>predict.py里上面的路径也需要更改一下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">&#x27;/root/ultralytics-8.3.27/&#x27;</span>) <span class="comment"># Path 以Autodl为例</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在终端输入命令开始预测</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python predict.py</span><br></pre></td></tr></table></figure><h2 id="收梢"><a class="markdownIt-Anchor" href="#收梢"></a> 收梢</h2><p>在云服务器上进行训练还是很ok的，又便宜又快，比本地部署好用多了，就是需要一点略微花费。</p><p><s>数据标注真费事</s></p><p>阿门，下次有机会拉姆写写OCR或者MiniCPM-V-2.6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目地址：&lt;a href=&quot;https://www.codewithgpu.com/i/ultralytics/ultralytics/yolov8&quot;&gt;yolov8镜像一键部署运行与云服务器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据标注工具&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java--Relearn</title>
    <link href="https://sherry14love.github.io/2024/09/26/learn/JavaRelearn/"/>
    <id>https://sherry14love.github.io/2024/09/26/learn/JavaRelearn/</id>
    <published>2024-09-25T16:00:00.000Z</published>
    <updated>2024-10-17T10:17:21.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合框架"><a class="markdownIt-Anchor" href="#集合框架"></a> 集合框架</h2><p>Java的集合框架分为Collection、Map</p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><pre><code>      Collection      /    |    \   List   Set   Queue    |      |      |</code></pre><p>ArrayList  HashSet  LinkedList<br />LinkedList TreeSet  PriorityQueue<br /><br />Deque<br />|<br />ArrayDeque</p><hr /><p>对不起，已乱码鐨勫皬鏍戝眿紝涓氬姟鍒嗘瀽宸叉垚涓轰紒涓氬喅绛栧拰鎴樼暐鍒跺畾鐨勬牳蹇冦€傛湰鏂囧皢浠嬬粛涔濈甯哥敤鐨勪笟鍔″垎鏋愭柟娉曪紝杩欎簺鏂规硶鑳藉府鍔╁垎鏋</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合框架&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集合框架&quot;&gt;&lt;/a&gt; 集合框架&lt;/h2&gt;
&lt;p&gt;Java的集合框架分为Collection、Map&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之业务拆解和分析</title>
    <link href="https://sherry14love.github.io/2024/09/06/learn/business/"/>
    <id>https://sherry14love.github.io/2024/09/06/learn/business/</id>
    <published>2024-09-05T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:00.361Z</updated>
    
    <content type="html"><![CDATA[<p>在当今数据驱动的商业环境中，业务分析已成为企业决策和战略制定的核心。本文将介绍九种常用的业务分析方法，这些方法能帮助分析师和管理者更好地理解复杂的业务问题，并制定有效的解决方案。</p><h2 id="mece原则业务拆解的基础"><a class="markdownIt-Anchor" href="#mece原则业务拆解的基础"></a> MECE原则：业务拆解的基础</h2><p>在开始介绍具体的分析方法之前，我们需要了解MECE原则。MECE是&quot;Mutually Exclusive Collectively Exhaustive&quot;的缩写，意为&quot;相互独立，完全穷尽&quot;。这个原则要求我们在分析问题时，将问题分解为不重叠（相互独立）且无遗漏（完全穷尽）的部分。遵循MECE原则可以帮助我们更系统、全面地分析问题。</p><h2 id="九种常用业务分析方法"><a class="markdownIt-Anchor" href="#九种常用业务分析方法"></a> 九种常用业务分析方法</h2><h3 id="流程拆解法"><a class="markdownIt-Anchor" href="#流程拆解法"></a> 流程拆解法</h3><p>流程拆解法是将复杂的业务流程按时间顺序或逻辑顺序分解为一系列步骤。这种方法特别适用于优化业务流程、识别瓶颈和改进效率。</p><p><strong>应用步骤：</strong></p><ol><li>确定流程范围</li><li>详细描述每个步骤</li><li>绘制流程图</li><li>识别关键环节</li><li>分析和优化每个步骤</li></ol><p><strong>示例：</strong> 分析电子商务网站的用户购买流程：浏览商品 -&gt; 加入购物车 -&gt; 结算 -&gt; 支付 -&gt; 确认订单</p><h3 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h3><p>二分法是将问题或数据集分为两个互斥的部分进行分析。这种方法有助于简化复杂问题，快速聚焦关键因素。</p><p><strong>应用示例：</strong></p><ul><li>将客户群分为新客户和老客户</li><li>将产品线分为高端产品和大众产品</li><li>将市场分为线上渠道和线下渠道</li></ul><h3 id="象限拆解法"><a class="markdownIt-Anchor" href="#象限拆解法"></a> 象限拆解法</h3><p>象限拆解法使用两个维度将数据或问题分为四个象限，有助于进行分类分析和优先级排序。</p><p><strong>应用示例：</strong><br />使用&quot;重要性&quot;和&quot;紧急性&quot;两个维度对任务进行分类：</p><ul><li>第一象限：重要且紧急</li><li>第二象限：重要但不紧急</li><li>第三象限：紧急但不重要</li><li>第四象限：既不重要也不紧急</li></ul><h3 id="杜邦分析法"><a class="markdownIt-Anchor" href="#杜邦分析法"></a> 杜邦分析法</h3><p>杜邦分析法是一种财务分析工具，通过分解净资产收益率（ROE）来评估公司的财务状况和经营效率。</p><p><strong>核心公式：</strong><br />ROE = 净利润率 × 总资产周转率 × 权益乘数</p><p>这种分析方法有助于识别影响公司盈利能力的关键因素。</p><h3 id="aarrr模型海盗指标"><a class="markdownIt-Anchor" href="#aarrr模型海盗指标"></a> AARRR模型（海盗指标）</h3><p>AARRR模型是一个用户增长框架，包括五个关键阶段：</p><ol><li>获取（Acquisition）：如何吸引用户</li><li>激活（Activation）：如何让用户体验产品价值</li><li>留存（Retention）：如何让用户持续使用</li><li>收入（Revenue）：如何从用户获得收入</li><li>推荐（Referral）：如何通过现有用户获得新用户</li></ol><p>这个模型帮助企业全面分析和优化用户生命周期。</p><h3 id="pest分析"><a class="markdownIt-Anchor" href="#pest分析"></a> PEST分析</h3><p>PEST分析用于评估宏观环境对企业的影响，包括四个方面：</p><ul><li>政治（Political）：政府政策、法规等</li><li>经济（Economic）：经济增长、通货膨胀等</li><li>社会（Social）：人口趋势、文化变迁等</li><li>技术（Technological）：技术创新、研发投入等</li></ul><p>PEST分析有助于企业识别外部环境的机遇与威胁。</p><h3 id="rfm模型"><a class="markdownIt-Anchor" href="#rfm模型"></a> RFM模型</h3><p>RFM模型是一种客户价值分析方法，基于三个维度：</p><ul><li>最近一次购买（Recency）</li><li>购买频率（Frequency）</li><li>购买金额（Monetary）</li></ul><p>通过这三个维度，企业可以对客户进行分类，制定针对性的营销策略。</p><h3 id="swot分析"><a class="markdownIt-Anchor" href="#swot分析"></a> SWOT分析</h3><p>SWOT分析是一种全面评估企业内外部环境的方法：</p><ul><li>优势（Strengths）：企业的内部优势</li><li>劣势（Weaknesses）：企业的内部不足</li><li>机会（Opportunities）：外部环境带来的机会</li><li>威胁（Threats）：外部环境带来的挑战</li></ul><p>SWOT分析有助于企业制定战略，扬长避短。</p><h3 id="5w1h分析法"><a class="markdownIt-Anchor" href="#5w1h分析法"></a> 5W1H分析法</h3><p>5W1H是一种全面分析问题的方法，通过回答六个问题来深入理解问题：</p><ul><li>What（什么）：问题是什么</li><li>Why（为什么）：为什么会发生</li><li>Who（谁）：涉及哪些人</li><li>Where（哪里）：在哪里发生</li><li>When（何时）：什么时候发生</li><li>How（如何）：如何解决</li></ul><p>这种方法有助于全面、系统地分析和解决问题。</p><h2 id="重点分析方法"><a class="markdownIt-Anchor" href="#重点分析方法"></a> 重点分析方法</h2><h3 id="工作分解结构wbs"><a class="markdownIt-Anchor" href="#工作分解结构wbs"></a> 工作分解结构（WBS）</h3><p>工作分解结构（Work Breakdown Structure，WBS）是一种项目管理工具，用于将项目分解成更小、更易管理的部分。WBS不仅是一种流程拆解方法，更是一种系统化的项目规划和控制工具。</p><p><strong>WBS的特点：</strong></p><ul><li>层级结构：从项目总体目标逐级分解到具体工作包</li><li>100%原则：下级元素必须完整描述上级元素的所有工作</li><li>可交付成果导向：每个工作包都应有明确的可交付成果</li></ul><p><strong>应用步骤：</strong></p><ol><li>确定项目范围和主要可交付成果</li><li>确定主要工作包</li><li>分解工作包到适当的详细程度</li><li>分配工作包责任</li><li>定义每个工作包的时间、资源和成本估算</li></ol><p><strong>示例：移动应用开发项目的WBS</strong></p><ol><li>移动应用开发项目<br />1.1 <strong>项目启动</strong><br />1.1.1 需求分析<br />1.1.2 项目章程<br />1.2 <strong>设计阶段</strong><br />1.2.1 UI/UX设计<br />1.2.2 技术架构设计<br />1.3 <strong>开发阶段</strong><br />1.3.1 前端开发<br />1.3.2 后端开发<br />1.3.3 数据库开发<br />1.4 <strong>测试阶段</strong><br />1.4.1 单元测试<br />1.4.2 集成测试<br />1.4.3 用户验收测试<br />1.5 <strong>部署阶段</strong><br />1.5.1 应用商店提交<br />1.5.2 服务器部署<br />1.6 <strong>项目管理</strong><br />1.6.1 进度管理<br />1.6.2 风险管理<br />1.6.3 沟通管理</li></ol><h3 id="泳道流程图"><a class="markdownIt-Anchor" href="#泳道流程图"></a> 泳道流程图</h3><p>泳道流程图是一种特殊类型的流程图，它通过将流程步骤分配到不同的&quot;泳道&quot;中来可视化复杂的业务流程。每个泳道通常代表一个参与者、部门或系统。</p><p><strong>泳道流程图的特点：</strong></p><ul><li>清晰展示不同参与者的职责</li><li>易于识别流程中的瓶颈和交接点</li><li>有助于优化跨部门或跨系统的流程</li></ul><p><strong>应用步骤：</strong></p><ol><li>确定流程涉及的所有参与者或部门</li><li>为每个参与者创建一个泳道</li><li>按时间顺序列出流程步骤</li><li>将每个步骤分配到相应的泳道</li><li>用箭头连接步骤，显示流程方向</li><li>标注决策点和条件分支</li></ol><p><strong>示例：电子商务订单处理流程</strong></p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/553aa03ff8a1708b264d22cfe2f7de41" alt="泳道图示例" /><br />客户泳道：<br />开始 -&gt; 浏览商品 -&gt; 添加到购物车 -&gt; 结算 -&gt; 支付 -&gt; 结束</p><p>系统泳道：<br />验证库存 -&gt; 生成订单 -&gt; 处理支付 -&gt; 更新库存</p><p>仓储部门泳道：<br />接收订单 -&gt; 拣货 -&gt; 包装</p><p>物流部门泳道：<br />收件 -&gt; 配送 -&gt; 送达</p><p>客服部门泳道：<br />处理查询 -&gt; 处理退换货请求</p><blockquote><p>对于流程图我们可以用PlantUML代码或者Mermaid来实现。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在当今数据驱动的商业环境中，业务分析已成为企业决策和战略制定的核心。本文将介绍九种常用的业务分析方法，这些方法能帮助分析师和管理者更好地理解复杂的业务问题，并制定有效的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;mece原则业务拆解的基础&quot;&gt;&lt;a class=&quot;markdownIt</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之MySQL食用指南</title>
    <link href="https://sherry14love.github.io/2024/07/25/learn/mysql/"/>
    <id>https://sherry14love.github.io/2024/07/25/learn/mysql/</id>
    <published>2024-07-24T16:00:00.000Z</published>
    <updated>2024-09-26T07:25:49.946Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL作为一种广泛使用的关系型数据库管理系统，是每个数据分析师必备技能，下面让我们来探讨如何利用MySQL进行高效的数据分析。</p><h2 id="基础语句"><a class="markdownIt-Anchor" href="#基础语句"></a> 基础语句</h2><p>为了帮助小伙伴们清晰理解SQL查询的语法结构和运行顺序，我们应该知道下面的：</p><ul><li>语法结构：select–from–where–group by–having–order by–limit</li><li>运行顺序：from–where–group by–having–order by–limit–select</li></ul><h3 id="select-from"><a class="markdownIt-Anchor" href="#select-from"></a> SELECT &amp; FROM</h3><h4 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h4><p>在MySQL中，使用 <code>SELECT</code> 语句来指定要查询的字段。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...</span><br></pre></td></tr></table></figure><p>使用 <code>FROM</code> 语句来指定数据来源的表。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>假设有一个名为 <code>students</code> 的表，包含以下字段：<code>id</code>, <code>name</code>, <code>age</code>, <code>gender</code>。</p><ol><li>查询所有字段</li></ol><p>要查询 <code>students</code> 表中的所有字段，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, age, gender</span><br><span class="line"><span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure><p>或者简化为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure><ol start="2"><li>查询特定字段</li></ol><p>如果只需要查询 <code>name</code> 和 <code>age</code> 字段，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age</span><br><span class="line"><span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure><p>通过这些基础的 <code>SELECT</code> 和 <code>FROM</code> 语句，我们就可以从数据库表中检索所需的数据。</p><blockquote><p>除此之外，如果我们需要连续执行两三个简单的查询语句，只需要中间用<code>;</code>分开，执行的时候就不会报错了。</p></blockquote><h4 id="字段名的别名"><a class="markdownIt-Anchor" href="#字段名的别名"></a> 字段名的——别名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">AS</span> 姓名, age <span class="keyword">AS</span> 年龄</span><br><span class="line"><span class="keyword">FROM</span> students</span><br></pre></td></tr></table></figure><blockquote><p><code>AS</code>可以省略，但是<code>字段名</code>后面需要加一个空格才可以加上<code>别名</code></p></blockquote><p>使用<code>AS</code>我们就可以改变我们的字段名，很简单，并且支持中文。</p><h4 id="去重"><a class="markdownIt-Anchor" href="#去重"></a> 去重</h4><p>在MySQL中，去重操作通常指的是从表中删除重复的记录或查询时排除重复的记录。</p><p>以下是两种常见的去重操作：</p><ol><li><p><strong>查询时去重</strong>：</p><ul><li>使用<code>SELECT DISTINCT</code>语句来查询不重复的记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>这条语句将返回指定列中不重复的所有记录。</p></li><li><p><strong>删除重复记录</strong>：</p><ul><li>删除表中的重复记录稍微复杂一些，需要使用临时表或子查询来实现。以下是一个常见的步骤：<ul><li>创建一个临时表，将不重复的记录插入到临时表中。</li><li>删除原表中的所有记录。</li><li>将临时表中的记录插入回原表。</li><li>删除临时表。</li></ul></li></ul><p>示例代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_table <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> original_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除原表中的所有记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> original_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将临时表中的记录插入回原表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> original_table <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> temp_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除临时表</span></span><br><span class="line"><span class="keyword">DROP</span> TEMPORARY <span class="keyword">TABLE</span> temp_table;</span><br></pre></td></tr></table></figure><p>另一种方法是使用子查询和<code>DELETE</code>语句来删除重复记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> t1 <span class="keyword">FROM</span> original_table t1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> original_table t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">&gt;</span> t2.id <span class="keyword">AND</span> t1.column <span class="operator">=</span> t2.column;</span><br></pre></td></tr></table></figure><p>这条语句将删除<code>original_table</code>中所有重复的记录，保留每个重复组中的一个记录。</p></li></ol><p>哦对，去重操作可能会影响数据的完整性和表之间的关系，因此在执行这些操作之前，请确保备份数据并了解其潜在影响。</p><h4 id="select之中简单的计算"><a class="markdownIt-Anchor" href="#select之中简单的计算"></a> SELECT之中简单的计算</h4><p>在MySQL的<code>SELECT</code>语句中，我们可以进行各种简单的计算操作，比如加法、减法、乘法、除法等。这些计算可以直接在<code>SELECT</code>子句中进行，从而在查询结果中显示计算后的值：</p><table><thead><tr><th>操作类型</th><th>SQL 示例代码</th><th>描述</th></tr></thead><tbody><tr><td><strong>加  法</strong></td><td><code>SELECT column1, column2, column1 + column2 AS sum_column FROM table_name;</code></td><td>返回<code>column1</code>和<code>column2</code>的值，并在结果中显示它们的和，命名为<code>sum_column</code>。</td></tr><tr><td><strong>减  法</strong></td><td><code>SELECT column1, column2, column1 - column2 AS difference_column FROM table_name;</code></td><td>返回<code>column1</code>和<code>column2</code>的值，并在结果中显示它们的差，命名为<code>difference_column</code>。</td></tr><tr><td><strong>乘  法</strong></td><td><code>SELECT column1, column2, column1 * column2 AS product_column FROM table_name;</code></td><td>返回<code>column1</code>和<code>column2</code>的值，并在结果中显示它们的乘积，命名为<code>product_column</code>。</td></tr><tr><td><strong>除  法</strong></td><td><code>SELECT column1, column2, column1 / column2 AS quotient_column FROM table_name;</code></td><td>返回<code>column1</code>和<code>column2</code>的值，并在结果中显示它们的商，命名为<code>quotient_column</code>。注意：如果<code>column2</code>的值为0，将会导致除以零的错误。</td></tr><tr><td><strong>混合计算</strong></td><td><code>SELECT column1, column2, (column1 + column2) * 2 AS calculated_column FROM table_name;</code></td><td>返回<code>column1</code>和<code>column2</code>的值，并在结果中显示它们的和乘以2的结果，命名为<code>calculated_column</code>。</td></tr></tbody></table><h3 id="where"><a class="markdownIt-Anchor" href="#where"></a> WHERE</h3><p>在MySQL中，<code>WHERE</code>子句用于在<code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>语句中指定条件，从而对数据进行筛选。<code>WHERE</code>子句允许我们根据一个或多个条件过滤数据，只返回满足这些条件的记录。以下是对<code>WHERE</code>子句的详细补充：</p><h4 id="基本语法-2"><a class="markdownIt-Anchor" href="#基本语法-2"></a> <strong>基本语法</strong>：</h4>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>condition</code>是一个逻辑表达式，用于评估每一行数据是否满足条件。</p><h4 id="常见的条件运算符"><a class="markdownIt-Anchor" href="#常见的条件运算符"></a> <strong>常见的条件运算符</strong>：</h4><p>假设我们有一个名为<code>employees</code>的表，其中存储了员工的年龄（<code>age</code>）、部门（<code>department</code>）、工资（<code>salary</code>）和电子邮件（<code>email</code>）等信息。</p><p>我们可以使用各种条件运算符来查询和筛选这个表中的数据：</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td><td><code>SELECT * FROM employees WHERE age = 30;</code></td><td>查询年龄等于30岁的所有员工。</td></tr><tr><td><code>&lt;&gt;</code> 或 <code>!=</code></td><td>不等于</td><td><code>SELECT * FROM employees WHERE department &lt;&gt; 'Sales';</code></td><td>查询部门不是&quot;Sales&quot;的所有员工。</td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>SELECT * FROM employees WHERE salary &gt; 5000;</code></td><td>查询工资大于5000的所有员工。</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>SELECT * FROM employees WHERE age &lt; 40;</code></td><td>查询年龄小于40岁的所有员工。</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>SELECT * FROM employees WHERE salary &gt;= 5000;</code></td><td>查询工资大于或等于5000的所有员工。</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>SELECT * FROM employees WHERE age &lt;= 40;</code></td><td>查询年龄小于或等于40岁的所有员工。</td></tr><tr><td><code>BETWEEN ... AND ...</code></td><td>在某个范围内</td><td><code>SELECT * FROM employees WHERE salary BETWEEN 5000 AND 10000;</code></td><td>查询工资在5000到10000之间的所有员工（包括5000和10000）。</td></tr><tr><td><code>IN (...)</code></td><td>在某个集合中</td><td><code>SELECT * FROM employees WHERE department IN ('Sales', 'Marketing');</code></td><td>查询部门是&quot;Sales&quot;或&quot;Marketing&quot;的所有员工。</td></tr><tr><td><code>LIKE</code></td><td>匹配某个模式</td><td><code>SELECT * FROM employees WHERE name LIKE 'A%';</code></td><td>查询名字以&quot;A&quot;开头的所有员工（<code>%</code>表示任意字符序列）。</td></tr><tr><td><code>LIKE</code></td><td>匹配某个模式</td><td><code>SELECT * FROM employees WHERE name LIKE '_A%';</code></td><td>查询名字以&quot;A&quot;第二个字母的所有员工（第一个字符可以是任意字符（用<code>_</code>表示））</td></tr><tr><td><code>IS NULL</code></td><td>为空</td><td><code>SELECT * FROM employees WHERE email IS NULL;</code></td><td>查询没有电子邮件地址的所有员工。</td></tr><tr><td><code>IS NOT NULL</code></td><td>不为空</td><td><code>SELECT * FROM employees WHERE email IS NOT NULL;</code></td><td>查询有电子邮件地址的所有员工。</td></tr><tr><td><code>AND</code></td><td>逻辑与</td><td><code>SELECT * FROM employees WHERE age &gt; 30 AND department = 'Sales';</code></td><td>查询年龄大于30岁且部门是&quot;Sales&quot;的所有员工。</td></tr><tr><td><code>OR</code></td><td>逻辑或</td><td><code>SELECT * FROM employees WHERE age &gt; 30 OR salary &gt; 10000;</code></td><td>查询年龄大于30岁或工资大于10000的所有员工。</td></tr><tr><td><code>NOT</code></td><td>逻辑非</td><td><code>SELECT * FROM employees WHERE NOT department = 'Sales';</code></td><td>查询部门不是&quot;Sales&quot;的所有员工。</td></tr></tbody></table><h4 id="组合条件"><a class="markdownIt-Anchor" href="#组合条件"></a> <strong>组合条件</strong>：</h4><ul><li>使用<code>AND</code>和<code>OR</code>组合多个条件：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>使用括号来明确优先级：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> (age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>) <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="简化"><a class="markdownIt-Anchor" href="#简化"></a> 简化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> world </span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%e%&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%i%&#x27;</span></span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%o%&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%u%&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;% %&#x27;</span></span><br></pre></td></tr></table></figure><p>对于上面的SQL语句，我们可以进行简化。</p><p>通过正则表达式（Regular Expression）来简化这个查询。MySQL支持使用<code>REGEXP</code>或<code>RLIKE</code>运算符来进行正则表达式匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> world</span><br><span class="line"><span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;[aeiou]&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;% %&#x27;</span>;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>name REGEXP '[aeiou]'</code>：这个条件检查名字中是否包含至少一个元音字母（a, e, i, o, u）。</li><li><code>name NOT LIKE '% %'</code>：这个条件确保名字中不包含空格。</li></ul><p><code>WHERE</code>子句是SQL查询中非常强大和灵活的工具，它允许我们精确地控制返回的数据集，从而满足各种数据分析和操作的需求。</p><h3 id="order-by"><a class="markdownIt-Anchor" href="#order-by"></a> ORDER BY</h3><p><code>ORDER BY</code> 是 SQL 中用于对查询结果进行排序的关键字。通过 <code>ORDER BY</code>，我们可以根据一个或多个列的值对结果集进行升序（ASC）或降序（DESC）排序。以下是 <code>ORDER BY</code> 的基本用法和一些示例：</p><h4 id="基本语法-3"><a class="markdownIt-Anchor" href="#基本语法-3"></a> 基本语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...;</span><br></pre></td></tr></table></figure><ul><li><code>column1</code>, <code>column2</code>, …：指定用于排序的列。</li><li><code>ASC</code>：表示升序排序（默认）。</li><li><code>DESC</code>：表示降序排序。</li></ul><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><ol><li><p><strong>单列升序排序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure><p>这个查询将返回所有员工的名字和年龄，并按年龄升序排序。</p></li><li><p><strong>单列降序排序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>这个查询将返回所有员工的名字和年龄，并按年龄降序排序。</p></li><li><p><strong>多列排序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, department, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department, salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>这个查询将首先按部门升序排序，然后在每个部门内按工资降序排序。</p></li><li><p><strong>使用列别名排序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">AS</span> employee_age</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_age;</span><br></pre></td></tr></table></figure><p>这个查询将返回所有员工的名字和年龄（使用别名 <code>employee_age</code>），并按年龄升序排序。</p></li><li><p><strong>使用列位置排序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个查询将返回所有员工的名字和年龄，并按第二列（即 <code>age</code>）升序排序。</p></li><li><p><strong>使用IN</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address <span class="keyword">IN</span> (<span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>), name, age;</span><br></pre></td></tr></table></figure></li></ol><p>这个查询首先是根据<code>address</code>列是否为’上海’或’北京’进行排序。</p><p>这里的<code>address IN ('上海', '北京')</code>会返回一个布尔值（TRUE或FALSE），TRUE会被视为1，FALSE会被视为0。</p><p>因为默认是升序排序，所以地址为’上海’或’北京’的记录会被排在后面。</p><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><ul><li><code>ORDER BY</code> 通常放在 <code>SELECT</code> 语句的最后。</li><li>如果不指定排序顺序（即不使用 <code>ASC</code> 或 <code>DESC</code>），默认是升序排序。</li><li>多列排序时，先按第一个列排序，然后在第一个列的每个值内按第二个列排序，依此类推。</li></ul><h3 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> LIMIT</h3><p><code>LIMIT</code>是SQL中用于限制查询结果返回行数的子句。它通常用于以下几种情况：</p><ol><li><strong>限制返回的行数</strong>：当你只需要查询结果的前几行时，可以使用<code>LIMIT</code>。</li><li><strong>分页查询</strong>：在实现分页功能时，<code>LIMIT</code>和<code>OFFSET</code>结合使用可以指定从哪一行开始返回多少行数据。</li></ol><h4 id="基本语法-4"><a class="markdownIt-Anchor" href="#基本语法-4"></a> 基本语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><p>假设我们有一个<code>employees</code>表，我们只想获取前5名员工的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="结合offset使用"><a class="markdownIt-Anchor" href="#结合offset使用"></a> 结合<code>OFFSET</code>使用</h4><p><code>OFFSET</code>用于指定从哪一行开始返回数据。通常用于分页查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number <span class="keyword">OFFSET</span> <span class="keyword">offset</span>;</span><br></pre></td></tr></table></figure><p>或者更常见的写法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT <span class="keyword">offset</span>, number;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><p>假设我们有一个<code>employees</code>表，我们想获取第7到第10名员工的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">4</span> <span class="keyword">OFFSET</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">6</span>, <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>从6+1开始，然后获取4个数据的意思（即获取第7到第10名员工的信息）</p><h4 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h4><ol><li><strong>性能考虑</strong>：使用<code>LIMIT</code>可以提高查询性能，尤其是在处理大数据集时。</li><li><strong>排序</strong>：在使用<code>LIMIT</code>时，通常需要结合<code>ORDER BY</code>子句来确保结果的顺序是确定的。</li></ol><p><strong>示例:</strong></p><p>假设我们想获取年龄最大的前5名员工的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, address</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="聚合函数-group-by"><a class="markdownIt-Anchor" href="#聚合函数-group-by"></a> 聚合函数 &amp; group by</h3><p>聚合函数在SQL中用于对一组值进行计算，并返回单个值。它们通常与<code>GROUP BY</code>子句一起使用，以便对数据进行分组并计算每个组的聚合值。下面是一些常用的聚合函数及其使用示例：</p><h4 id="常用的聚合函数"><a class="markdownIt-Anchor" href="#常用的聚合函数"></a> 常用的聚合函数</h4><ol><li><strong>COUNT</strong>：计算行数。</li><li><strong>SUM</strong>：计算总和。</li><li><strong>AVG</strong>：计算平均值。</li><li><strong>MAX</strong>：找出最大值。</li><li><strong>MIN</strong>：找出最小值。</li></ol><p><strong>示例：</strong></p><p>假设我们有一个名为<code>sales</code>的表，包含以下列：<code>product_id</code>、<code>sale_date</code>、<code>quantity</code>和<code>revenue</code>。</p><ol><li>COUNT</li></ol><p>计算总行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total_rows</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>计算特定产品的销售记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sales_count</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><ol start="2"><li>SUM</li></ol><p>计算总销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(revenue) <span class="keyword">AS</span> total_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>计算每个产品的总销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(revenue) <span class="keyword">AS</span> total_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><ol start="3"><li>AVG</li></ol><p>计算平均销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(revenue) <span class="keyword">AS</span> average_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>计算每个产品的平均销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">AVG</span>(revenue) <span class="keyword">AS</span> average_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><ol start="4"><li>MAX</li></ol><p>找出最大销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(revenue) <span class="keyword">AS</span> max_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>找出每个产品的最大销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">MAX</span>(revenue) <span class="keyword">AS</span> max_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><ol start="5"><li>MIN</li></ol><p>找出最小销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(revenue) <span class="keyword">AS</span> min_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p>找出每个产品的最小销售额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">MIN</span>(revenue) <span class="keyword">AS</span> min_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><h4 id="结合group-by和having"><a class="markdownIt-Anchor" href="#结合group-by和having"></a> 结合<code>GROUP BY</code>和<code>HAVING</code></h4><p><code>HAVING</code>子句用于对分组后的结果进行筛选。例如，找出销售额总和超过1000的产品：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(revenue) <span class="keyword">AS</span> total_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(revenue) <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h4 id="聚合函数注意事项"><a class="markdownIt-Anchor" href="#聚合函数注意事项"></a> 聚合函数注意事项</h4><ol><li><strong>NULL值</strong>：聚合函数通常会忽略<code>NULL</code>值。例如，<code>COUNT(*)</code>会计算所有行，而<code>COUNT(column_name)</code>会忽略该列中的<code>NULL</code>值。</li><li><strong>数据类型</strong>：确保聚合函数应用于正确的数据类型。例如，<code>SUM</code>和<code>AVG</code>通常用于数值类型。</li></ol><h4 id="group-by基本语法"><a class="markdownIt-Anchor" href="#group-by基本语法"></a> <code>GROUP BY</code>基本语法</h4><p><code>GROUP BY</code>子句在SQL中用于将行分组，通常与聚合函数（如<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code>等）一起使用，以便对每个组进行计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, aggregate_function(column3)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>假设我们有一个名为<code>orders</code>的表，包含以下列：<code>customer_id</code>、<code>order_date</code>、<code>product_id</code>和<code>quantity</code>。</p><ol><li>按单个列分组</li></ol><p>计算每个客户的订单总数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure><ol start="2"><li>按多个列分组</li></ol><p>计算每个客户和每个产品的订单总数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, product_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id, product_id;</span><br></pre></td></tr></table></figure><ol start="3"><li>结合聚合函数</li></ol><p>计算每个客户的订单总数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure><ol start="4"><li>结合<code>HAVING</code>子句</li></ol><p>筛选出订单总数超过10的客户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="group-by注意事项"><a class="markdownIt-Anchor" href="#group-by注意事项"></a> <code>GROUP BY</code>注意事项</h4><ol><li><strong>选择列</strong>：在<code>SELECT</code>子句中，除了聚合函数外，所有列都必须出现在<code>GROUP BY</code>子句中。</li><li><strong>NULL值</strong>：<code>GROUP BY</code>会将所有<code>NULL</code>值视为相同的组。</li><li><strong>性能考虑</strong>：<code>GROUP BY</code>操作可能会消耗较多资源，尤其是在处理大数据集时。可以考虑使用索引优化性能。</li></ol><p><strong>示例：结合多个聚合函数</strong></p><p>计算每个客户的订单总数、总数量和平均数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, </span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_count, </span><br><span class="line">       <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity, </span><br><span class="line">       <span class="built_in">AVG</span>(quantity) <span class="keyword">AS</span> average_quantity</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure><h3 id="having"><a class="markdownIt-Anchor" href="#having"></a> HAVING</h3><p>在SQL中，<code>HAVING</code>子句用于对聚合函数的结果进行筛选。它通常与<code>GROUP BY</code>子句一起使用，以便在分组后对组进行条件过滤：</p><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列<span class="number">1</span>, 列<span class="number">2</span>, 聚合函数(列<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列<span class="number">1</span>, 列<span class="number">2</span></span><br><span class="line"><span class="keyword">HAVING</span> 聚合函数(列<span class="number">3</span>) 条件;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong><br />假设我们有一个名为<code>sales</code>的表，其中包含以下列：<code>id</code>, <code>product</code>, <code>quantity</code>, <code>price</code>。我们想要找出每个产品的总销售额，并且只显示总销售额大于1000的产品。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product, <span class="built_in">SUM</span>(quantity <span class="operator">*</span> price) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity <span class="operator">*</span> price) <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ol><li><code>SELECT product, SUM(quantity * price) AS total_sales</code>：选择产品名称和总销售额。</li><li><code>FROM sales</code>：从<code>sales</code>表中获取数据。</li><li><code>GROUP BY product</code>：按产品名称分组。</li><li><code>HAVING SUM(quantity * price) &gt; 1000</code>：筛选出总销售额大于1000的产品。</li></ol><h4 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h4><ul><li><code>HAVING</code>子句只能用于包含聚合函数的查询。</li><li><code>HAVING</code>子句在<code>GROUP BY</code>之后执行，因此它用于对分组后的结果进行筛选。</li><li>如果不需要对分组后的结果进行筛选，可以直接使用<code>WHERE</code>子句对原始数据进行筛选。</li></ul><blockquote><p><code>where</code>是对原始数据进行筛选(数据不改变)，而<code>having</code>是针对聚合函数的筛选(数据改变)</p></blockquote><h3 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h3><h4 id="数学函数"><a class="markdownIt-Anchor" href="#数学函数"></a> 数学函数</h4><ol><li>round(x,y)——四舍五入函数：</li></ol><ul><li>round函数对x值进行四舍五入，精确到小数点后y位</li><li>y为负值时，保留小数点左边相应的位数为0，不进行四舍五入</li></ul><p>下面是示例：</p><table><thead><tr><th>表达式</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td><code>ROUND(3.15, 1)</code></td><td>3.2</td><td>对小数部分的第一位进行四舍五入，结果是3.2</td></tr><tr><td><code>ROUND(14.15, -1)</code></td><td>10</td><td>对整数部分的十位进行四舍五入，结果是10</td></tr><tr><td><code>ROUND(152.15, 0)</code></td><td>152</td><td>对小数部分的第一位进行四舍五入，结果是152</td></tr><tr><td><code>ROUND(155.15, -1)</code></td><td>160</td><td>对整数部分的十位进行四舍五入，结果是160</td></tr><tr><td><code>ROUND(152.15, -2)</code></td><td>200</td><td>对整数部分的百位进行四舍五入，结果是200</td></tr><tr><td><code>ROUND(152.15, -3)</code></td><td>0</td><td>对整数部分的千位进行四舍五入，结果是0</td></tr></tbody></table><h4 id="字符串函数"><a class="markdownIt-Anchor" href="#字符串函数"></a> 字符串函数</h4><ol><li>concat(s1,s2,…)——连接字符串函数：</li></ol><ul><li>concat函数返回连接的参数s1,s2等产生的字符串</li><li>任以参数为null时，返回null<ul><li>示例1：<code>concat('My',' ','SQL')</code></li><li>结果：<code>My SQL</code>(中间有空格哦)</li><li>示例2：<code>concat('My',null,'SQL')</code></li><li>结果：<code>null</code>(只要有一个为null结果就返回null)</li></ul></li></ul><ol start="2"><li>replace(s,s1,s2)——替换函数：</li></ol><ul><li>replace函数使用字符串s2替代s中<strong>所有</strong>的s1<ul><li>示例：<code>replace('MySQLMySQL','SQL','sql')</code></li><li>结果：<code>MysqlMysql</code></li></ul></li></ul><ol start="3"><li>left(s,n)、right(s,n)&amp;substring(s,n,len)——截取字符串一部分的函数：</li></ol><ul><li>left函数返回字符串s最左边n个字符<ul><li>示例：<code>left(&quot;Hello, World!&quot;, 5)</code></li><li>结果：<code>&quot;Hello&quot;</code></li></ul></li><li>right函数返回字符串s最右边n个字符<ul><li>示例：<code>right(&quot;Hello, World!&quot;, 6)</code></li><li>结果：<code>&quot;World!&quot;</code></li></ul></li><li>substring函数返回字符串s从第n个字符起取长度为len的子字符串，n可以做为<strong>负值</strong>，则从<strong>倒数</strong>第n个字符起取长度为len的子字符串，没有len值则从第n个字符取到最后一位。<ul><li>示例1：<code>substring(&quot;Hello, World!&quot;, 7, 5)</code></li><li>结果：<code>&quot;World&quot;</code></li><li>示例2：<code>substring(&quot;Hello, World!&quot;, -6, 5)</code></li><li>结果：<code>&quot;World&quot;</code></li><li>示例3：<code>substring(&quot;Hello, World!&quot;, 7)</code></li><li>结果：<code>&quot;World!&quot;</code></li></ul></li></ul><ol start="4"><li>length()——统计字符串长度的函数：</li></ol><ul><li>用于返回字符串的长度（即字符串中字符的数量）<ul><li>示例：<code>select ... where length(content) &gt; 15</code></li><li>结果：返回content列字符串数量大于15的列</li></ul></li><li><strong>MySQL</strong>和<strong>SQLite</strong>使用<code>length</code>函数。<br /><strong>PostgreSQL</strong>使用<code>length</code>函数。<br /><strong>SQL Server</strong>使用<code>len</code>函数。<br /><strong>Oracle</strong>使用<code>length</code>函数。</li></ul><h4 id="数据类型转换函数"><a class="markdownIt-Anchor" href="#数据类型转换函数"></a> 数据类型转换函数</h4><ol><li>cast(x as type)——转换数据类型的函数</li></ol><ul><li>cast函数将一个类型的x值转换为另一类型的值</li><li>type参数可以填写char(n)、date、time、datetime、decimal等转换为对应的数值类型</li></ul><ol><li><strong>将整数转换为字符串</strong><br />- 示例：<code>cast(123 as char(5))</code><br />- 结果：<code>&quot;  123&quot;</code>（注意：这里假设<code>char(5)</code>会在左侧填充空格以达到5个字符的长度）</li><li><strong>将字符串转换为日期</strong><br />- 示例：<code>cast(&quot;2023-04-05&quot; as date)</code><br />- 结果：<code>2023-04-05</code>（日期类型）</li><li><strong>将字符串转换为时间</strong><br />- 示例：<code>cast(&quot;14:23:55&quot; as time)</code><br />- 结果：<code>14:23:55</code>（时间类型）</li><li><strong>将字符串转换为日期时间</strong><br />- 示例：<code>cast(&quot;2023-04-05 14:23:55&quot; as datetime)</code><br />- 结果：<code>2023-04-05 14:23:55</code>（日期时间类型）</li><li><strong>将浮点数转换为十进制数</strong><br />- 示例：<code>cast(123.456 as decimal(10, 2))</code><br />- 结果：<code>123.46</code>（十进制数类型，保留两位小数）</li></ol><h4 id="日期时间函数"><a class="markdownIt-Anchor" href="#日期时间函数"></a> 日期时间函数</h4><ol><li><strong>获取年月日函数</strong><ul><li><code>year(date)</code><ul><li>示例：<code>year('2023-04-05')</code></li><li>结果：<code>2023</code></li></ul></li><li><code>month(date)</code><ul><li>示例：<code>month('2023-04-05')</code></li><li>结果：<code>4</code></li></ul></li><li><code>day(date)</code><ul><li>示例：<code>day('2023-04-05')</code></li><li>结果：<code>5</code></li></ul></li></ul></li><li><strong>对指定起始时间进行加减操作</strong><ul><li><code>date_add(date, interval expr type)</code><ul><li>示例：<code>date_add('2023-04-05', interval 10 day)</code></li><li>结果：<code>2023-04-15</code></li></ul></li><li><code>date_sub(date, interval expr type)</code><ul><li>示例：<code>date_sub('2023-04-05', interval 5 day)</code></li><li>结果：<code>2023-03-31</code></li></ul></li></ul></li><li><strong>计算两个日期之间间隔的天数</strong><ul><li><code>datediff(date1, date2)</code><ul><li>示例：<code>datediff('2023-04-10', '2023-04-05')</code></li><li>结果：<code>5</code></li></ul></li></ul></li><li><strong>将日期和时间格式化</strong><ul><li><code>date_format(date, format)</code><ul><li>示例：<code>date_format('2023-04-05 14:23:55', '%Y-%m-%d %H:%i:%s')</code></li><li>结果：<code>2023-04-05 14:23:55</code></li><li>示例：<code>date_format('2023-04-05 14:23:55', '%d/%m/%Y')</code></li><li>结果：<code>05/04/2023</code></li></ul></li></ul></li><li>格式化符号说明：</li></ol><table><thead><tr><th>格式化符号</th><th>说明</th><th>格式化符号</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4位数的年份（例如：2023）</td><td>%y</td><td>2位数的年份（例如：23）</td></tr><tr><td>%m</td><td>2位数的月份（01到12）</td><td>%c</td><td>月份的数字表示（1到12）</td></tr><tr><td>%d</td><td>2位数的日期（01到31）</td><td>%e</td><td>日期的数字表示（1到31）</td></tr><tr><td>%H</td><td>2位数的小时（00到23）</td><td>%k</td><td>小时（0到23）</td></tr><tr><td>%h</td><td>2位数的小时（01到12）</td><td>%I</td><td>2位数的小时（01到12）</td></tr><tr><td>%l</td><td>小时（1到12）</td><td></td><td></td></tr><tr><td>%i</td><td>2位数的分钟（00到59）</td><td></td><td></td></tr><tr><td>%S</td><td>2位数的秒（00到59）</td><td>%s</td><td>秒（从1970-01-01 00:00:00 UTC开始的秒数）</td></tr><tr><td>%f</td><td>微秒（000000到999999）</td><td></td><td></td></tr><tr><td>%p</td><td>AM或PM</td><td></td><td></td></tr><tr><td>%r</td><td>时间，12小时制（hh:mm:ss AM/PM）</td><td>%T</td><td>时间，24小时制（hh:mm:ss）</td></tr><tr><td>%W</td><td>星期几的全名（例如：Sunday）</td><td>%a</td><td>星期的缩写名（例如：Sun）</td></tr><tr><td>%w</td><td>星期几的数字表示（0=Sunday, 6=Saturday）</td><td></td><td></td></tr><tr><td>%j</td><td>一年中的第几天（001到366）</td><td></td><td></td></tr><tr><td>%U</td><td>一年中的第几周（00到53），星期天是一周的第一天</td><td>%u</td><td>一年中的第几周（00到53），星期一是一周的第一天</td></tr><tr><td>%V</td><td>一年中的第几周（01到53），星期天是一周的第一天，用于ISO 8601</td><td>%v</td><td>一年中的第几周（01到53），星期一是一周的第一天，用于ISO 8601</td></tr></tbody></table><h4 id="条件判断函数"><a class="markdownIt-Anchor" href="#条件判断函数"></a> 条件判断函数</h4><ol><li>if(expr,v1,v2)</li></ol><ul><li>如果表达式expr是true返回v1，否则返回v2<ul><li>示例：<code>if(5 &gt; 3, 'Yes', 'No')</code></li><li>结果：<code>'Yes'</code></li><li>示例：<code>if(length('hello') &gt; 10, 'Long', 'Short')</code></li><li>结果：<code>'Short'</code></li></ul></li></ul><ol start="2"><li>case when</li></ol><ul><li>case expr when v1 then r1 [when v2 then r2]…[else rn] end<ul><li>例如：<code>case 2 when 1 then 'one' when 2 then 'two' else 'more' end</code></li><li>结果：<code>two</code></li></ul></li><li>case when v1 then r1 [when v2 then r2]…[else rn] end<ul><li>例如：<code>case when 1&lt;0 then 'T' else 'F' end </code></li><li>结果：<code>F</code></li></ul></li></ul><ol start="3"><li>详细说明<code>case when</code><br /><code>case when</code> 语句用于多条件判断，可以根据不同的条件返回不同的结果。它有两种常见的形式,第一种形式是基于表达式的判断，第二种形式是基于条件的判断。</li></ol><h5 id="形式一基于表达式的-case-when"><a class="markdownIt-Anchor" href="#形式一基于表达式的-case-when"></a> 形式一：基于表达式的 <code>case when</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> expr </span><br><span class="line">  <span class="keyword">WHEN</span> v1 <span class="keyword">THEN</span> r1 </span><br><span class="line">  [<span class="keyword">WHEN</span> v2 <span class="keyword">THEN</span> r2]</span><br><span class="line">  ...</span><br><span class="line">  [<span class="keyword">ELSE</span> rn] </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">CASE</span> <span class="number">2</span> </span><br><span class="line">    <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;one&#x27;</span> </span><br><span class="line">    <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;two&#x27;</span> </span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;more&#x27;</span> </span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">result</span>;</span><br></pre></td></tr></table></figure></li><li><strong>结果</strong>：<code>two</code></li></ul><h5 id="形式二基于条件的-case-when"><a class="markdownIt-Anchor" href="#形式二基于条件的-case-when"></a> 形式二：基于条件的 <code>case when</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">  <span class="keyword">WHEN</span> v1 <span class="keyword">THEN</span> r1 </span><br><span class="line">  [<span class="keyword">WHEN</span> v2 <span class="keyword">THEN</span> r2]</span><br><span class="line">  ...</span><br><span class="line">  [<span class="keyword">ELSE</span> rn] </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;T&#x27;</span> </span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;F&#x27;</span> </span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">result</span>;</span><br></pre></td></tr></table></figure></li><li><strong>结果</strong>：<code>F</code><br /><code>case when</code>语句在处理复杂逻辑和多分支场景时非常有用：</li></ul><h2 id="高级语句"><a class="markdownIt-Anchor" href="#高级语句"></a> 高级语句</h2><p>SQL高级语句可以用于数据处理、分析和转换等，是数据岗工作所必备的技能。</p><h3 id="窗口函数"><a class="markdownIt-Anchor" href="#窗口函数"></a> 窗口函数</h3><p>窗口函数是SQL中用于对数据进行分组、排序和计算的高级功能。它们可以在不改变数据行数的情况下，对数据进行复杂的分析和处理。</p><h4 id="标准语法"><a class="markdownIt-Anchor" href="#标准语法"></a> 标准语法</h4><p>窗口函数的标准语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">OVER</span> (</span><br><span class="line">    [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>分区列<span class="operator">&gt;</span>]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span>]</span><br><span class="line">    [<span class="operator">&lt;</span>窗口框架<span class="operator">&gt;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>窗口函数</code>：可以是聚合函数（如 <code>SUM</code>、<code>AVG</code>）或者是其他的窗口函数（如 <code>ROW_NUMBER</code>）。</li><li><code>PARTITION BY</code>：可选，指定分区列。</li><li><code>ORDER BY</code>：可选，指定排序列。</li><li><code>窗口框架</code>：可选，定义窗口的范围，如 <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>。</li></ul><h4 id="滑动窗口rowsrange用法"><a class="markdownIt-Anchor" href="#滑动窗口rowsrange用法"></a> 滑动窗口：rows&amp;range用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">ROWS</span> <span class="keyword">or</span> <span class="keyword">RANGE</span> clause<span class="operator">&gt;</span> <span class="keyword">BETWEEN</span> <span class="operator">&lt;</span><span class="keyword">Start</span> expr<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span><span class="keyword">End</span> expr<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>ROWS: 表示按照行的范围进行定义框架，根据order by子句排序后，取的前N行及后N行的数据计算（与当前行的值无关，只与排序后的行号相关）。</p><p>常用：rows n perceding表示从当前行到前n行（一共n+1行）</p><p>RANGE：表示按照值的范围进行定义框架，根据order by子句排序后，指定当前行对应值的范围取值，行数不固定，只要行值在范围内，对应行都包含在内。适用于对日期、时间、数值排序分组</p><table><thead><tr><th>边界可取值 (Start expr &amp; End expr)</th><th>说明</th></tr></thead><tbody><tr><td><code>CURRENT ROW</code></td><td>当前行</td></tr><tr><td><code>N PRECEDING</code></td><td>前 n 行，n 为数字，比如 <code>2 PRECEDING</code> 表示前2行</td></tr><tr><td><code>UNBOUNDED PRECEDING</code></td><td>开头</td></tr><tr><td><code>N FOLLOWING</code></td><td>后 N 行，n 为数字，比如 <code>2 FOLLOWING</code> 表示后2行</td></tr><tr><td><code>UNBOUNDED FOLLOWING</code></td><td>结尾</td></tr></tbody></table><table><thead><tr><th><code>RANGE</code> 取特定日期区间</th><th>说明</th></tr></thead><tbody><tr><td><code>RANGE INTERVAL '7-1' DAY PRECEDING</code></td><td>最近7天的值</td></tr><tr><td><code>RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND INTERVAL '1' DAY FOLLOWING</code></td><td>前后一天和当天的值</td></tr></tbody></table><p><strong>示例1：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    salary,</span><br><span class="line">    departmentld,</span><br><span class="line">    <span class="built_in">sum</span>(salary)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) <span class="keyword">as</span> <span class="string">&#x27;累计工资&#x27;</span>,</span><br><span class="line">    <span class="built_in">sum</span>(salary)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="number">1</span> preceding) <span class="keyword">as</span> <span class="string">&#x27;本行加前一行&#x27;</span>,</span><br><span class="line">    <span class="built_in">sum</span>(salary)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="number">2</span> preceding) <span class="keyword">as</span> <span class="string">&#x27;本行加前两行&#x27;</span>,</span><br><span class="line">    <span class="built_in">sum</span>(salary)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">2</span> preceding <span class="keyword">and</span> <span class="number">1</span> following ) <span class="keyword">as</span> <span class="string">&#x27;前两行加到后一行&#x27;</span>,</span><br><span class="line">    <span class="built_in">sum</span>(salary)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> <span class="number">1</span> unbounded following ) <span class="keyword">as</span> <span class="string">&#x27;当前行加到后一行&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>这段 SQL 查询使用了窗口函数来计算不同范围内的工资累计值。如下图：</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/3aae9b54b94e6c6d61ea1cab1887271d" alt="1" /></p><p>下面来让我们逐行解释每个窗口函数的含义：</p><ol><li><strong>累计工资</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(salary) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id) <span class="keyword">as</span> <span class="string">&#x27;累计工资&#x27;</span></span><br></pre></td></tr></table></figure>这个窗口函数计算从第一行到当前行的工资累计值。由于没有指定 <code>ROWS</code> 或 <code>RANGE</code> 子句，默认是 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>，即从分区的第一行到当前行的累计值。</li><li><strong>本行加前一行</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(salary) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="number">1</span> preceding) <span class="keyword">as</span> <span class="string">&#x27;本行加前一行&#x27;</span></span><br></pre></td></tr></table></figure>这个窗口函数计算当前行和前一行的工资总和。<code>ROWS 1 PRECEDING</code> 表示窗口从当前行的前一行开始，到当前行结束。</li><li><strong>本行加前两行</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(salary) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="number">2</span> preceding) <span class="keyword">as</span> <span class="string">&#x27;本行加前两行&#x27;</span></span><br></pre></td></tr></table></figure>这个窗口函数计算当前行和前两行的工资总和。<code>ROWS 2 PRECEDING</code> 表示窗口从当前行的前两行开始，到当前行结束。</li><li><strong>前两行加到后一行</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(salary) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">2</span> preceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="keyword">as</span> <span class="string">&#x27;前两行加到后一行&#x27;</span></span><br></pre></td></tr></table></figure>这个窗口函数计算从当前行的前两行到当前行的后一行的工资总和。<code>ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING</code> 表示窗口从当前行的前两行开始，到当前行的后一行结束。</li><li><strong>当前行加到后一行</strong>： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(salary) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> <span class="number">1</span> unbounded following) <span class="keyword">as</span> <span class="string">&#x27;当前行加到后一行&#x27;</span></span><br></pre></td></tr></table></figure>这个窗口函数计算从当前行到分区的最后一行的工资总和。<code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code> 表示窗口从当前行开始，到分区的最后一行结束。</li></ol><p><strong>示例2：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    salary,</span><br><span class="line">    departmentld,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">10000</span> preceding <span class="keyword">and</span> <span class="number">10000</span> following) <span class="keyword">as</span> <span class="string">&#x27;员工人数（薪资在±10000）&#x27;</span>,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">5000</span> preceding <span class="keyword">and</span> <span class="number">5000</span> following) <span class="keyword">as</span> <span class="string">&#x27;员工人数（薪资在±5000）&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>这段 SQL 查询使用了窗口函数来计算在特定薪资范围内的员工人数。具体来说，它使用了 <code>RANGE</code> 子句来定义窗口，该窗口基于薪资的值范围。如下图：</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/d2420c572cc95fa9bb7eb24963b10385" alt="2" /><br />让我们逐行解释每个窗口函数的含义：</p><ol><li><p><strong>员工人数（薪资在±10000）</strong>：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">10000</span> preceding <span class="keyword">and</span> <span class="number">10000</span> following) <span class="keyword">as</span> <span class="string">&#x27;员工人数（薪资在±10000）&#x27;</span></span><br></pre></td></tr></table></figure><p>这个窗口函数计算薪资在当前行薪资的±10000范围内的员工人数。例如，如果当前员工的薪资是 15000 元，那么薪资在5000元到25000元之间的所有员工都会被统计在内。</p><p><code>RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING</code> 表示窗口从当前行薪资的前 10000 开始，到当前行薪资的后 10000 结束。</p></li><li><p><strong>员工人数（薪资在±5000）</strong>：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">5000</span> preceding <span class="keyword">and</span> <span class="number">5000</span> following) <span class="keyword">as</span> <span class="string">&#x27;员工人数（薪资在±5000）&#x27;</span></span><br></pre></td></tr></table></figure><p>这个窗口函数计算薪资在当前行薪资的±5000范围内的员工人数。例如，如果当前员工的薪资是 15000 元，那么薪资在10000元到20000元之间的所有员工都会被统计在内。</p><p><code>RANGE BETWEEN 5000 PRECEDING AND 5000 FOLLOWING</code> 表示窗口从当前行薪资的前 5000 开始，到当前行薪资的后 5000 结束。</p></li></ol><h4 id="排序窗口函数"><a class="markdownIt-Anchor" href="#排序窗口函数"></a> 排序窗口函数</h4><p>排序窗口函数用于为结果集中的每一行分配一个唯一的序号或排名。常见的排序窗口函数包括：</p><ul><li><code>ROW_NUMBER()</code>：为每一行分配一个唯一的序号。</li><li><code>RANK()</code>：为每一行分配一个排名，排名相同的行会有相同的序号，后续的排名会跳过。</li><li><code>DENSE_RANK()</code>：与 <code>RANK()</code> 类似，但后续的排名不会跳过。</li><li><code>NTILE(n)</code>：将结果集分成 <code>n</code> 个桶，并为每一行分配一个桶号。</li><li><code>PERCENT_RANK()</code>：计算每一行的百分比排名，结果在0到1之间。</li><li><code>CUME_DIST()</code>：计算每一行的累积分布，结果在0到1之间。</li></ul><ol><li>窗口函数只能写在<code>select</code>字句中</li><li>窗口函数中的<code>partition by</code>子句可以指定数据的分区，和<code>group by</code>要去重分组不同的是，<code>partition by</code><strong>只分区不去重</strong></li><li>窗口函数中没有<code>partition by</code>子句时，即不对数据分区，直接整个表为一个区</li><li>排序窗口函数中<code>order by</code>子句是<strong>必选项</strong>，窗口函数中<code>order by</code>子句在<strong>分区内</strong>，依据指定字段和排序方法对数据行排序</li><li><code>rank()、dense_rank0、row_number()</code>指定排序赋值方法，对比三个排序窗口函数的异同：<ul><li>rank():跳跃式排序–比如数值为99，99，90，89，那么通过这个函数得到的排名为1，1，3，4</li><li>dense_rank():并列连续型排序–比如数值为99，99，90，89，那么通过这个函数得到的排名为1，1，2，3</li><li>row_number():连续型排序–比如数值为99，99，90，89，那么通过这个函数得到的排名为1，2，3，4</li><li>根据对排序值的需求选择相应的排序窗口函数，由于值的不同特性(比如数值不重复)，这三个函数可以通用<br /><strong>示例</strong>：</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,</span><br><span class="line">    employee_name,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank,</span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dense_rank</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们对每个部门的员工按工资从高到低进行排序，并为每个员工分配行号、排名和密集排名。</p><h4 id="偏移分析函数"><a class="markdownIt-Anchor" href="#偏移分析函数"></a> 偏移分析函数</h4><p>偏移分析函数用于访问窗口内其他行的数据，常见的偏移分析函数包括：</p><ul><li><code>LAG(expression, offset, default)</code>：用于访问当前行之前的第 <code>offset</code> 行的数据，如果没有找到则返回 <code>default</code>。</li><li><code>LEAD(expression, offset, default)</code>：用于访问当前行之后的第 <code>offset</code> 行的数据，如果没有找到则返回 <code>default</code>。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="built_in">LAG</span>(salary, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">AS</span> previous_salary,</span><br><span class="line">    <span class="built_in">LEAD</span>(salary, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">AS</span> next_salary</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>LAG</code> 函数获取当前行的上一行的工资，使用 <code>LEAD</code> 函数获取当前行的下一行的工资。如果没有找到对应的行，则返回默认值 <code>0</code>。这样可以方便地进行比较分析。</p><h3 id="表连接"><a class="markdownIt-Anchor" href="#表连接"></a> 表连接</h3><p>表连接是关系型数据库中用于合并两个或多个表的数据的一种操作。表连接基于这些表之间的相关列进行操作。</p><h4 id="内连接inner-join"><a class="markdownIt-Anchor" href="#内连接inner-join"></a> <strong>内连接（INNER JOIN）</strong>：</h4><p>内连接返回两个表中满足连接条件的记录。只有当连接条件为真时，记录才会被包含在结果集中。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>INNER JOIN table2</code>：指定要连接的表。</li><li><code>ON table1.common_field = table2.common_field</code>：指定连接条件，即两个表中用于匹配的列。</li></ul><h4 id="左连接left-join-或-left-outer-join"><a class="markdownIt-Anchor" href="#左连接left-join-或-left-outer-join"></a> <strong>左连接（LEFT JOIN 或 LEFT OUTER JOIN）</strong>：</h4><p>左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中对应的部分为 NULL。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>LEFT JOIN table2</code>：指定要连接的表。</li><li><code>ON table1.common_field = table2.common_field</code>：指定连接条件。</li></ul><h4 id="右连接right-join-或-right-outer-join"><a class="markdownIt-Anchor" href="#右连接right-join-或-right-outer-join"></a> <strong>右连接（RIGHT JOIN 或 RIGHT OUTER JOIN）</strong>：</h4><p>右连接返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中对应的部分为 NULL。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>RIGHT JOIN table2</code>：指定要连接的表。</li><li><code>ON table1.common_field = table2.common_field</code>：指定连接条件。</li></ul><h4 id="全外连接full-outer-join-或-full-join"><a class="markdownIt-Anchor" href="#全外连接full-outer-join-或-full-join"></a> <strong>全外连接（FULL OUTER JOIN 或 FULL JOIN）</strong>：</h4><p>全外连接返回两个表中的所有记录，当没有匹配的记录时，结果集中对应的部分为 NULL。MySQL本身不支持FULL OUTER JOIN，但可以通过UNION操作实现类似效果。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_field <span class="operator">=</span> table2.common_field;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>LEFT JOIN table2</code>：指定要连接的表。</li><li><code>ON table1.common_field = table2.common_field</code>：指定连接条件。</li><li><code>UNION</code>：合并两个查询结果。</li></ul><h4 id="交叉连接cross-join"><a class="markdownIt-Anchor" href="#交叉连接cross-join"></a> <strong>交叉连接（CROSS JOIN）</strong>：</h4><p>交叉连接返回两个表的笛卡尔积，即第一个表的每一行与第二个表的每一行组合。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>CROSS JOIN table2</code>：指定要连接的表。</li></ul><h3 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h3><p>子查询是嵌套在另一个查询中的查询，是优先于主查询的，它可以出现在SQL语句的多个部分，如SELECT、FROM、WHERE、HAVING等子句中。子查询可以返回单个值、一列值或一个表。</p><h4 id="标量子查询scalar-subquery"><a class="markdownIt-Anchor" href="#标量子查询scalar-subquery"></a> <strong>标量子查询（Scalar Subquery）</strong>：</h4><p>标量子查询返回单个值，通常用在SELECT子句或WHERE子句中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, (<span class="keyword">SELECT</span> scalar_column <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>) <span class="keyword">AS</span> alias</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2, ...</code>：选择需要查询的列。</li><li><code>(SELECT scalar_column FROM table2 WHERE condition)</code>：标量子查询，返回单个值。</li><li><code>AS alias</code>：为子查询结果指定别名。</li><li><code>FROM table1</code>：指定主表。</li><li><code>WHERE condition</code>：指定查询条件。</li></ul><h4 id="列子查询column-subquery"><a class="markdownIt-Anchor" href="#列子查询column-subquery"></a> <strong>列子查询（Column Subquery）</strong>：</h4><p>列子查询返回一列值，通常用在WHERE子句中，与IN、ANY、ALL等操作符一起使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> column1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>WHERE column1 IN (SELECT column1 FROM table2 WHERE condition)</code>：列子查询，返回一列值。</li></ul><h4 id="行子查询row-subquery"><a class="markdownIt-Anchor" href="#行子查询row-subquery"></a> <strong>行子查询（Row Subquery）</strong>：</h4><p>行子查询返回一行值，通常用在WHERE子句中，与比较操作符一起使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> (column1, column2) <span class="operator">=</span> (<span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2</code>：选择需要查询的列。</li><li><code>FROM table1</code>：指定主表。</li><li><code>WHERE (column1, column2) = (SELECT column1, column2 FROM table2 WHERE condition)</code>：行子查询，返回一行值。</li></ul><h4 id="表子查询table-subquery"><a class="markdownIt-Anchor" href="#表子查询table-subquery"></a> <strong>表子查询（Table Subquery）</strong>：</h4><p>表子查询返回一个表，通常用在FROM子句中，作为临时表使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, a.column2</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> table1 <span class="keyword">ON</span> a.common_field <span class="operator">=</span> table1.common_field;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT a.column1, a.column2</code>：选择需要查询的列。</li><li><code>FROM (SELECT column1, column2 FROM table2 WHERE condition) AS a</code>：表子查询，返回一个表。</li><li><code>JOIN table1 ON a.common_field = table1.common_field</code>：与主表进行连接。</li></ul><h4 id="相关子查询correlated-subquery"><a class="markdownIt-Anchor" href="#相关子查询correlated-subquery"></a> <strong>相关子查询（Correlated Subquery）</strong>：</h4><p>相关子查询依赖于外部查询的值，它会对每个外部查询的行进行一次评估。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1 a</span><br><span class="line"><span class="keyword">WHERE</span> column1 <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column1) <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> table2.common_field <span class="operator">=</span> a.common_field);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>SELECT column1, column2</code>：选择需要查询的列。</li><li><code>FROM table1 a</code>：指定主表，并为其指定别名。</li><li><code>WHERE column1 = (SELECT MAX(column1) FROM table2 WHERE table2.common_field = a.common_field)</code>：相关子查询，依赖于外部查询的值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL作为一种广泛使用的关系型数据库管理系统，是每个数据分析师必备技能，下面让我们来探讨如何利用MySQL进行高效的数据分析。&lt;/p&gt;
&lt;h2 id=&quot;基础语句&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础语句&quot;&gt;&lt;/a&gt; 基础语句&lt;/</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>随机森林如何调参</title>
    <link href="https://sherry14love.github.io/2024/07/15/learn/data6/"/>
    <id>https://sherry14love.github.io/2024/07/15/learn/data6/</id>
    <published>2024-07-14T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:21.189Z</updated>
    
    <content type="html"><![CDATA[<p>随机森林是一种强大的集成学习方法，通过构建多个决策树并取它们的平均值来进行预测。为了获得最佳性能，需要对随机森林模型进行调参。以下是一些常见的参数和调参方法：</p><h3 id="常见参数"><a class="markdownIt-Anchor" href="#常见参数"></a> 常见参数</h3><ol><li><strong>n_estimators</strong>: 决策树的数量。通常，增加树的数量可以提高模型的性能，但也会增加计算成本。</li><li><strong>max_depth</strong>: 每棵树的最大深度。限制树的深度可以防止过拟合。</li><li><strong>min_samples_split</strong>: 内部节点再划分所需最小样本数。增加这个值可以防止过拟合。</li><li><strong>min_samples_leaf</strong>: 叶子节点最少样本数。增加这个值可以防止过拟合。</li><li><strong>max_features</strong>: 寻找最佳分割时要考虑的特征数量。通常，默认值（“auto&quot;或&quot;sqrt”）效果较好。</li><li><strong>bootstrap</strong>: 是否进行自助采样。通常设置为True。</li></ol><h3 id="调参方法"><a class="markdownIt-Anchor" href="#调参方法"></a> 调参方法</h3><h4 id="1-网格搜索grid-search"><a class="markdownIt-Anchor" href="#1-网格搜索grid-search"></a> 1. 网格搜索（Grid Search）</h4><p>网格搜索是一种穷举搜索方法，通过遍历给定的参数组合来找到最佳参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数网格</span></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: [<span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>],</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: [<span class="literal">None</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;max_features&#x27;</span>: [<span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机森林模型</span></span><br><span class="line">rf_model = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建GridSearchCV对象</span></span><br><span class="line">grid_search = GridSearchCV(estimator=rf_model, param_grid=param_grid, </span><br><span class="line">                           cv=<span class="number">3</span>, n_jobs=-<span class="number">1</span>, verbose=<span class="number">2</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最佳参数</span></span><br><span class="line">best_params = grid_search.best_params_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best Parameters: <span class="subst">&#123;best_params&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-随机搜索randomized-search"><a class="markdownIt-Anchor" href="#2-随机搜索randomized-search"></a> 2. 随机搜索（Randomized Search）</h4><p>随机搜索是一种在参数空间中随机采样的方法，适用于参数空间较大的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint <span class="keyword">as</span> sp_randint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数分布</span></span><br><span class="line">param_dist = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: sp_randint(<span class="number">50</span>, <span class="number">200</span>),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: [<span class="literal">None</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: sp_randint(<span class="number">2</span>, <span class="number">11</span>),</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: sp_randint(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">&#x27;max_features&#x27;</span>: [<span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机森林模型</span></span><br><span class="line">rf_model = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建RandomizedSearchCV对象</span></span><br><span class="line">random_search = RandomizedSearchCV(estimator=rf_model, param_distributions=param_dist, </span><br><span class="line">                                   n_iter=<span class="number">100</span>, cv=<span class="number">3</span>, n_jobs=-<span class="number">1</span>, verbose=<span class="number">2</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">random_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最佳参数</span></span><br><span class="line">best_params = random_search.best_params_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best Parameters: <span class="subst">&#123;best_params&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-基于贝叶斯优化的调参"><a class="markdownIt-Anchor" href="#3-基于贝叶斯优化的调参"></a> 3. 基于贝叶斯优化的调参</h4><p>贝叶斯优化是一种更高效的调参方法，通过构建概率模型来选择最有可能改善性能的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skopt <span class="keyword">import</span> BayesSearchCV</span><br><span class="line"><span class="keyword">from</span> skopt.space <span class="keyword">import</span> Integer, Categorical</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数空间</span></span><br><span class="line">param_space = &#123;</span><br><span class="line">    <span class="string">&#x27;n_estimators&#x27;</span>: Integer(<span class="number">50</span>, <span class="number">200</span>),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: Categorical([<span class="literal">None</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]),</span><br><span class="line">    <span class="string">&#x27;min_samples_split&#x27;</span>: Integer(<span class="number">2</span>, <span class="number">11</span>),</span><br><span class="line">    <span class="string">&#x27;min_samples_leaf&#x27;</span>: Integer(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">&#x27;max_features&#x27;</span>: Categorical([<span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机森林模型</span></span><br><span class="line">rf_model = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建BayesSearchCV对象</span></span><br><span class="line">bayes_search = BayesSearchCV(estimator=rf_model, search_spaces=param_space, </span><br><span class="line">                             n_iter=<span class="number">50</span>, cv=<span class="number">3</span>, n_jobs=-<span class="number">1</span>, verbose=<span class="number">2</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">bayes_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最佳参数</span></span><br><span class="line">best_params = bayes_search.best_params_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best Parameters: <span class="subst">&#123;best_params&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随机森林是一种强大的集成学习方法，通过构建多个决策树并取它们的平均值来进行预测。为了获得最佳性能，需要对随机森林模型进行调参。以下是一些常见的参数和调参方法：&lt;/p&gt;
&lt;h3 id=&quot;常见参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常见参</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之Tableau食用指南</title>
    <link href="https://sherry14love.github.io/2024/07/12/learn/tableau/"/>
    <id>https://sherry14love.github.io/2024/07/12/learn/tableau/</id>
    <published>2024-07-11T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:39.719Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tableau：最易上手且功能强大的可视化操作BI工具</strong></p><p>Tableau是一款广受欢迎的商业智能（BI）工具，以其直观的用户界面和强大的数据可视化功能而闻名。无论是数据分析师、业务用户还是IT专业人员，都能快速上手并利用Tableau进行高效的数据分析和可视化展示。</p><p>相对于<strong>Excel</strong>，Tableau可以处理以亿为级别的数据，展现出其卓越的数据处理能力。而Excel在处理几十万条数据的时候，往往会出现卡顿现象，限制了其在大型数据集上的应用。</p><p>相较于<strong>MySQL</strong>，Tableau不仅提供了强大的数据连接和处理功能，还以其可视化操作和丰富的图表选项著称。用户可以通过Tableau直观地展示数据，进行深入的数据探索和分析，而MySQL虽然在业务取数方面表现出色，但在可视化能力上相对有限，无法全面满足复杂的数据展示需求。</p><p>相较于<strong>Python</strong>，Tableau的上手难度显著降低，用户无需深厚的编程基础，即可通过简单的操作实现复杂的数据分析和可视化。这种即学即用的特性，使得Tableau成为非专业人士进行数据分析的理想选择，而Python则需要用户投入较大的精力进行学习和实践。</p><p>相较于其他<strong>BI工具</strong>，Tableau在多个方面展现出其独特的优势：</p><ul><li><strong>更直观的用户界面</strong>：Tableau的拖放式操作界面和直观的图表生成方式，使得数据分析变得更加简单和直观。</li><li><strong>更灵活的数据连接</strong>：Tableau支持多种数据源的连接和混合分析，能够无缝集成各类数据，提供全面的数据洞察。</li><li><strong>更强大的交互功能</strong>：Tableau的仪表板支持丰富的交互功能，用户可以通过点击、筛选等操作深入探索数据，提升分析的深度和广度。</li><li><strong>更丰富的社区支持</strong>：Tableau拥有庞大的用户社区和丰富的在线资源，用户可以轻松获取帮助和学习资料，加速问题的解决和技能的提升。</li></ul><h2 id="数据连接"><a class="markdownIt-Anchor" href="#数据连接"></a> 数据连接</h2><p>Tableau支持与多种数据源的连接，包括本地文件、数据库、云服务等。以下是一些常见的数据连接方式：</p><ul><li><strong>本地文件</strong>：Tableau可以直接打开多种类型的本地文件，包括：<ul><li><strong>CSV文件</strong>：通常使用文本编辑器打开。</li><li><strong>Excel文件（xlsx）</strong>：使用Microsoft Excel打开。</li><li><strong>JSON文件</strong>：用于存储结构化数据的轻量级格式。</li><li><strong>Microsoft Access文件（mdb, accdb）</strong>：用于存储关系型数据的桌面数据库文件。</li><li><strong>PDF文件</strong>：虽然PDF主要用于文档展示，但Tableau可以通过插件或外部工具提取其中的数据。</li><li><strong>空间文件（如Shapefile, GeoJSON）</strong>：用于地理空间数据的存储和分析。</li><li><strong>统计文件（如SPSS, SAS）</strong>：用于存储统计分析数据的文件格式。</li></ul></li><li><strong>数据库</strong>：Tableau支持与多种数据库的连接，如MySQL、Oracle、SQL Server等。用户只需提供数据库的连接信息，即可将数据库中的数据导入Tableau进行分析。</li><li><strong>云服务</strong>：Tableau还支持与各种云服务的连接，如Amazon Redshift、Google BigQuery等。通过与云服务的集成，用户可以轻松访问和分析存储在云端的大量数据。</li></ul><hr /><p>在Tableau的数据连接世界中，实时连接与数据提取是两种核心的数据接入方式，它们各自拥有独特的优势和适用场景，共同构成了Tableau强大的数据处理能力。</p><h3 id="实时连接"><a class="markdownIt-Anchor" href="#实时连接"></a> 实时连接</h3><p>实时连接是Tableau的一项关键功能，它允许用户直接连接到数据源，实时获取和分析数据。这种方式的优势在于：</p><ul><li><strong>即时性</strong>：用户可以实时查看和分析最新的数据，无需等待数据提取和加载的过程，确保了分析结果的时效性和准确性。</li><li><strong>动态性</strong>：实时连接支持数据的动态更新和变化，用户可以在Tableau中观察到数据随时间的变化趋势，适用于需要频繁更新数据的场景。</li><li><strong>灵活性</strong>：用户可以根据需要灵活地调整查询条件和分析维度，实时获取所需的数据洞察，提高了数据分析的灵活性和响应速度。</li></ul><p>然而，实时连接也存在一定的局限性，例如在处理大规模数据集时可能会遇到性能瓶颈，以及对数据源的稳定性和响应速度有一定要求。</p><h3 id="数据提取"><a class="markdownIt-Anchor" href="#数据提取"></a> 数据提取</h3><p>数据提取是Tableau的另一种数据连接方式，它通过将数据从源系统提取到Tableau的本地存储中，实现数据的离线分析和处理。这种方式的优势在于：</p><ul><li><strong>性能优化</strong>：数据提取可以将大规模数据集加载到Tableau的本地存储中，通过优化数据结构和索引，提高数据查询和分析的性能，适用于处理复杂和大规模的数据集。</li><li><strong>稳定性</strong>：数据提取不受源系统性能和稳定性的影响，用户可以在Tableau中稳定地进行数据分析和可视化，确保了分析过程的连续性和可靠性。</li><li><strong>灵活性</strong>：用户可以根据需要定期更新数据提取，保持数据的最新状态，同时也可以对提取的数据进行预处理和清洗，提高数据分析的质量和效率。</li></ul><p>数据提取的局限性在于它需要定期更新以保持数据的最新状态，以及在处理实时数据变化时可能存在一定的延迟。</p><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><ul><li><strong>实时连接</strong>：适用于需要实时查看和分析最新数据的场景，如实时监控、实时报表、实时决策支持等。</li><li><strong>数据提取</strong>：适用于需要处理大规模数据集、进行复杂数据分析和可视化的场景，如历史数据分析、趋势预测、数据挖掘等。</li></ul><p>通过灵活运用实时连接和数据提取两种方式，Tableau为用户提供了全面的数据接入和分析能力，无论是实时数据监控还是深度数据挖掘，Tableau都能提供强大的支持。</p><h2 id="数据保存"><a class="markdownIt-Anchor" href="#数据保存"></a> 数据保存</h2><p>数据保存确保了用户的工作成果得以安全存储，便于后续的访问、分享和进一步分析。Tableau提供了多种数据保存方式，以满足不同用户的需求和场景。</p><h3 id="工作簿保存"><a class="markdownIt-Anchor" href="#工作簿保存"></a> 工作簿保存</h3><p>Tableau工作簿是用户进行数据分析和可视化的主要成果，包含了所有的数据连接、图表、仪表板和分析逻辑。Tableau支持将工作簿保存为<code>.twb</code>或<code>.twbx</code>格式：</p><ul><li><strong>.twb格式</strong>：这种格式保存了工作簿的结构和设置，但不包含数据提取。用户在打开<code>.twb</code>文件时需要重新连接到原始数据源。</li><li><strong>.twbx格式</strong>：这种格式是Tableau打包工作簿，包含了工作簿的所有内容，包括数据提取。用户在打开<code>.twbx</code>文件时无需重新连接数据源，可以直接进行分析。</li></ul><h3 id="数据提取保存"><a class="markdownIt-Anchor" href="#数据提取保存"></a> 数据提取保存</h3><p>对于通过数据提取方式连接的数据，Tableau允许用户将提取的数据保存为<code>.tde</code>或<code>.hyper</code>格式：</p><ul><li><strong>.tde格式</strong>：这是Tableau Data Extract的旧格式，适用于Tableau 10.x及更早版本。它支持数据的压缩和优化，便于快速加载和分析。</li><li><strong>.hyper格式</strong>：这是Tableau Data Extract的新格式，从Tableau 10.5开始引入。它提供了更高的性能和更灵活的数据模型，支持更复杂的数据类型和操作。</li></ul><h3 id="数据源保存"><a class="markdownIt-Anchor" href="#数据源保存"></a> 数据源保存</h3><p>Tableau还支持将数据源保存为<code>.tds</code>或<code>.tdsx</code>格式：</p><ul><li><strong>.tds格式</strong>：这种格式保存了数据源的连接信息和设置，但不包含数据提取。用户在打开<code>.tds</code>文件时需要重新连接到原始数据源。</li><li><strong>.tdsx格式</strong>：这种格式是Tableau打包数据源，包含了数据源的所有内容，包括数据提取。用户在打开<code>.tdsx</code>文件时无需重新连接数据源，可以直接使用。</li></ul><h3 id="云端保存"><a class="markdownIt-Anchor" href="#云端保存"></a> 云端保存</h3><p>随着云计算的普及，Tableau也提供了云端保存的选项，支持将工作簿和数据提取保存到Tableau Online或Tableau Server：</p><ul><li><strong>Tableau Online</strong>：这是Tableau的云服务平台，用户可以将工作簿和数据提取上传到云端，实现跨设备的访问和协作。</li><li><strong>Tableau Server</strong>：这是Tableau的企业级服务器解决方案，支持在企业内部部署，提供更强大的数据管理和安全控制。</li></ul><h3 id="数据备份与恢复"><a class="markdownIt-Anchor" href="#数据备份与恢复"></a> 数据备份与恢复</h3><p>为了确保数据的安全性，Tableau还提供了数据备份和恢复的功能。用户可以定期备份工作簿、数据提取和数据源，以防止数据丢失或损坏。在需要时，用户可以通过备份文件快速恢复数据，确保分析工作的连续性和可靠性。</p><h2 id="数据解释器"><a class="markdownIt-Anchor" href="#数据解释器"></a> 数据解释器</h2><p>数据解释器清理是Tableau中的一项功能，主要用于处理和清理导入的数据，以便更有效地进行数据分析和可视化。以下是数据解释器清理的具体含义和作用：</p><h3 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h3><p>数据解释器清理是指在Tableau中导入数据时，自动识别和处理数据中的常见问题，如重复行、缺失值、格式不一致等。这一过程旨在提高数据的质量和一致性，确保后续的数据分析和可视化更加准确和可靠。</p><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><ol><li><strong>数据清洗</strong>：自动识别和删除重复的行，填充或删除缺失值，统一数据格式，从而提高数据的整体质量。</li><li><strong>简化分析</strong>：通过清理数据，减少分析过程中的干扰因素，使分析师能够更专注于数据的实质内容和洞察。</li><li><strong>提升可视化效果</strong>：高质量的数据是生成有效可视化图表的基础。数据解释器清理确保数据在可视化过程中能够准确反映实际情况，避免误导性的图表和结论。</li><li><strong>节省时间</strong>：手动清理数据通常耗时且容易出错。数据解释器清理功能能够自动完成这些任务，节省分析师的时间和精力，使其能够更快地进行数据探索和分析。</li></ol><p>在Tableau中，数据解释器清理功能通常在数据源设置阶段启用。用户可以在导入数据时选择启用数据解释器，Tableau将自动进行数据清理。这一功能特别适用于处理来自不同来源和格式的数据，确保数据在导入后即可用于分析和可视化。</p><h2 id="数据可视化"><a class="markdownIt-Anchor" href="#数据可视化"></a> 数据可视化</h2><p>我们之所以需要数据可视化，是因为在缺乏专业训练的情况下，面对一堆数字，我们往往难以迅速识别出其中的最大值、最小值等关键信息。人类对数据的敏感度实际上是相对较低的。</p><p>然而，一旦我们通过可视化操作，将这些数字转化为直观的图像，我们的数据敏感度便会显著提升。这是因为人类天生就是图像视觉动物，我们的大脑更擅长处理和理解视觉信息。通过图表、图形等视觉元素，我们能够更快速、更直观地捕捉到数据的核心特征和内在规律，从而更有效地进行数据分析和决策。</p><p>其实对于tableau，我们要做的，熟能生巧就可以了，除此之外，要掌握做表格、做词云、做其他基础图表的能力。</p><p>其实总结来说，就是：</p><ul><li>度量默认聚合</li><li>度量值会形成图形标记，图形标记可以切换</li><li>维度会对度量值进行区分，增加度量值的信息密度</li><li>图表分为有轴图表和无轴图表(极坐标图表)</li><li>离散形成标签，连续形成数轴</li></ul><h2 id="基础图表制作指南"><a class="markdownIt-Anchor" href="#基础图表制作指南"></a> 基础图表制作指南</h2><h3 id="柱状图"><a class="markdownIt-Anchor" href="#柱状图"></a> 柱状图</h3><p>在成功连接数据源后，创建一个新的工作表。将所需数据分别拖拽至<code>行</code>和<code>列</code>区域，即可轻松生成柱状图。</p><h3 id="条形图"><a class="markdownIt-Anchor" href="#条形图"></a> 条形图</h3><p>若需将柱状图转换为条形图，只需点击工具栏中的排序快捷图标左侧，选择<code>交换行和列</code>（快捷键：Ctrl+W）。此外，通过在维度数据上右键点击并选择<code>创建分层结构</code>，可实现数据的分层展示，这是一个非常便捷的功能。</p><h4 id="筛选器"><a class="markdownIt-Anchor" href="#筛选器"></a> 筛选器</h4><p>筛选器是基础且实用的功能之一。在点击<code>显示筛选器</code>后，右侧将出现筛选面板，可用于按数值、日期、门店等条件进行图像筛选。</p><h3 id="热力图"><a class="markdownIt-Anchor" href="#热力图"></a> 热力图</h3><p>首先创建一个表格，然后将度量值数据拖至<code>颜色</code>区域，并将标记类型更改为<code>方形</code>，即可完成热力图的制作。</p><h3 id="气泡图和词云"><a class="markdownIt-Anchor" href="#气泡图和词云"></a> 气泡图和词云</h3><p>将数值度量放置于<code>大小</code>区域，将名称等维度量放置于<code>标签</code>或<code>文本</code>区域，并将标记类型改为<code>圆</code>，即可生成气泡图或词云。</p><h3 id="饼图"><a class="markdownIt-Anchor" href="#饼图"></a> 饼图</h3><p>制作饼图的方法与气泡图类似。将标记类型更改为<code>饼图</code>，将数值度量放置于<code>角度</code>区域，将名称等维度量放置于<code>颜色</code>区域。若需显示百分比或标签，按住<code>Ctrl</code>键将相应内容拖至<code>标签</code>区域。对于百分比显示，右键点击数值度量（位于<code>标签</code>中），选择<code>快速表计算</code> -&gt; <code>合计百分比</code>，并在<code>设置格式</code> -&gt; <code>数字</code> -&gt; <code>百分比</code>中进行进一步设置。</p><h3 id="树地图"><a class="markdownIt-Anchor" href="#树地图"></a> 树地图</h3><p>树地图的制作与饼图相似。将维度量放置于<code>颜色</code>区域，将<code>角度</code>区域中的数据度量拖至<code>大小</code>区域，并将标记类型更改为<code>方形</code>。</p><h3 id="堆积图"><a class="markdownIt-Anchor" href="#堆积图"></a> 堆积图</h3><p>堆积图适用于对比分析。首先将一个维度量放置于<code>列</code>区域，将数据度量放置于<code>行</code>区域，然后将另一个维度量放置于<code>颜色</code>区域。</p><h4 id="编辑表计算-数值"><a class="markdownIt-Anchor" href="#编辑表计算-数值"></a> 编辑表计算 - 数值</h4><p>选择<code>标签</code>区域中的数据度量，右键点击并选择<code>编辑表计算</code>，然后选择<code>表向下</code>，即可查看每列不同维度量之间的百分比差异。</p><h4 id="编辑表计算-数轴"><a class="markdownIt-Anchor" href="#编辑表计算-数轴"></a> 编辑表计算 - 数轴</h4><p>选择<code>行</code>区域中的数据度量，右键点击并依次选择<code>快速表计算</code> -&gt; <code>合计百分比</code>，然后选择<code>编辑表计算</code>并点击<code>表向下</code>，以显示相对百分比，使占比变化更加明显。</p><h3 id="折线图"><a class="markdownIt-Anchor" href="#折线图"></a> 折线图</h3><p>选择相应的行列数据，并将标记类型设置为<code>线</code>。通过添加筛选器，可以在<code>分析</code>菜单中点击<code>预测</code>，以获得一定的可信度分析。日期数据通常放置于<code>列</code>区域，右键点击可选择离散或连续的年月周日数据，通常使用连续数据进行操作。此外，还可以在<code>分析</code>菜单中添加趋势线、盒须图等分析工具。</p><h3 id="面积图"><a class="markdownIt-Anchor" href="#面积图"></a> 面积图</h3><p>选择相应的行列数据，将标记类型设置为<code>区域</code>，并将具有区分性的维度量放置于<code>颜色</code>区域，即可生成面积图。</p><h3 id="散点图"><a class="markdownIt-Anchor" href="#散点图"></a> 散点图</h3><p>选择相应的行列数据，将标记类型设置为<code>自动</code>，并将具有区分性的维度量放置于<code>颜色</code>或<code>详细信息</code>区域。最后，添加<code>分析</code>菜单中的<code>趋势线</code>，以完善散点图。根据需求，还可以添加<code>群集</code>功能进行分类。</p><h3 id="直方图"><a class="markdownIt-Anchor" href="#直方图"></a> 直方图</h3><p>首先创建一个<code>数据桶</code>，然后将其拖至相应的行和列区域。可根据需要添加其他维度量进行区分。</p><h3 id="地图"><a class="markdownIt-Anchor" href="#地图"></a> 地图</h3><p>将城市、省份、国家等维度量右键点击并选择<code>地理角色</code>，更改为相应的角色。然后双击或使用智能推荐功能，即可生成相应的地理图。后续可加入行列数据和其他筛选条件进行进一步区分。</p><blockquote><p>在进行<code>距离</code>类型的维度量分析时，我们通常会通过右键选择<code>创建</code>-&gt;<code>组</code>的方式，将不同距离区间进行分组。以美化可视化效果并清晰区分各组与门店的距离,从而提升数据解读的直观性和效率。</p></blockquote><h4 id="主键"><a class="markdownIt-Anchor" href="#主键"></a> 主键</h4><p>在处理大量数据时，为了便于区分和识别，我们通常会创建一个主键，以实现数据的唯一标识。在操作界面的左侧，我们可以看到<code>查看数据</code>和<code>查找字段</code>等功能选项，而右侧则提供了<code>创建计算字段</code>的选项。通过点击<code>创建计算字段</code>，我们可以选择合适的维度量来构建一个具有唯一标识的主键。这样，在后续的数据处理过程中，我们便能够更加准确地区分和识别每一条数据。</p><h2 id="bi仪表盘"><a class="markdownIt-Anchor" href="#bi仪表盘"></a> BI仪表盘</h2><p>在精心打造BI仪表盘的过程中，我们首先需要精准定位我们的目标观众，这包括但不限于业务人员、中层管理者、高级管理者以及用人单位等。</p><p>每类观众因其职责和需求的不同，对仪表盘的功能和呈现方式有着各自独特的要求：</p><ul><li>对于业务人员而言，他们更关注与自身业务紧密相关的数据细节，因此仪表盘应提供直观、具体的数据展示，以便他们快速获取所需信息，辅助日常业务决策。</li><li>中层管理者则需要一个全面而精炼的总结报告，涵盖各个关键维度的数据。这样的仪表盘应具备多维度分析能力，能够帮助他们从宏观层面把握业务动态，同时也能深入到具体细节，以便进行更为精准的管理和指导。</li><li>高级管理者通常关注的是整体战略层面的总结报告。因此，他们的仪表盘应简洁明了，突出关键指标和趋势，以便他们迅速把握全局，做出高层次的决策。</li><li>至于用人单位，他们往往需要一个明确的分析主题，且分析的维度越深入、图表越高级，越能满足他们的需求。这类仪表盘应具备强大的数据挖掘和可视化能力，能够提供深入的分析结果，帮助用人单位洞察数据背后的深层次信息。</li></ul><h3 id="如何明确主题"><a class="markdownIt-Anchor" href="#如何明确主题"></a> 如何明确主题</h3><p>在明确目标观众后，我们需要进一步确定仪表盘的主题。这一步骤至关重要，因为它直接关系到仪表盘的内容和结构。我们可以通过以下几个步骤来明确主题：</p><ol><li><strong>需求调研</strong>：深入了解目标观众的具体需求和痛点，通过访谈、问卷等方式收集信息。这一阶段，我们需要关注观众对数据的具体需求，包括他们希望看到哪些数据、这些数据的重要程度是否相同，以及他们希望通过这些数据解决什么问题。</li><li><strong>数据梳理与分类</strong>：根据调研结果，对涉及的数据进行梳理和分类。这一步骤中，我们需要识别出哪些数据是核心数据，哪些是辅助数据，以及它们之间的关联性。同时，我们还需要评估每类数据的重要程度，确保在后续的仪表盘设计中能够合理分配展示空间。</li><li><strong>关键指标筛选</strong>：在数据梳理的基础上，筛选出与主题紧密相关的关键指标。这些指标应能够全面反映主题的核心内容，并且具有较高的重要程度。通过这一步骤，我们可以确保仪表盘的主题突出，避免信息过载。</li><li><strong>数据整合与分析</strong>：对筛选出的关键指标进行数据整合和深入分析，挖掘数据背后的关联和趋势。这一阶段，我们需要运用各种数据分析工具和方法，对数据进行深入剖析，以便为可视化设计提供有力的支撑。</li><li><strong>可视化设计</strong>：根据分析结果，设计直观、易懂的可视化图表，确保观众能够迅速理解数据含义。在设计过程中，我们需要充分考虑观众的认知习惯和视觉偏好，力求使图表既美观又实用。</li><li><strong>反馈与迭代</strong>：在仪表盘初步完成后，邀请目标观众进行试用，并根据反馈进行迭代优化。这一步骤中，我们需要关注观众的实际使用体验，及时调整和优化仪表盘的设计，确保其能够真正满足观众的需求。</li></ol><h3 id="最适合数据的图表"><a class="markdownIt-Anchor" href="#最适合数据的图表"></a> 最适合数据的图表</h3><ol><li>对比：</li></ol><ul><li>绝对值对比——条形图/柱状图</li></ul><ol start="2"><li>变化：</li></ol><ul><li>没有累计关系——折线图+柱状图</li><li>有累计关系——面积图/堆积图</li></ul><ol start="3"><li>构成：</li></ol><ul><li>对象少于3个——环形图</li><li>对象大于3个——树地图</li></ul><ol start="4"><li>分布：</li></ol><ul><li>单变量分布——直方图</li><li>多变量分布——散点图/气泡图</li></ul><h3 id="度量名称显示"><a class="markdownIt-Anchor" href="#度量名称显示"></a> 度量名称显示</h3><p>首先先把一个数据度量放在<code>文本</code>里，再拖动一个数据度量放在画布里那个显示的数据上，拖到上面会发现有个<code>+</code>或者<code>智能显示</code>，这样，就可以发现<code>行</code>上面显示一个<code>度量名称</code>，下面我们把<code>度量名称</code>拖到<code>列</code>上，然后把其他所需要的度量值托到左侧的<code>度量值</code>里就可以了。</p><blockquote><p>其实我们在做仪表盘的时候，会在筛选器里通常加入日期一类的维度量，然后右键点击<code>应用于工作表</code>-&gt;<code>使用相关数据源的所有项</code>，再<code>显示筛选器</code>，操作筛选器之后，你会发现，所有的表图都会根据你对筛选器变动，而不是只变动一张图表的。</p></blockquote><h3 id="双轴"><a class="markdownIt-Anchor" href="#双轴"></a> 双轴</h3><p>在Tableau中创建双轴（Dual Axis）可以帮助我们在一个图表中同时显示两个不同的度量，每个度量有自己的轴。这对于比较两个不同量级的数据或者展示两个相关但不同类型的数据非常有用。以下是如何在Tableau中创建双轴的步骤：</p><ol><li><strong>准备数据</strong>：确保你的数据源中有至少两个不同的度量（Metrics），这些度量将分别显示在两个轴上。</li><li><strong>创建第一个视图</strong>：将第一个度量拖到<code>行</code>或<code>列</code>功能区。例如，将<code>销售额</code>拖到<code>行</code>功能区。</li><li><strong>创建第二个视图</strong>：将第二个度量拖到与第一个度量相同的位置，例如，将<code>利润</code>拖到<code>行</code>功能区，并且放在<code>销售额</code>的旁边。</li><li><strong>转换为双轴</strong>：右键点击第二个度量（例如<code>利润</code>），然后选择<code>双轴</code>（Dual Axis）。</li><li><strong>调整轴和格式</strong>：你可以通过右键点击轴标签来调整每个轴的格式，比如设置轴的最小值、最大值、刻度间隔等。</li></ol><p>双轴的作用主要包括：</p><ul><li><strong>比较不同量级的数据</strong>：例如，销售额和利润，这两个数据可能量级不同，通过双轴可以更直观地比较。</li><li><strong>展示相关但不同类型的数据</strong>：例如，温度和降雨量，这两个数据虽然相关，但类型不同，通过双轴可以同时展示。</li><li><strong>增强可视化效果</strong>：双轴图表可以提供更丰富的信息，帮助用户更好地理解数据之间的关系。</li></ul><p>最后我们发现，这个双轴图并不美观，没关系，我们点击第一个视图，将其调整为条形图，并通过调整透明度和条形大小来增强视觉效果。具体操作如下：</p><ol><li><strong>选择条形图</strong>：在<code>标记</code>卡中，将图表类型从默认的折线图改为条形图。</li><li><strong>调整透明度</strong>：在<code>标记</code>卡下找到<code>颜色</code>选项，调整透明度滑块，降低条形图的透明度，使其更加柔和，不至于过于突兀。</li><li><strong>缩小条形大小</strong>：在<code>标记</code>卡中，找到<code>大小</code>选项，适当减小条形的大小，使其与后续的折线图更好地融合，保持图表的整体协调性。</li><li><strong>保持折线图</strong>：对于第二个视图，继续使用折线图，以保持数据的连续性和趋势的清晰展示。</li></ol><p>咳，最后的最后，我们再加一个<code>分析</code>里的<code>趋势线</code>，完美收工。</p><h3 id="环形图"><a class="markdownIt-Anchor" href="#环形图"></a> 环形图</h3><p>先做一个饼形图，然后在<code>行</code>的上面双击输入<code>0</code>，重复两次，可以得到两个图表，然后右键<code>双轴</code>，在左侧的下面的<code>总和(0)</code>里进行以下操作，首先把所有标签删除，把<code>颜色</code>改为纯白，最后把<code>大小</code>拉小，就可以得到一个环形图了。</p><p>不过这个时候会发现左右两侧会有轴线，我们右键轴线段，点击<code>显示标题</code>，就可以把轴线给隐藏掉。</p><p>还有一个零值线，我们右键画布，点击<code>设置格式</code>，点击字段左边的图标，里面是设置工作表的各种线和刻度的，找到<code>零值线</code>，将其设置为<code>无</code>，这样我们就可以得到一个干净的环形图了。</p><blockquote><p>如果遇到标签的名字不符合我们所期望的，我们可以右键<code>编辑别名</code>进行设置。</p></blockquote><h3 id="仪表盘布局"><a class="markdownIt-Anchor" href="#仪表盘布局"></a> 仪表盘布局</h3><p>常见的仪表盘布局有两种，一种是纵向的，另一种是横向的。</p><h3 id="仪表盘制作"><a class="markdownIt-Anchor" href="#仪表盘制作"></a> 仪表盘制作</h3><p>当你根据数据源做好各类图表的时候，直接在右下侧建立仪表盘，然后把图表拖拽到仪表盘中，进行布局调试和交互设计/记得加上边框哦，这样我们的仪表盘就制作成功了，如下图所示，这是拉姆自己用一个小项目进行的练手：<br /><img src="https://www.qiuxs.cn/sharing-tools/img/read/f294f36b1c59f4262381d6ecb16fd7d9" alt="图表1" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Tableau：最易上手且功能强大的可视化操作BI工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tableau是一款广受欢迎的商业智能（BI）工具，以其直观的用户界面和强大的数据可视化功能而闻名。无论是数据分析师、业务用户还是IT专业人员，都能快速上手并利用Tabl</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之Excel食用指南</title>
    <link href="https://sherry14love.github.io/2024/07/02/learn/excel/"/>
    <id>https://sherry14love.github.io/2024/07/02/learn/excel/</id>
    <published>2024-07-01T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:28.674Z</updated>
    
    <content type="html"><![CDATA[<p>Excel，作为微软公司开发的一款强大电子表格软件，不仅在数据分析、财务计算、项目管理、统计分析等领域发挥着重要作用，还因其丰富的数据处理和计算功能，以及多样化的图表和图形工具，成为高效管理和分析数据的得力助手。</p><p>如下图，是拉姆在系统学习Excel时制作的某店铺报表，其中利用了切片器灵活筛选美团、饿了么的数据情况，这是初级数据分析师所必须掌握的。接下来，我们要介绍关于excel的各类用法，帮助大家胜任数据分析师。</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/2775923e3ecc6eeb946155c4b77dfe86" alt="报表" /></p><h2 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h2><p>首先，为了确保数据的安全性和便于分析计算结果，我们需采取以下步骤：</p><ol><li>创建一个新的工作簿（例如工作簿2），专门用于存储和分析计算结果。</li><li>这样做的好处是可以避免在原始数据工作簿（例如工作簿1）中进行操作时可能导致的数据丢失或错误。</li><li>通过将分析和计算结果独立出来，可以更清晰地管理和查看数据，同时也便于进行后续的数据处理和报告生成。</li></ol><p>这种做法有助于保持数据的原貌，同时提供了一个专门的空间来进行数据分析和计算，确保了工作的有序性和高效性。</p><h3 id="等号的基础使用"><a class="markdownIt-Anchor" href="#等号的基础使用"></a> 等号的基础使用</h3><p>在Excel中，使用等号<code>=</code>是创建公式或引用其他单元格数据的关键步骤：</p><ol><li>打开一个新的工作簿（例如工作簿2），在任意一个单元格中输入等号<code>=</code>。</li><li>切换到另一个含有数据的工作簿（例如工作簿1）。</li><li>在工作簿1中选择我们想要引用的数据单元格，然后按回车键。</li><li>会自动回到工作簿2，可以发现所选单元格中显示了工作簿1中选定的数据。</li><li>如果需要引用工作簿1中同一列的连续数据，可以向下拖动工作簿2中单元格的填充柄（即单元格右下角的小方块），这样会自动引用工作簿1中相应列的后续数据。</li></ol><p>通过这种方式，可以方便地在不同工作簿之间引用和复制数据。</p><p>还有在一个单元格内输入等号<code>=</code>，可以选择各类函数，包括求和求平均的常用函数、财务、工程、日期与时间、统计、数学与三角函数等。</p><h3 id="绝对引用"><a class="markdownIt-Anchor" href="#绝对引用"></a> 绝对引用</h3><p>在Excel中，锁定引用通常指的是使用绝对引用，这样在复制公式时，引用的单元格不会改变。可以通过以下步骤来锁定引用：</p><ol><li><strong>选择单元格</strong>：首先，选择包含我们要锁定引用的公式的单元格。</li><li><strong>编辑公式</strong>：点击公式栏，进入公式编辑模式。</li><li><strong>锁定引用</strong>：在公式中，将光标放在我们要锁定的单元格引用上，然后按下 <code>F4</code> 键。每按一次 <code>F4</code> 键，引用就会在以下四种模式之间切换：<ul><li><strong>绝对引用</strong>：例如 <code>$A$1</code>，行和列都被锁定。</li><li><strong>混合引用（锁定行）</strong>：例如 <code>A$1</code>，只有行被锁定。</li><li><strong>混合引用（锁定列）</strong>：例如 <code>$A1</code>，只有列被锁定。</li><li><strong>相对引用</strong>：例如 <code>A1</code>，行和列都没有锁定。</li></ul></li><li><strong>完成公式</strong>：根据需要调整引用后，按 <code>Enter</code> 键完成公式的编辑。</li></ol><p>例如，如果我们有一个公式 <code>=A1</code>，并且想锁定这个引用，我们可以将光标放在 <code>A1</code> 上，然后按 <code>F4</code> 键，公式会变成 <code>=$A$1</code>。</p><p>这样，当我们复制这个公式到其他单元格时，<code>$A$1</code> 的引用不会改变，而相对引用会根据新单元格的位置自动调整。</p><h3 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h3><p><strong>Ctrl + Shift + L</strong>是排序和筛选功能的快捷键，选中数据，进行排序。</p><h3 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h3><h4 id="常用快捷键"><a class="markdownIt-Anchor" href="#常用快捷键"></a> 常用快捷键</h4><ul><li><strong>Ctrl + C</strong>：复制选中的单元格</li><li><strong>Ctrl + V</strong>：粘贴复制的内容</li><li><strong>Ctrl + X</strong>：剪切选中的单元格</li><li><strong>Ctrl + Z</strong>：撤销上一步操作</li><li><strong>Ctrl + Y</strong>：重做上一步操作</li><li><strong>Ctrl + S</strong>：保存当前工作簿</li><li><strong>Ctrl + P</strong>：打印当前工作表</li><li><strong>Ctrl + F</strong>：查找内容</li><li><strong>Ctrl + H</strong>：替换内容</li><li><strong>Ctrl + A</strong>：全选当前工作表</li><li><strong>Ctrl + B</strong>：应用或取消加粗格式</li><li><strong>Ctrl + I</strong>：应用或取消斜体格式</li><li><strong>Ctrl + U</strong>：应用或取消下划线</li><li><strong>Ctrl + K</strong>：插入或编辑超链接</li><li><strong>Ctrl + Shift + L</strong>：排序和筛选</li></ul><h4 id="导航快捷键"><a class="markdownIt-Anchor" href="#导航快捷键"></a> 导航快捷键</h4><ul><li><strong>Ctrl + 方向键</strong>：快速移动到数据区域的边缘</li><li><strong>Ctrl + Home</strong>：移动到工作表的第一个单元格（A1）</li><li><strong>Ctrl + End</strong>：移动到工作表的最后一个单元格（数据区域的右下角）</li><li><strong>Page Up</strong>：向上翻页</li><li><strong>Page Down</strong>：向下翻页</li><li><strong>Alt + Page Up</strong>：向左翻页</li><li><strong>Alt + Page Down</strong>：向右翻页</li></ul><h4 id="选择和编辑快捷键"><a class="markdownIt-Anchor" href="#选择和编辑快捷键"></a> 选择和编辑快捷键</h4><ul><li><strong>Shift + 方向键</strong>：扩展选定区域</li><li><strong>Shift + Ctrl + 方向键</strong>：快速选择数据区域</li><li><strong>F2</strong>：编辑活动单元格</li><li><strong>Enter</strong>：完成单元格输入并移动到下方单元格</li><li><strong>Tab</strong>：完成单元格输入并移动到右侧单元格</li><li><strong>Esc</strong>：取消单元格或编辑栏中的输入</li></ul><h4 id="格式化快捷键"><a class="markdownIt-Anchor" href="#格式化快捷键"></a> 格式化快捷键</h4><ul><li><strong>Ctrl + 1</strong>：打开“单元格格式”对话框</li><li><strong>Ctrl + Shift + $</strong>：应用货币格式</li><li><strong>Ctrl + Shift + %</strong>：应用百分比格式</li><li><strong>Ctrl + Shift + #</strong>：应用日期格式</li><li><strong>Ctrl + Shift + @</strong>：应用时间格式</li><li><strong>Ctrl + Shift + !</strong>：应用数字格式</li></ul><h4 id="工作表和窗口管理快捷键"><a class="markdownIt-Anchor" href="#工作表和窗口管理快捷键"></a> 工作表和窗口管理快捷键</h4><ul><li><strong>Ctrl + N</strong>：新建工作簿</li><li><strong>Ctrl + O</strong>：打开工作簿</li><li><strong>Ctrl + W</strong>：关闭当前工作簿</li><li><strong>Ctrl + F6</strong>：切换到下一个工作簿</li><li><strong>Ctrl + Shift + F6</strong>：切换到上一个工作簿</li><li><strong>Alt + F1</strong>：创建当前数据区域的图表</li><li><strong>F11</strong>：创建当前数据区域的图表并插入到新工作表中</li></ul><h2 id="进阶篇"><a class="markdownIt-Anchor" href="#进阶篇"></a> 进阶篇</h2><h3 id="数据透视表"><a class="markdownIt-Anchor" href="#数据透视表"></a> 数据透视表</h3><p>在Excel中，数据透视表是一种强大的数据分析工具，能够帮助用户快速汇总、分析和展示大量数据。以下是创建和使用数据透视表的详细步骤：</p><ol><li><strong>创建数据透视表</strong>：<ul><li>首先，选择我们想要分析的数据区域。确保数据区域包含标题行，以便数据透视表能够正确识别字段名称。</li><li>然后，点击Excel顶部菜单栏中的“插入”选项卡。</li><li>在“插入”选项卡中，找到并点击最左侧的“数据透视表”按钮。</li><li>在弹出的“创建数据透视表”对话框中，确认数据区域无误，并选择“新工作表”选项，以便将数据透视表放置在一个新的工作表中，保持原始数据的整洁。</li></ul></li><li><strong>配置数据透视表</strong>：<ul><li>创建数据透视表后，Excel会显示一个新的工作表，并在右侧打开“数据透视表字段”窗格。</li><li>在“数据透视表字段”窗格中，我们可以通过拖拽字段到不同的区域（行、列、值、筛选器）来配置数据透视表的布局。<ul><li><strong>行区域</strong>：拖拽字段到行区域，数据透视表将按该字段进行行排列。</li><li><strong>列区域</strong>：拖拽字段到列区域，数据透视表将按该字段进行列排列。</li><li><strong>值区域</strong>：拖拽字段到值区域，数据透视表将对该字段进行汇总计算（如求和、计数、平均值、方差等）。</li><li><strong>筛选器区域</strong>：拖拽字段到筛选器区域，可以对数据透视表进行条件筛选，以便查看特定数据子集。</li></ul></li></ul></li><li><strong>优化数据透视表</strong>：<ul><li>根据需要，我们可以进一步调整数据透视表的格式和布局，例如更改汇总方式、添加计算字段、设置条件格式等。</li><li>数据透视表还支持多种图表类型，我们可以通过点击“数据透视图”按钮，将数据透视表转换为图表，以便更直观地展示数据分析结果。</li></ul></li><li><strong>插入切片器</strong>：<ul><li>切片器是数据透视表的一个交互式组件，可以方便地对数据进行动态筛选。</li><li>要插入切片器，首先确保我们的数据透视表已经创建并配置好。</li><li>然后，点击“插入”选项卡中的“切片器”按钮。</li><li>在弹出的“插入切片器”对话框中，选择我们想要作为筛选条件的字段，然后点击“确定”。</li><li>切片器将以一个小窗口的形式出现在工作表中，我们可以通过点击切片器中的选项来动态筛选数据透视表中的数据。</li></ul></li><li><strong>刷新数据透视表</strong>：<ul><li>如果我们的原始数据发生了变化，需要更新数据透视表以反映最新的数据。</li><li>右键点击数据透视表中的任意单元格，选择“刷新”，或者点击“数据”选项卡中的“刷新”按钮。</li><li>数据透视表将重新计算并显示最新的数据。</li></ul></li><li><strong>数据透视表的高级功能</strong>：<ul><li><strong>计算字段和计算项</strong>：在数据透视表中添加自定义的计算字段或计算项，以进行更复杂的分析。</li><li><strong>数据透视表选项</strong>：通过“数据透视表选项”对话框，可以调整数据透视表的各种设置，如布局和格式、汇总和筛选、显示和打印等。</li><li><strong>数据模型</strong>：对于大型和复杂的数据集，可以使用数据模型来创建多表数据透视表，进行更深入的数据分析。</li></ul></li></ol><h3 id="数据透视图表"><a class="markdownIt-Anchor" href="#数据透视图表"></a> 数据透视图表</h3><p>在Excel中，数据透视图表是一种强大的可视化工具，它与数据透视表紧密结合，能够直观地展示数据的汇总和分析结果。以下是创建和使用数据透视图表的详细步骤：</p><ol><li><strong>创建数据透视图表</strong>：<ul><li>首先，确保我们已经创建并配置好了一个数据透视表。</li><li>然后，点击Excel顶部菜单栏中的“数据透视表分析”选项卡。</li><li>在“数据透视表分析”选项卡中，找到并点击“数据透视图”按钮。</li><li>在弹出的“插入图表”对话框中，选择我们想要的图表类型，如柱状图、折线图、饼图等。</li><li>点击“确定”，Excel将根据数据透视表的内容自动生成相应的数据透视图表。</li></ul></li><li><strong>配置数据透视图表</strong>：<ul><li>创建数据透视图表后，我们可以通过“数据透视图字段”窗格来配置图表的布局和内容。</li><li>在“数据透视图字段”窗格中，我们可以拖拽字段到不同的区域（轴、图例、值、筛选器）来调整图表的显示方式。<ul><li><strong>轴区域</strong>：拖拽字段到轴区域，图表将按该字段进行分类。</li><li><strong>图例区域</strong>：拖拽字段到图例区域，图表将按该字段进行分组。</li><li><strong>值区域</strong>：拖拽字段到值区域，图表将对该字段进行汇总计算（如求和、计数、平均值等）。</li><li><strong>筛选器区域</strong>：拖拽字段到筛选器区域，可以对图表进行条件筛选，以便查看特定数据子集。</li></ul></li></ul></li><li><strong>优化数据透视图表</strong>：<ul><li>根据需要，我们可以进一步调整数据透视图表的格式和样式，例如更改颜色、添加数据标签、调整图表标题等。</li><li>数据透视图表还支持交互式功能，如通过切片器进行动态筛选，使图表更加灵活和直观。</li></ul></li><li><strong>插入切片器</strong>：<ul><li>切片器是数据透视图表的一个交互式组件，可以方便地对数据进行动态筛选。</li><li>要插入切片器，首先确保我们的数据透视图表已经创建并配置好。</li><li>然后，点击“插入”选项卡中的“切片器”按钮。</li><li>在弹出的“插入切片器”对话框中，选择我们想要作为筛选条件的字段，然后点击“确定”。</li><li>切片器将以一个小窗口的形式出现在工作表中，我们可以通过点击切片器中的选项来动态筛选数据透视图表中的数据。</li></ul></li></ol><h3 id="vlookup函数"><a class="markdownIt-Anchor" href="#vlookup函数"></a> VLOOKUP函数</h3><p>VLOOKUP函数是Excel中非常常用的函数之一，用于在表格或区域中按行查找数据。它的基本语法如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VLOOKUP</span>(lookup_value, table_array, col_index_num, [range_lookup])</span><br></pre></td></tr></table></figure><p>各参数的含义如下：</p><ol><li><strong>lookup_value</strong>：要查找的值。</li><li><strong>table_array</strong>：包含数据的表格区域。</li><li><strong>col_index_num</strong>：返回值在表格区域中的列号。</li><li><strong>range_lookup</strong>：可选参数，指定查找方式。TRUE（或省略）表示近似匹配，FALSE（或0）表示精确匹配。</li></ol><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p>假设有以下数据表格：</p><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>25</td></tr><tr><td>2</td><td>李四</td><td>30</td></tr><tr><td>3</td><td>王五</td><td>28</td></tr></tbody></table><p>如果我们想根据编号查找对应的姓名，可以使用以下公式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">VLOOKUP</span>(<span class="number">2</span>; sheet2！<span class="symbol">A2</span>:<span class="symbol">C4</span>; <span class="number">2</span>; <span class="built_in">FALSE</span>)</span><br></pre></td></tr></table></figure><p>这个公式的含义是：</p><ul><li>查找值为2（编号为2的行）。</li><li>在A2:C4区域中查找。</li><li>返回第2列的值（即姓名）。</li><li>使用精确匹配（FALSE）。</li></ul><p>因此，结果将返回“李四”。</p><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><ol><li><strong>table_array</strong>的第一列必须包含要查找的值（lookup_value）。</li><li><strong>col_index_num</strong>必须大于0且小于等于table_array的总列数。</li><li>使用精确匹配时，确保lookup_value在table_array的第一列中存在，否则会返回错误。</li></ol><p>VLOOKUP函数在处理大量数据时非常有用，但也有一些局限性，例如无法从右向左查找。在这种情况下，可以考虑使用INDEX和MATCH函数的组合来实现更灵活的查找。</p><h3 id="if函数"><a class="markdownIt-Anchor" href="#if函数"></a> IF函数</h3><p>IF函数是Excel中非常基础且常用的逻辑函数，用于根据指定的条件返回不同的结果。它的基本语法如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IF</span>(logical_test; [value_if_true]; [value_if_false])</span><br></pre></td></tr></table></figure><p>各参数的含义如下：</p><ol><li><strong>logical_test</strong>：要进行测试的逻辑表达式，结果为TRUE或FALSE。</li><li><strong>value_if_true</strong>：如果logical_test为TRUE，则返回的值。</li><li><strong>value_if_false</strong>：如果logical_test为FALSE，则返回的值。</li></ol><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><p>假设有以下数据表格：</p><table><thead><tr><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>张三</td><td>85</td></tr><tr><td>李四</td><td>72</td></tr><tr><td>王五</td><td>90</td></tr></tbody></table><p>如果我们想根据分数判断学生是否及格（假设及格分数为60），可以使用以下公式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">IF</span>(<span class="symbol">B2</span>&gt;=<span class="number">60</span>; <span class="string">&quot;及格&quot;</span>; <span class="string">&quot;不及格&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个公式的含义是：</p><ul><li>测试B2单元格的值是否大于或等于60。</li><li>如果是，返回“及格”。</li><li>如果不是，返回“不及格”。</li></ul><p>因此，对于张三（分数为85），结果将返回“及格”。</p><h4 id="嵌套if函数"><a class="markdownIt-Anchor" href="#嵌套if函数"></a> 嵌套IF函数</h4><p>IF函数还可以嵌套使用，以处理更复杂的逻辑判断。例如，如果我们想根据分数划分等级（优秀、良好、及格、不及格），可以使用以下公式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">IF</span>(<span class="symbol">B2</span>&gt;=<span class="number">90</span>; <span class="string">&quot;优秀&quot;</span>; <span class="built_in">IF</span>(<span class="symbol">B2</span>&gt;=<span class="number">80</span>; <span class="string">&quot;良好&quot;</span>; <span class="built_in">IF</span>(<span class="symbol">B2</span>&gt;=<span class="number">60</span>; <span class="string">&quot;及格&quot;</span>; <span class="string">&quot;不及格&quot;</span>)))</span><br></pre></td></tr></table></figure><p>这个公式的含义是：</p><ul><li>如果B2单元格的值大于或等于90，返回“优秀”。</li><li>否则，如果B2单元格的值大于或等于80，返回“良好”。</li><li>否则，如果B2单元格的值大于或等于60，返回“及格”。</li><li>否则，返回“不及格”。</li></ul><h4 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h4><ol><li><strong>logical_test</strong>必须是一个可以计算为TRUE或FALSE的表达式。</li><li><strong>value_if_true</strong>和<strong>value_if_false</strong>可以是文本、数字、其他公式或函数的结果。</li><li>嵌套IF函数时，确保逻辑清晰且完整，避免出现逻辑错误。</li></ol><p>IF函数在处理简单的条件判断时非常方便，但在处理复杂逻辑时，可能需要结合其他函数（如AND、OR、NOT等）来实现更复杂的逻辑判断。</p><blockquote><p>通过巧妙地结合这些函数，我们能够实现更为复杂且精准的逻辑判断。<br />完成这一系列逻辑判断后，只需轻轻回车，即可得到我们期望的值。此时，若双击单元格右下角的填充柄，整列便会自动填充上我们期望的结果，从而避免了手动逐个拖动的繁琐操作，大大提升了工作效率。</p></blockquote><h3 id="sumif函数"><a class="markdownIt-Anchor" href="#sumif函数"></a> SumIF函数</h3><p>在Excel中，SumIF函数是一个非常实用的工具，它能够根据指定的条件对数据进行求和。这个函数在处理大量数据时尤为高效，能够帮助我们快速筛选并汇总符合特定条件的数据。</p><h4 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h4><p>SumIF函数的基本语法如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">SUMIF</span>(range; criteria; [sum_range])</span><br></pre></td></tr></table></figure><ul><li><strong>range</strong>：需要进行条件判断的单元格区域。</li><li><strong>criteria</strong>：用于筛选的条件，可以是数字、文本、表达式或单元格引用。</li><li><strong>[sum_range]</strong>：实际需要求和的单元格区域。如果省略此参数，则默认对range区域中符合条件的单元格进行求和。</li></ul><h4 id="应用示例"><a class="markdownIt-Anchor" href="#应用示例"></a> 应用示例</h4><p>假设我们有一个销售数据表，其中A列是产品名称，B列是销售数量。我们希望统计“苹果”产品的总销售数量，可以使用以下公式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">SUMIF</span>(<span class="symbol">A:A</span>; <span class="string">&quot;苹果&quot;</span>; <span class="symbol">B:B</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，A列是range，&quot;苹果&quot;是criteria，B列是sum_range。函数会筛选出A列中所有名为“苹果”的单元格，并对对应的B列单元格进行求和。</p><h4 id="进阶技巧"><a class="markdownIt-Anchor" href="#进阶技巧"></a> 进阶技巧</h4><ol><li><strong>使用通配符</strong>：在criteria中可以使用通配符，如<code>*</code>和<code>?</code>。例如，<code>=SUMIF(A:A; &quot;苹果*&quot;; B:B)</code>可以统计所有以“苹果”开头的产品销售数量。</li><li><strong>引用单元格作为条件</strong>：可以将criteria设置为单元格引用，如<code>=SUMIF(A:A; D1; B:B)</code>，其中D1单元格中存放着需要筛选的产品名称。</li><li><strong>多条件求和</strong>：如果需要进行多条件求和，可以考虑使用SumIFS函数，它支持多个条件同时进行筛选和求和。</li></ol><h3 id="sumifs函数"><a class="markdownIt-Anchor" href="#sumifs函数"></a> SumIFS函数</h3><p>在Excel中，SumIFS函数是一个强大的工具，它允许用户根据多个条件对数据进行求和。与SumIF函数相比，SumIFS函数能够处理更为复杂的筛选需求，使得数据分析和汇总变得更加灵活和精确。</p><h4 id="基本语法-2"><a class="markdownIt-Anchor" href="#基本语法-2"></a> 基本语法</h4><p>SumIFS函数的基本语法如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">SUMIFS</span>(sum_range; criteria_range1; criteria1; [criteria_range2;  criteria2]; ...)</span><br></pre></td></tr></table></figure><ul><li><strong>sum_range</strong>：实际需要求和的单元格区域。</li><li><strong>criteria_range1</strong>：第一个条件判断的单元格区域。</li><li><strong>criteria1</strong>：第一个用于筛选的条件。</li><li><strong>[criteria_range2, criteria2]</strong>：可选参数，用于添加更多的条件判断区域和条件。</li></ul><h4 id="应用示例-2"><a class="markdownIt-Anchor" href="#应用示例-2"></a> 应用示例</h4><p>假设我们有一个销售数据表，其中A列是产品名称，B列是销售数量，C列是销售地区。我们希望统计“苹果”产品在“北京”地区的总销售数量，可以使用以下公式：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">SUMIFS</span>(<span class="symbol">B:B</span>; <span class="symbol">A:A</span>; <span class="string">&quot;苹果&quot;</span>; <span class="symbol">C:C</span>; <span class="string">&quot;北京&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，B列是sum_range，A列是第一个criteria_range，&quot;苹果&quot;是第一个criteria，C列是第二个criteria_range，&quot;北京&quot;是第二个criteria。函数会筛选出A列中所有名为“苹果”且C列中地区为“北京”的单元格，并对对应的B列单元格进行求和。</p><h4 id="进阶技巧-2"><a class="markdownIt-Anchor" href="#进阶技巧-2"></a> 进阶技巧</h4><ol><li><strong>使用通配符</strong>：在criteria中可以使用通配符，如<code>*</code>和<code>?</code>。例如，<code>=SUMIFS(B:B; A:A; &quot;苹果*&quot;; C:C; &quot;北京&quot;)</code>可以统计所有以“苹果”开头的产品在“北京”地区的销售数量。</li><li><strong>引用单元格作为条件</strong>：可以将criteria设置为单元格引用，如<code>=SUMIFS(B:B; A:A; D1; C:C; E1)</code>，其中D1单元格中存放着需要筛选的产品名称，E1单元格中存放着需要筛选的地区。</li><li><strong>日期和数值条件</strong>：SumIFS函数也支持日期和数值条件。例如，<code>=SUMIFS(B:B; A:A; &quot;苹果&quot;; C:C, &quot;北京&quot;; D:D; &quot;&gt;2023-01-01&quot;)</code>可以统计“苹果”产品在“北京”地区且销售日期在2023年1月1日之后的销售数量。</li></ol><h3 id="同比和环比"><a class="markdownIt-Anchor" href="#同比和环比"></a> 同比和环比</h3><p>下面，让我们了解一下常用的数据比较方法：同比和环比，这两者主要用于分析时间序列数据的变化情况。它们在经济分析、市场研究、财务报告等领域有着广泛的应用。</p><h4 id="同比year-on-year"><a class="markdownIt-Anchor" href="#同比year-on-year"></a> 同比（Year-on-Year）</h4><p>同比是指将某一时期的数据与上一年同一时期的数据进行比较。这种比较方法主要用于观察长期趋势和季节性因素的影响。</p><p><strong>同比公式：同比增减率 = (本期数值 - 同期数值) / 同期数值 * 100%</strong></p><p>例如，如果2023年第二季度的销售额为100万元，而2022年第二季度的销售额为80万元，那么同比增减率为：<strong>同比增减率 = (100 - 80) / 80 * 100% = 25%</strong></p><p>这意味着2023年第二季度的销售额比2022年第二季度增长了25%。</p><h4 id="环比month-on-month或-quarter-on-quarter"><a class="markdownIt-Anchor" href="#环比month-on-month或-quarter-on-quarter"></a> 环比（Month-on-Month或 Quarter-on-Quarter）</h4><p>环比是指将某一时期的数据与上一个相邻时期的数据进行比较。这种比较方法主要用于观察短期内的变化趋势，尤其是季节性因素和市场波动的影响。<br /><strong>环比公式：环比增减率 = (本期数值 - 上期数值) / 上期数值 * 100%</strong></p><p>例如，如果2023年第二季度的销售额为100万元，而2023年第一季度的销售额为90万元，那么环比增减率为：<strong>环比增减率 = (100 - 90) / 90 * 100% = 11.11%</strong><br />这意味着2023年第二季度的销售额比2023年第一季度增长了11.11%。</p><ul><li><strong>同比</strong>：比较同一时期不同年份的数据，用于观察长期趋势和季节性因素。</li><li><strong>环比</strong>：比较相邻时期的数据，用于观察短期内的变化趋势和市场波动。</li></ul><h3 id="数据验证"><a class="markdownIt-Anchor" href="#数据验证"></a> 数据验证</h3><p>在Excel中，数据验证是一项强大的功能，它允许用户设定特定的规则来限制输入到单元格中的数据类型和范围。这不仅有助于确保数据的准确性和一致性，还能提升工作表的整体质量。以下是一些关于Excel数据验证功能的详细介绍和使用技巧（在业务中常用作切片器功能）：</p><h4 id="1-设置数据验证规则"><a class="markdownIt-Anchor" href="#1-设置数据验证规则"></a> 1. 设置数据验证规则</h4><ul><li><strong>数据类型限制</strong>：我们可以选择允许输入的数据类型，如整数、小数、日期、时间等。</li><li><strong>范围限制</strong>：通过设定最小值和最大值，可以限制输入的数据必须在某个特定范围内。</li><li><strong>列表限制</strong>：创建一个下拉列表，用户只能从预定义的选项中选择。</li><li><strong>自定义公式</strong>：使用公式来定义更复杂的验证规则，如确保输入的数据符合特定的业务逻辑。</li></ul><h4 id="2-数据验证的提示信息"><a class="markdownIt-Anchor" href="#2-数据验证的提示信息"></a> 2. 数据验证的提示信息</h4><ul><li><strong>输入提示</strong>：当用户选择一个设置了数据验证的单元格时，可以显示输入提示信息，帮助用户理解应该输入什么样的数据。</li><li><strong>错误警告</strong>：如果用户输入的数据不符合设定的规则，可以显示错误警告信息，并提供重试、取消或帮助选项。</li></ul><h4 id="3-数据验证的高级应用"><a class="markdownIt-Anchor" href="#3-数据验证的高级应用"></a> 3. 数据验证的高级应用</h4><ul><li><strong>跨单元格验证</strong>：可以设置规则来验证多个单元格之间的关系，例如确保一个单元格的值总是大于另一个单元格的值。</li><li><strong>动态数据验证</strong>：结合公式和函数，可以使数据验证规则根据其他单元格的内容动态变化。</li></ul><h4 id="4-数据验证的维护和更新"><a class="markdownIt-Anchor" href="#4-数据验证的维护和更新"></a> 4. 数据验证的维护和更新</h4><ul><li><strong>复制数据验证</strong>：可以通过复制和粘贴的方式，将数据验证规则应用到其他单元格或工作表中。</li><li><strong>更新验证规则</strong>：当业务需求变化时，可以方便地更新数据验证规则，以适应新的数据要求。</li></ul><h3 id="迷你图"><a class="markdownIt-Anchor" href="#迷你图"></a> 迷你图</h3><p>迷你图（Sparklines）是Excel中一种简洁而强大的数据可视化工具，它能够在单个单元格内展示数据的趋势和波动，非常适合用于展示时间序列数据或对比分析。以下是对Excel迷你图功能的详细介绍和使用技巧：</p><h4 id="1-迷你图的类型"><a class="markdownIt-Anchor" href="#1-迷你图的类型"></a> 1. 迷你图的类型</h4><ul><li><strong>折线图</strong>：展示数据随时间的变化趋势，适用于时间序列数据。</li><li><strong>柱形图</strong>：通过柱子的高低来展示数据的对比，适用于比较不同类别的数据。</li><li><strong>盈亏图</strong>：通过不同的颜色来区分正负值，适用于展示盈亏或正负变化。</li></ul><h4 id="2-创建迷你图"><a class="markdownIt-Anchor" href="#2-创建迷你图"></a> 2. 创建迷你图</h4><ul><li><strong>选择数据</strong>：首先，选择我们要创建迷你图的数据范围。</li><li><strong>插入迷你图</strong>：在“插入”选项卡中，点击“迷你图”组中的相应图表类型（折线图、柱形图或盈亏图）。</li><li><strong>设置位置</strong>：在弹出的对话框中，指定迷你图的位置范围，即我们希望迷你图显示的单元格。</li><li><strong>确认创建</strong>：点击“确定”，迷你图就会出现在指定的单元格中。</li></ul><h4 id="3-迷你图的格式设置"><a class="markdownIt-Anchor" href="#3-迷你图的格式设置"></a> 3. 迷你图的格式设置</h4><ul><li><strong>样式调整</strong>：通过“设计”选项卡中的样式库，可以快速更改迷你图的颜色和样式。</li><li><strong>标记设置</strong>：可以添加高点、低点、首点、末点等标记，以突出显示数据中的关键点。</li><li><strong>轴线设置</strong>：对于折线图，可以显示或隐藏轴线，以更好地展示数据趋势。</li></ul><h4 id="4-迷你图的高级应用"><a class="markdownIt-Anchor" href="#4-迷你图的高级应用"></a> 4. 迷你图的高级应用</h4><ul><li><strong>动态迷你图</strong>：结合数据验证和条件格式，可以创建动态更新的迷你图，实时反映数据变化。</li><li><strong>组合迷你图</strong>：在同一单元格内组合不同类型的迷你图，以展示更丰富的数据信息。</li></ul><h4 id="5-迷你图的维护和更新"><a class="markdownIt-Anchor" href="#5-迷你图的维护和更新"></a> 5. 迷你图的维护和更新</h4><ul><li><strong>更新数据</strong>：当源数据发生变化时，迷你图会自动更新，保持数据的实时性。</li><li><strong>复制迷你图</strong>：可以通过复制和粘贴的方式，将迷你图应用到其他单元格或工作表中。</li></ul><p>通过合理使用Excel的迷你图功能，可以在有限的单元格空间内直观地展示数据趋势和对比，提升数据分析的效率和效果。无论是制作报告、仪表盘还是进行日常的数据监控，迷你图都是一种非常实用的工具。</p><h3 id="条件格式"><a class="markdownIt-Anchor" href="#条件格式"></a> 条件格式</h3><p>条件格式是Excel中一项强大的数据可视化工具，它允许用户根据特定的条件自动格式化单元格，从而使数据分析更加直观和高效。以下是对Excel条件格式功能的详细介绍和使用技巧，包括数据条和突出显示单元格规则的应用。</p><h4 id="1-数据条的应用"><a class="markdownIt-Anchor" href="#1-数据条的应用"></a> 1. 数据条的应用</h4><ul><li><strong>业务进度百分比显示</strong>：通过数据条，可以在单元格内直观地展示业务进度的百分比。数据条的长度与百分比数据成正比，使得进度一目了然。</li><li><strong>设置数据条</strong>：选择包含百分比数据的单元格范围，然后在“开始”选项卡中点击“条件格式”，选择“数据条”并选择合适的样式。</li><li><strong>高级设置</strong>：在“条件格式规则管理器”中，可以设置数据条的最小值和最大值，以及负值的显示方式，确保数据条的准确性和美观性。</li></ul><h4 id="2-突出显示单元格规则"><a class="markdownIt-Anchor" href="#2-突出显示单元格规则"></a> 2. 突出显示单元格规则</h4><ul><li><strong>特定值的突出显示</strong>：可以设置规则，使得包含特定值（如关键绩效指标、异常值等）的单元格自动以不同的颜色或格式突出显示。</li><li><strong>条件设置</strong>：在“开始”选项卡中点击“条件格式”，选择“突出显示单元格规则”，然后选择“等于”、“大于”、“小于”等条件，并设置相应的格式。</li><li><strong>自定义规则</strong>：可以使用公式创建自定义的突出显示规则，以满足更复杂的格式化需求。</li></ul><h4 id="3-条件格式的高级应用"><a class="markdownIt-Anchor" href="#3-条件格式的高级应用"></a> 3. 条件格式的高级应用</h4><ul><li><strong>数据条与突出显示规则的结合</strong>：可以在同一数据范围内同时应用数据条和突出显示规则，以提供更丰富的数据可视化效果。</li><li><strong>动态更新</strong>：当数据发生变化时，条件格式会自动更新，保持数据的实时性和准确性。</li><li><strong>复制和应用规则</strong>：可以通过复制条件格式规则，将相同的格式化效果应用到其他单元格或工作表中。</li></ul><h4 id="4-条件格式的维护和更新"><a class="markdownIt-Anchor" href="#4-条件格式的维护和更新"></a> 4. 条件格式的维护和更新</h4><ul><li><strong>管理规则</strong>：在“条件格式规则管理器”中，可以查看、编辑和删除已设置的条件格式规则。</li><li><strong>优先级调整</strong>：可以调整规则的优先级，确保重要的规则优先执行。</li></ul><p>通过合理使用Excel的条件格式功能，可以在单元格内直观地展示业务进度百分比，并突出显示关键数据，提升数据的可读性和分析效率。无论是进行日常的业务监控，还是制作专业的报告和仪表盘，条件格式都是一种非常实用的工具。</p><h2 id="excel自动化宏与vba"><a class="markdownIt-Anchor" href="#excel自动化宏与vba"></a> excel自动化：宏与VBA</h2><h3 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h3><p><strong>宏</strong> 是一组预先录制的命令和操作，目的是自动化重复性任务，从而节省时间并减少人为错误。在Excel中，宏通过录制或编写VBA（Visual Basic for Applications）代码实现。以下是关于宏操作的详细介绍：</p><h4 id="1-录制宏"><a class="markdownIt-Anchor" href="#1-录制宏"></a> 1. 录制宏</h4><p>录制宏是创建宏的一种简单方法，无需编写任何代码。通过录制宏，你可以自动执行一系列手动操作。以下是录制宏的步骤：</p><ol><li><strong>打开宏录制工具</strong><ul><li>在Excel中，转到“开发工具”选项卡。如果“开发工具”选项卡未显示，可以通过“文件”-&gt;“选项”-&gt;“自定义功能区”来启用。</li><li>点击“录制宏”按钮。</li></ul></li><li><strong>设置宏参数</strong><ul><li>弹出对话框中，输入宏的名称（必须以字母开头，不得包含空格）。</li><li>选择宏的存储位置，可以选择存储在当前工作簿、新工作簿或个人宏工作簿中。</li><li>输入描述，便于将来识别宏的用途。</li></ul></li><li><strong>执行操作</strong><ul><li>录制开始后，所有的操作都会被记录下来。可以执行希望自动化的步骤，如格式化单元格、输入数据、创建图表等。</li><li>完成所有操作后，点击“停止录制”按钮。</li></ul></li><li><strong>运行宏</strong><ul><li>可以通过“开发工具”选项卡中的“宏”按钮来查看和运行录制的宏。</li></ul></li></ol><h4 id="2-编辑宏"><a class="markdownIt-Anchor" href="#2-编辑宏"></a> 2. 编辑宏</h4><p>录制的宏生成的VBA代码可以在VBA编辑器中进行编辑和修改。以下是编辑宏的步骤：</p><ol><li><strong>打开VBA编辑器</strong><ul><li>在“开发工具”选项卡中，点击“Visual Basic”按钮，打开VBA编辑器。</li></ul></li><li><strong>查找录制的宏</strong><ul><li>在项目资源管理器中，找到包含宏的模块，双击模块名称打开代码窗口。</li></ul></li><li><strong>编辑VBA代码</strong><ul><li>可以直接在代码窗口中修改录制的VBA代码。例如，修改单元格格式、添加新的操作等。</li></ul></li></ol><h3 id="vba"><a class="markdownIt-Anchor" href="#vba"></a> VBA</h3><p><strong>VBA（Visual Basic for Applications）</strong> 是一种事件驱动的编程语言，用于编写宏和自动化任务。VBA提供了比录制宏更强大的功能，可以实现复杂的自动化和定制化操作。以下是使用VBA的一些基本知识和工具：</p><h4 id="1-打开vba编辑器"><a class="markdownIt-Anchor" href="#1-打开vba编辑器"></a> 1. 打开VBA编辑器</h4><ul><li>在Excel中，转到“开发工具”选项卡，点击“Visual Basic”按钮，打开VBA编辑器。</li></ul><h4 id="2-vba编辑器界面"><a class="markdownIt-Anchor" href="#2-vba编辑器界面"></a> 2. VBA编辑器界面</h4><p>VBA编辑器由以下几个部分组成：</p><ul><li><strong>项目资源管理器</strong>：显示所有打开的工作簿及其包含的工作表、模块等。</li><li><strong>属性窗口</strong>：显示所选对象的属性。</li><li><strong>代码窗口</strong>：编写和编辑VBA代码的地方。</li></ul><h4 id="3-创建模块"><a class="markdownIt-Anchor" href="#3-创建模块"></a> 3. 创建模块</h4><p>模块是存放VBA代码的地方。以下是创建模块的步骤：</p><ol><li>在项目资源管理器中，右键单击工作簿名称。</li><li>选择“插入”-&gt;“模块”，创建一个新的代码模块。</li></ol><h4 id="4-编写vba代码"><a class="markdownIt-Anchor" href="#4-编写vba代码"></a> 4. 编写VBA代码</h4><p>在模块中编写VBA代码。例如，创建一个简单的宏来显示消息框：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub ShowMessage()</span><br><span class="line">    MsgBox &quot;Hello, Excel VBA!&quot;</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><h4 id="5-运行vba代码"><a class="markdownIt-Anchor" href="#5-运行vba代码"></a> 5. 运行VBA代码</h4><p>在VBA编辑器中，点击“运行”按钮（绿色三角形）或按下F5键来运行代码。</p><h4 id="6-调试vba代码"><a class="markdownIt-Anchor" href="#6-调试vba代码"></a> 6. 调试VBA代码</h4><p>调试是发现和修正错误的重要步骤。VBA编辑器提供了多种调试工具：</p><ul><li><strong>断点</strong>：按F9键设置断点，在代码执行到断点时暂停。</li><li><strong>单步执行</strong>：按F8键逐行执行代码，便于观察每一步的执行情况。</li><li><strong>立即窗口</strong>：可以在代码运行时输入命令，查看变量值或执行VBA语句。</li></ul><h4 id="7-示例宏与vba代码"><a class="markdownIt-Anchor" href="#7-示例宏与vba代码"></a> 7. 示例宏与VBA代码</h4><p>以下是一些常用的宏和VBA代码示例：</p><ol><li><strong>自动化格式化</strong><ul><li>录制一个宏，将选定单元格的字体设置为粗体，颜色设置为红色。</li></ul></li><li><strong>批量处理数据</strong><ul><li>编写VBA代码，将工作表中A列中的所有空单元格填充为“NA”：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sub FillEmptyCells()</span><br><span class="line">    Dim cell As Range</span><br><span class="line">    For Each cell In Range(&quot;A1:A100&quot;)</span><br><span class="line">        If IsEmpty(cell) Then</span><br><span class="line">            cell.Value = &quot;NA&quot;</span><br><span class="line">        End If</span><br><span class="line">    Next cell</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>生成报告</strong><ul><li>录制一个宏，将数据表中的数据复制到新的工作表，并插入图表。</li></ul></li></ol><h3 id="末梢"><a class="markdownIt-Anchor" href="#末梢"></a> 末梢</h3><p>通过宏和VBA，Excel用户可以极大地提高工作效率，自动化繁琐的任务。录制宏适用于简单的自动化需求，而VBA则提供了更强大和灵活的功能，适用于复杂的自动化和定制化操作。掌握这些工具，愿我们都胜任数据分析师，找到合适的工作，拿到满意的薪资。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Excel，作为微软公司开发的一款强大电子表格软件，不仅在数据分析、财务计算、项目管理、统计分析等领域发挥着重要作用，还因其丰富的数据处理和计算功能，以及多样化的图表和图形工具，成为高效管理和分析数据的得力助手。&lt;/p&gt;
&lt;p&gt;如下图，是拉姆在系统学习Excel时制作的某店</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析食用指南2-优化与连接</title>
    <link href="https://sherry14love.github.io/2024/06/15/learn/data5/"/>
    <id>https://sherry14love.github.io/2024/06/15/learn/data5/</id>
    <published>2024-06-14T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:16.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化算法"><a class="markdownIt-Anchor" href="#优化算法"></a> 优化算法</h2><p>曾经有一次面试的时候，HR问拉姆优化算法都是有哪些，拉姆很懵，因为拉姆下意识以为这是算法岗的内容，就磕磕绊绊得回答的很糟糕。</p><p>现在了解一下，其实数据分析和数据挖掘中常用的优化算法是有很多的，这些算法可以帮助我们找到最优或近似最优的解决方案。</p><p>以下是一些常见的优化算法及其应用场景：</p><h3 id="梯度下降gradient-descent"><a class="markdownIt-Anchor" href="#梯度下降gradient-descent"></a> 梯度下降（Gradient Descent）</h3><p>梯度下降是一种迭代优化算法，用于最小化一个函数。在机器学习中，它通常用于最小化损失函数，以找到模型的最佳参数。</p><p><strong>应用场景</strong>：线性回归、逻辑回归、神经网络等模型的参数优化。</p><h3 id="随机梯度下降stochastic-gradient-descent-sgd"><a class="markdownIt-Anchor" href="#随机梯度下降stochastic-gradient-descent-sgd"></a> 随机梯度下降（Stochastic Gradient Descent, SGD）</h3><p>随机梯度下降是梯度下降的一种变体，它在每次迭代中使用一个随机样本的梯度来更新参数，这使得算法更快，但可能会导致收敛路径更加震荡。</p><p><strong>应用场景</strong>：大规模数据集的模型训练，如图像识别、自然语言处理等。</p><h3 id="牛顿法newtons-method"><a class="markdownIt-Anchor" href="#牛顿法newtons-method"></a> 牛顿法（Newton’s Method）</h3><p>牛顿法是一种二阶优化算法，它使用目标函数的二阶导数（海森矩阵）来寻找最小值。牛顿法通常比梯度下降更快收敛，但计算海森矩阵及其逆矩阵可能非常耗时。</p><p><strong>应用场景</strong>：数据维度较低的优化问题，如支持向量机（SVM）的参数优化。</p><h3 id="拟牛顿法quasi-newton-methods"><a class="markdownIt-Anchor" href="#拟牛顿法quasi-newton-methods"></a> 拟牛顿法（Quasi-Newton Methods）</h3><p>拟牛顿法是一类使用近似海森矩阵来代替精确海森矩阵的优化算法，其中最著名的是BFGS和L-BFGS。这些方法在保持牛顿法快速收敛特性的同时，避免了直接计算海森矩阵。</p><p><strong>应用场景</strong>：中等规模数据集的模型训练，如逻辑回归、神经网络等。</p><h3 id="坐标下降coordinate-descent"><a class="markdownIt-Anchor" href="#坐标下降coordinate-descent"></a> 坐标下降（Coordinate Descent）</h3><p>坐标下降是一种迭代算法，它在每次迭代中只优化一个参数，而保持其他参数不变。这种方法在参数之间相互独立或近似独立时非常有效。</p><p><strong>应用场景</strong>：LASSO回归、弹性网络等正则化模型的参数优化。</p><h3 id="遗传算法genetic-algorithms"><a class="markdownIt-Anchor" href="#遗传算法genetic-algorithms"></a> 遗传算法（Genetic Algorithms）</h3><p>遗传算法是一种模拟自然选择和遗传机制的搜索启发式算法。它通过模拟生物进化过程来寻找问题的最优解。</p><p><strong>应用场景</strong>：复杂的优化问题，如调度问题、旅行商问题（TSP）等。</p><h3 id="粒子群优化particle-swarm-optimization-pso"><a class="markdownIt-Anchor" href="#粒子群优化particle-swarm-optimization-pso"></a> 粒子群优化（Particle Swarm Optimization, PSO）</h3><p>粒子群优化是一种基于群体智能的优化算法，它模拟鸟群或鱼群的社会行为来寻找最优解。</p><p><strong>应用场景</strong>：多目标优化问题，如工程设计、机器人路径规划等。</p><h3 id="模拟退火simulated-annealing"><a class="markdownIt-Anchor" href="#模拟退火simulated-annealing"></a> 模拟退火（Simulated Annealing）</h3><p>模拟退火是一种概率性优化算法，它通过模拟固体退火过程来寻找全局最优解。算法在搜索过程中允许接受劣解，以避免陷入局部最优。</p><p><strong>应用场景</strong>：组合优化问题，如旅行商问题、调度问题等。</p><h3 id="蚁群算法ant-colony-optimization-aco"><a class="markdownIt-Anchor" href="#蚁群算法ant-colony-optimization-aco"></a> 蚁群算法（Ant Colony Optimization, ACO）</h3><p>蚁群算法是一种模拟蚂蚁觅食行为的优化算法，它通过模拟蚂蚁在寻找食物过程中留下的信息素来解决优化问题。</p><p><strong>应用场景</strong>：路径规划、网络路由等优化问题。</p><h3 id="支持向量机support-vector-machines-svm"><a class="markdownIt-Anchor" href="#支持向量机support-vector-machines-svm"></a> 支持向量机（Support Vector Machines, SVM）</h3><p>虽然SVM本身不是一种优化算法，但它使用了一种称为序列最小优化（Sequential Minimal Optimization, SMO）的算法来解决其优化问题。</p><p><strong>应用场景</strong>：分类和回归问题，如文本分类、图像识别等。</p><p>上面算是对优化算法的一个小介绍。</p><h2 id="数据连接"><a class="markdownIt-Anchor" href="#数据连接"></a> 数据连接</h2><p>数据连接（Data Joining 或 Data Merging）是数据分析和处理中的一项核心操作，它将两个或多个数据集合并在一起，以便进行更深入的分析。这个过程通常基于一个或多个共同的键（key），这些键在不同的数据集中对应相同的实体或观测值。</p><p>我们将介绍常见的数据连接类型，并通过Python的pandas库展示如何实现这些连接。</p><h2 id="数据连接类型"><a class="markdownIt-Anchor" href="#数据连接类型"></a> 数据连接类型</h2><h3 id="内连接inner-join"><a class="markdownIt-Anchor" href="#内连接inner-join"></a> 内连接（Inner Join）</h3><p>内连接只保留两个数据集中键值匹配的记录。换句话说，只有当两个数据集中的键值完全匹配时，这些记录才会被包含在结果中。</p><p><strong>示例场景</strong>：假设你有两个数据集，一个包含客户信息（如客户ID、姓名、地址），另一个包含客户的购买记录（如客户ID、购买日期、购买金额）。通过内连接这两个数据集，你可以得到一个包含所有客户购买信息的新数据集，其中只包含那些在两个数据集中都有记录的客户。</p><h3 id="左连接left-join或左外连接left-outer-join"><a class="markdownIt-Anchor" href="#左连接left-join或左外连接left-outer-join"></a> 左连接（Left Join）或左外连接（Left Outer Join）</h3><p>左连接保留左边的数据集中的所有记录，以及右边数据集中与左边数据集键值匹配的记录。如果右边数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。</p><p><strong>示例场景</strong>：在上述客户和购买记录的例子中，使用左连接可以得到一个包含所有客户信息及其购买记录的数据集，即使某些客户没有购买记录。</p><h3 id="右连接right-join或右外连接right-outer-join"><a class="markdownIt-Anchor" href="#右连接right-join或右外连接right-outer-join"></a> 右连接（Right Join）或右外连接（Right Outer Join）</h3><p>右连接保留右边的数据集中的所有记录，以及左边数据集中与右边数据集键值匹配的记录。如果左边数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。</p><p><strong>示例场景</strong>：在客户和购买记录的例子中，使用右连接可以得到一个包含所有购买记录及其对应客户信息的数据集，即使某些购买记录没有对应的客户信息。</p><h3 id="全连接full-join或全外连接full-outer-join"><a class="markdownIt-Anchor" href="#全连接full-join或全外连接full-outer-join"></a> 全连接（Full Join）或全外连接（Full Outer Join）</h3><p>全连接保留两个数据集中的所有记录，无论它们是否在另一个数据集中有匹配的记录。如果一个数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。</p><p><strong>示例场景</strong>：在客户和购买记录的例子中，使用全连接可以得到一个包含所有客户信息和购买记录的数据集，无论它们是否相互匹配。</p><h3 id="交叉连接cross-join或笛卡尔积cartesian-product"><a class="markdownIt-Anchor" href="#交叉连接cross-join或笛卡尔积cartesian-product"></a> 交叉连接（Cross Join）或笛卡尔积（Cartesian Product）</h3><p>交叉连接将两个数据集中的每一行与另一个数据集中的每一行进行配对，生成所有可能的组合。这种连接不依赖于任何键值匹配。</p><p><strong>示例场景</strong>：假设你有两个数据集，一个包含产品列表，另一个包含促销活动。通过交叉连接这两个数据集，你可以得到一个包含所有可能的产品和促销组合的数据集。</p><h3 id="自连接self-join"><a class="markdownIt-Anchor" href="#自连接self-join"></a> 自连接（Self Join）</h3><p>自连接是将数据集与其自身连接的操作，通常用于处理层次结构数据或需要比较数据集中不同记录的情况。</p><p><strong>示例场景</strong>：假设你有一个员工数据集，其中包含员工ID、姓名和经理ID。通过自连接，你可以创建一个包含所有员工及其直接经理信息的数据集。</p><p>在实际操作中，数据连接可以通过多种编程语言和工具来实现，如SQL、Python（使用pandas库）、R等。</p><h2 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> Python实现</h2><p>下面我们将使用Python的pandas库来演示这些连接类型。首先，我们需要创建示例数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第一个数据集：客户信息</span></span><br><span class="line">data1 = &#123;<span class="string">&#x27;CustomerID&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;Address&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;Houston&#x27;</span>, <span class="string">&#x27;Phoenix&#x27;</span>]&#125;</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第二个数据集：购买记录</span></span><br><span class="line">data2 = &#123;<span class="string">&#x27;CustomerID&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">         <span class="string">&#x27;PurchaseDate&#x27;</span>: [<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="string">&#x27;2023-01-03&#x27;</span>, <span class="string">&#x27;2023-01-04&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;Amount&#x27;</span>: [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]&#125;</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;客户信息数据集:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n购买记录数据集:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p>现在，让我们展示如何实现不同类型的连接：</p><h3 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inner_join = pd.merge(df1, df2, on=<span class="string">&#x27;CustomerID&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n内连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inner_join)</span><br></pre></td></tr></table></figure><h3 id="左连接"><a class="markdownIt-Anchor" href="#左连接"></a> 左连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left_join = pd.merge(df1, df2, on=<span class="string">&#x27;CustomerID&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n左连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(left_join)</span><br></pre></td></tr></table></figure><h3 id="右连接"><a class="markdownIt-Anchor" href="#右连接"></a> 右连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">right_join = pd.merge(df1, df2, on=<span class="string">&#x27;CustomerID&#x27;</span>, how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n右连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(right_join)</span><br></pre></td></tr></table></figure><h3 id="全连接"><a class="markdownIt-Anchor" href="#全连接"></a> 全连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">full_join = pd.merge(df1, df2, on=<span class="string">&#x27;CustomerID&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n全连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(full_join)</span><br></pre></td></tr></table></figure><h3 id="交叉连接"><a class="markdownIt-Anchor" href="#交叉连接"></a> 交叉连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cross_join = pd.merge(df1, df2, how=<span class="string">&#x27;cross&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n交叉连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cross_join)</span><br></pre></td></tr></table></figure><h3 id="自连接"><a class="markdownIt-Anchor" href="#自连接"></a> 自连接</h3><p>自连接通常用于同一个数据集内部的不同记录之间的连接。以下是一个简单的自连接示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的员工数据集</span></span><br><span class="line">data3 = &#123;<span class="string">&#x27;EmployeeID&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">         <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;ManagerID&#x27;</span>: [<span class="literal">None</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">df3 = pd.DataFrame(data3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自连接</span></span><br><span class="line">self_join = pd.merge(df3, df3, left_on=<span class="string">&#x27;ManagerID&#x27;</span>, right_on=<span class="string">&#x27;EmployeeID&#x27;</span>, suffixes=(<span class="string">&#x27;_Employee&#x27;</span>, <span class="string">&#x27;_Manager&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n自连接结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(self_join[[<span class="string">&#x27;EmployeeID_Employee&#x27;</span>, <span class="string">&#x27;Name_Employee&#x27;</span>, <span class="string">&#x27;Name_Manager&#x27;</span>]])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优化算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#优化算法&quot;&gt;&lt;/a&gt; 优化算法&lt;/h2&gt;
&lt;p&gt;曾经有一次面试的时候，HR问拉姆优化算法都是有哪些，拉姆很懵，因为拉姆下意识以为这是算法岗的内容，就磕磕绊绊得回答的很糟糕。&lt;/p&gt;</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>回归与分类</title>
    <link href="https://sherry14love.github.io/2024/06/05/learn/data3/"/>
    <id>https://sherry14love.github.io/2024/06/05/learn/data3/</id>
    <published>2024-06-04T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:10.898Z</updated>
    
    <content type="html"><![CDATA[<p>回归（Regression）和分类（Classification）是机器学习中两种常见的监督学习任务，它们在目标和方法上有所不同。</p><h2 id="回归regression"><a class="markdownIt-Anchor" href="#回归regression"></a> 回归（Regression）</h2><p>回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测一个具体的数值，如房价、股票价格、温度等。</p><p><strong>关键特点：</strong></p><ul><li><strong>目标变量</strong>：连续值。</li><li><strong>输出</strong>：一个数值。</li><li><strong>例子</strong>：线性回归、多项式回归、决策树回归、随机森林回归等。</li></ul><p><strong>应用场景</strong>：</p><ul><li>房价预测</li><li>销售预测</li><li>股票价格预测</li></ul><h3 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h3><p>线性回归（Linear Regression）是统计学和机器学习中最基础的预测建模技术之一，它用于建立和估计一个变量（因变量）与一个或多个变量（自变量）之间的线性关系。线性回归假设因变量和自变量之间的关系可以用一条直线（在一维情况下）或一个超平面（在多维情况下）来近似表示。</p><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p><strong>因变量（Dependent Variable）</strong>：我们试图预测的变量，通常表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。<br /><strong>自变量（Independent Variables）</strong>：用于预测因变量的变量，通常表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, \ldots, x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br /><strong>参数（Parameters）</strong>：模型中的系数，用于确定自变量和因变量之间的关系，通常表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>β</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>β</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\beta_0, \beta_1, \ldots, \beta_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是截距，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>β</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\beta_1, \ldots, \beta_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是各自变量的系数。</p><h3 id="模型表示"><a class="markdownIt-Anchor" href="#模型表示"></a> 模型表示</h3><p>在一元线性回归（只有一个自变量）中，模型可以表示为：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y = \beta_0 + \beta_1x + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span><br />在多元线性回归（有多个自变量）中，模型可以表示为：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>β</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y = \beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_nx_n + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span><br />其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是误差项，表示模型未能捕捉到的随机变异。</p><h3 id="参数估计"><a class="markdownIt-Anchor" href="#参数估计"></a> 参数估计</h3><p>线性回归模型的参数通常使用最小二乘法（Least Squares Method）来估计，目的是找到使所有观测值的残差平方和（RSS，Residual Sum of Squares）最小的参数值。数学上，这可以通过求解最小化问题来实现：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><msub><mi>β</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>β</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>β</mi><mi>n</mi></msub></mrow></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><mo stretchy="false">(</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>x</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>β</mi><mi>n</mi></msub><msub><mi>x</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\min_{\beta_0, \beta_1, ..., \beta_n} \sum_{i=1}^{N} (y_i - (\beta_0 + \beta_1x_{i1} + \beta_2x_{i2} + ... + \beta_nx_{in}))^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.3478920000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882159999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="假设"><a class="markdownIt-Anchor" href="#假设"></a> 假设</h3><p>线性回归模型基于几个关键假设：</p><ol><li><strong>线性关系</strong>：因变量和自变量之间的关系是线性的。</li><li><strong>独立性</strong>：观测值之间是相互独立的。</li><li><strong>同方差性</strong>：误差项的方差对于所有观测值都是相同的。</li><li><strong>无自相关</strong>：误差项之间不存在自相关（即序列相关）。</li><li><strong>正态性</strong>：误差项是正态分布的。</li></ol><h3 id="评估指标"><a class="markdownIt-Anchor" href="#评估指标"></a> 评估指标</h3><ul><li><strong>均方误差（MSE）</strong>：衡量预测值和实际值之间差异的平均平方值。</li><li><strong>决定系数（R-squared）</strong>：表示模型解释的数据变异性的比例。</li></ul><h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3><p>线性回归广泛应用于各种领域，包括经济学、金融学、社会科学、物理学等，用于预测和分析变量之间的关系。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li>线性回归对异常值敏感。</li><li>需要满足模型的假设条件。</li><li>在处理非线性关系时，可能需要使用多项式回归或其他非线性模型。</li></ul><p>线性回归虽然简单，但它是理解更复杂模型的基础，并且在许多实际问题中仍然非常有效。</p><h2 id="分类classification"><a class="markdownIt-Anchor" href="#分类classification"></a> 分类（Classification）</h2><p>分类是另一种预测模型，它涉及将数据分到预定义的类别或标签中。分类模型通常用于识别模式，并根据这些模式对数据进行分类。</p><p><strong>关键特点：</strong></p><ul><li><strong>目标变量</strong>：离散值，通常是预定义的类别。</li><li><strong>输出</strong>：一个类别或标签。</li><li><strong>例子</strong>：逻辑回归、决策树分类、支持向量机（SVM）、随机森林分类、神经网络等。</li></ul><p><strong>应用场景</strong>：</p><ul><li>垃圾邮件检测</li><li>图像识别</li><li>信用评分</li></ul><h2 id="主要区别"><a class="markdownIt-Anchor" href="#主要区别"></a> 主要区别</h2><ul><li><strong>目标变量的类型</strong>：回归分析处理连续数值，而分类处理离散的类别。</li><li><strong>输出的性质</strong>：回归输出一个数值，分类输出一个类别。</li><li><strong>损失函数</strong>：回归通常使用均方误差（MSE）等，分类则使用交叉熵损失等。</li></ul><h3 id="逻辑回归"><a class="markdownIt-Anchor" href="#逻辑回归"></a> 逻辑回归</h3><p>逻辑回归（Logistic Regression）是一种广泛使用的统计学习方法，用于解决分类问题。尽管它的名字中包含“回归”，但实际上它主要用于分类任务，特别是二分类问题。逻辑回归通过使用逻辑函数（也称为Sigmoid函数）来估计概率，从而将线性回归的输出转换为0到1之间的概率值，这个概率值可以用来预测样本属于某一类别的概率。</p><h3 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h3><ul><li><strong>因变量（Dependent Variable）</strong>：通常是二元的，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，取值为0或1。</li><li><strong>自变量（Independent Variables）</strong>：用于预测因变量的变量，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, ..., x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li><strong>参数（Parameters）</strong>：模型中的系数，用于确定自变量和因变量之间的关系，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>β</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>β</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\beta_0, \beta_1, ..., \beta_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="模型表示-2"><a class="markdownIt-Anchor" href="#模型表示-2"></a> 模型表示</h3><p>逻辑回归模型可以表示为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mo stretchy="false">(</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>β</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(y=1|X) = \frac{1}{1 + e^{-(\beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_nx_n)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.10877em;vertical-align:-0.78733em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05278em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.78733em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y=1|X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>是给定自变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>时，因变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>取值为1的概率。逻辑函数（Sigmoid函数）定义为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sigma(z) = \frac{1}{1 + e^{-z}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>β</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">z = \beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_nx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><h3 id="参数估计-2"><a class="markdownIt-Anchor" href="#参数估计-2"></a> 参数估计</h3><p>逻辑回归的参数通常使用最大似然估计（Maximum Likelihood Estimation, MLE）来估计。目标是找到最大化观测数据似然函数的参数值。数学上，这可以通过求解优化问题来实现，通常使用梯度下降或其变体（如随机梯度下降、牛顿法等）来找到最优参数。</p><h3 id="假设-2"><a class="markdownIt-Anchor" href="#假设-2"></a> 假设</h3><p>逻辑回归模型基于以下假设：</p><ol><li><strong>线性关系</strong>：自变量和因变量之间的关系可以通过线性组合来近似。</li><li><strong>概率输出</strong>：模型的输出是样本属于正类的概率。</li></ol><h3 id="评估指标-2"><a class="markdownIt-Anchor" href="#评估指标-2"></a> 评估指标</h3><ul><li><strong>准确率（Accuracy）</strong>：正确预测的比例。</li><li><strong>混淆矩阵（Confusion Matrix）</strong>：显示真正例（True Positives）、假正例（False Positives）、真反例（True Negatives）和假反例（False Negatives）的数量。</li><li><strong>精确率（Precision）</strong>：真正例占所有预测为正例的比例。</li><li><strong>召回率（Recall）</strong>：真正例占所有实际正例的比例。</li><li><strong>F1分数（F1 Score）</strong>：精确率和召回率的调和平均。</li></ul><h3 id="应用-2"><a class="markdownIt-Anchor" href="#应用-2"></a> 应用</h3><p>逻辑回归广泛应用于各种领域，包括医学、金融、社会科学等，用于预测和分类任务，如信用评分、疾病诊断、垃圾邮件检测等。</p><h3 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h3><ul><li>逻辑回归对自变量的缩放和异常值敏感。</li><li>它假设数据是线性可分的，这在某些情况下可能不成立。</li><li>逻辑回归不直接提供概率的置信区间。</li></ul><p>逻辑回归是一种强大且易于实现的分类算法，尤其适合于二分类问题，并且在实际应用中非常受欢迎。</p><h2 id="小总结"><a class="markdownIt-Anchor" href="#小总结"></a> 小总结</h2><p>回归和分类是机器学习中的基本任务，它们各自适用于不同类型的问题。选择哪种方法取决于问题的性质和所需解决的具体任务。在实际应用中，这两种方法都有广泛的应用，并且经常需要根据数据的特点和业务需求来选择合适的模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回归（Regression）和分类（Classification）是机器学习中两种常见的监督学习任务，它们在目标和方法上有所不同。&lt;/p&gt;
&lt;h2 id=&quot;回归regression&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#回归regress</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>GPT食用分享</title>
    <link href="https://sherry14love.github.io/2024/06/01/Tool/ChatGPTfree/"/>
    <id>https://sherry14love.github.io/2024/06/01/Tool/ChatGPTfree/</id>
    <published>2024-05-31T16:00:00.000Z</published>
    <updated>2025-05-16T04:31:00.763Z</updated>
    
    <content type="html"><![CDATA[<!-- ## GPT4 > 注意，套壳网站注册的时候，千万别用自己的qq邮箱还有手机号，密码记得随机生成，容易被开盒（亲身吃瓜）### `官网`:> 1. *openAI*⭐⭐⭐（什么实力就不用说了吧）：https://chat.openai.com/> 2. *Claude*⭐⭐⭐（唯一一家在正面上能力比OpenAI强的）：https://claude.ai/> 3. Copilot⭐⭐⭐（最早联网的AI，微软的心头宝）：https://copilot.microsoft.com/> 4. *DeepSeek*（写报告不错，就是敏感词太严格）：https://chat.deepseek.com/> 5. 智谱清言（国内的免费挡NO.1了几乎）：https://chatglm.cn/> 6. Kimi（除了上传文档多之外，逻辑能力有点堪忧）：https://kimi.moonshot.cn/> 7. 通义千问（没细用过，不太清楚）：https://tongyi.aliyun.com/qianwen/> 8. 讯飞星火（没细用过，不太清楚）：https://xinghuo.xfyun.cn/> 9. 文心一言（嗯...3.5一言难尽）：https://yiyan.baidu.com/> 10. 豆包（逻辑能力还可以）：https://www.doubao.com/chat/> 11. 万知AI（恩...一般）：https://www.wanzhi.com/> ~~12. 复仇者联盟AI（整合了国内的所有的AI）~~：https://bot.360.com/> 13. 知乎直答：https://zhida.zhihu.com/### `套壳`: 有删除线的是已失效的**注意，有`国内直连`标志的，如果用手机或者电脑访问不成功，基本上是你所在地区的运营商不支持这个网址，换一个运营商或者借助魔法，就可以访问了(也有概率是挂了)。**1. Poe（每日10次4o）：https://poe.com/2. Coze（现在不推荐了）：https://www.coze.com/3. 慧AI（`国内直连`、每日150次4o）：https://huiai.io/signup/?code=29264. Arena（`国内直连`、免费，拥挤）：https://arena.lmsys.org/5. ChatGate（`国内直连`、所有模型可用但不能上传文件）：https://chatgate.ai/6. ~~ChatData（`国内直连`、免费可用所有模型，不稳定）~~：https://chat.chatdata.online/chat7. *Aicnn*（`国内直连`、联系拉姆）：http://aicnn.cn/loginPage?aff=zypTghoVaW *Aicnn*：http://www.aicnn.cn/oaifree 8. ~~套壳1(不推荐）~~： https://oai.aitopk.com/ 9. ~~套壳2（可用4o）~~： https://share.bpj666.xyz/10. 套壳3（`国内直连`、可体验4）：https://jvip.ccaiai.com/#/chat/100211. 套壳4（免费公共账户-4）：https://share.wendaalpha.net/12. ~~套壳5（可用4o）~~：https://jialeopen.love/chat/#/13. WRTN（免费4，韩国）：https://wrtn.ai/14. Dify（免费Claude）：https://cloud.dify.ai/15. Merlin（`国内直连`、每日4o四次）：https://www.getmerlin.in/zh-CN/chat16. ~~LibreChat（`国内直连`、慈善家，免费）~~：https://get.multibotapp.com/c/new17. OhMyGpt（不推荐）：https://www.ohmygpt.com/18. Free For Ai（`国内直连`、慈善家，Open WebUI）：https://ffa.chat/19. ChandlerAi（`国内直连`、每月四十次）:https://mychandler.bet/20. 套壳6（50次3小时4o）：https://share.sydney-ai.com/ 20. 套壳6（`国内直连`、50次3小时4o）：https://share.tu-zi.com/21. 套壳7（`国内直连`、一日五次4o）：https://gpt4o.so/zh-CN/app22. 套壳8（`国内直连`、模型变少了）：https://chat.sorapi.dev/ 23. 套壳9（`国内直连`、领悟AI，免费4o）：https://www.chatgpt.sh/?inviteCode=ad82400124. ~~morphic（`国内直连`、免费4o、Claude3.5）~~：https://www.morphic.sh/25. julius（`国内直连`、`专攻`数据分析的AI）：https://julius.ai/26. 套壳9（`国内直连`、Claude3.5）：https://www.zaiwen.top/27. hiplotAI（`国内直连`、`专攻`生物信息分析）：https://hiplot.cn/?lang=zh_cn28. ~~VecMul Chat(`国内直连`、可联系拉姆)~~:https://www.vecmul.com?inviteCode=HBFLI9K729. wordware(`国内直连`、目前免费):https://www.wordware.ai/30. SambaVova(Meta-Llama3.1-405B):https://sambanova.ai/31. 套壳10(`国内直连`、目前免费405B、Claude3.5)：https://openai-x.net/32. RawChat公益站点(`国内直连`、Claude3.5)：https://kelaode.ai/33. 套壳11(`国内直连`、4o和Claude3.5万完全免费)：https://aichatru.ru/zh-CN/app34. **Notiamond**(每月100000次免费请求额度)：https://www.notdiamond.ai/35. GizAI(所有模型免费，包括O1):https://app.giz.ai/shared36. Le Chat：https://chat.mistral.ai/chat37. GPT PLUS：https://share.aivvm.com/  --><p>如欲免费平替，可自行搭建或和拉姆联系，不过正常情况下，下面的就足够你用了。</p><h2 id="ai对话"><a class="markdownIt-Anchor" href="#ai对话"></a> AI对话</h2><ol><li><p><em>openAI</em>⭐⭐⭐（AI界老大哥）：<a href="https://chat.openai.com/">https://chat.openai.com/</a></p></li><li><p><em>Claude</em>⭐⭐⭐（代码生产和文笔理解第一）：<a href="https://claude.ai/">https://claude.ai/</a></p></li><li><p><em>gemini</em>⭐⭐⭐（Google的多模态很🐂）:<a href="https://gemini.google.com/app">https://gemini.google.com/app</a></p></li><li><p><em>qwen</em>⭐⭐⭐（<code>国内直连</code>，千问很可以）:<a href="https://chat.qwen.ai/">https://chat.qwen.ai/</a></p></li><li><p><em>DeepSeek</em>（服务器易宕机，建议用平替或者qwen）：<a href="https://chat.deepseek.com/">https://chat.deepseek.com/</a></p></li></ol><p><a href="https://ccnk05wgo092.feishu.cn/wiki/WeGmwNVgLi9SFtkfwnacu6H5nfd?table=tblfZlmGJHoAYrQe&amp;view=vewv6xDDG2">R1平替文档汇总</a></p><ol start="6"><li><p>Grop⭐⭐⭐（马斯克的X）：<a href="https://grok.com/">https://grok.com/</a></p></li><li><p>Copilot⭐⭐⭐（微软）：<a href="https://copilot.microsoft.com/">https://copilot.microsoft.com/</a></p></li><li><p>Mercury Coder（你对<code>速度</code>一无所知）: <a href="https://chat.inceptionlabs.ai/">https://chat.inceptionlabs.ai/</a></p></li></ol><h2 id="ai前端"><a class="markdownIt-Anchor" href="#ai前端"></a> AI前端</h2><ol><li><p>V0：<a href="https://v0.dev/chat">https://v0.dev/chat</a></p></li><li><p>bolt：<a href="https://bolt.new/">https://bolt.new/</a></p></li><li><p>Lovable：<a href="https://lovable.dev/">https://lovable.dev/</a></p></li></ol><h2 id="ai音乐"><a class="markdownIt-Anchor" href="#ai音乐"></a> AI音乐</h2><ol><li><em>suno</em>（唯一真神）：<a href="https://suno.com/">https://suno.com/</a></li></ol><h2 id="ai编程直接搜索即可"><a class="markdownIt-Anchor" href="#ai编程直接搜索即可"></a> AI编程/直接搜索即可</h2><ol><li><p>Cursor</p></li><li><p>Trae</p></li><li><p>VScode</p></li><li><p>Windsurf</p></li><li><p>Firebase studio</p></li></ol><h2 id="ai搜索"><a class="markdownIt-Anchor" href="#ai搜索"></a> AI搜索</h2><ol><li><p>清华的AMiner（<code>国内直连</code>、AI学术搜索平台）：<a href="https://www.aminer.cn/">https://www.aminer.cn/</a></p></li><li><p>秘塔AI（<code>国内直连</code>、全网、学术、文库、播客搜索AI）：<a href="https://metaso.cn/">https://metaso.cn/</a></p></li><li><p>ScholarAI（学术AI）<a href="https://app.scholarai.io/home">https://app.scholarai.io/home</a></p></li><li><p>DevvAI（特色：有GitHub库搜索）：<a href="https://devv.ai/zh/referral?code=driyivdqpn9c">https://devv.ai/zh/referral?code=driyivdqpn9c</a></p></li><li><p>Genspark（在检索某些信息方面个人感觉比秘塔好一点）：<a href="https://www.genspark.ai">https://www.genspark.ai</a></p></li><li><p>Perplexity（AI搜索鼻祖）：<a href="https://www.perplexity.ai/">https://www.perplexity.ai/</a></p></li><li><p>Phind（有IDE支持，还可以）<a href="https://www.phind.com/">https://www.phind.com/</a></p></li><li><p><strong>Copilot</strong>（最早联网的AI，涵盖AI搜索的功能）：<a href="https://copilot.microsoft.com/">https://copilot.microsoft.com/</a></p></li><li><p>百小应（<code>国内直连</code>、百度的）：<a href="https://ying.baichuan-ai.com/chat">https://ying.baichuan-ai.com/chat</a></p></li><li><p>360搜索（<code>国内直连</code>、360）：<a href="https://so.360.com/">https://so.360.com/</a></p></li><li><p>博查AI（<code>国内直连</code>、提供联网搜索、AI搜索、智能体搜索等API服务）：<a href="https://bochaai.com/">https://bochaai.com/</a></p></li><li><p>天工AI（<code>国内直连</code>）：<a href="https://www.tiangong.cn/">https://www.tiangong.cn/</a></p></li><li><p>ThinkAny（<code>国内直连</code>、提供GitHub、twitter、Wikipedia搜索）<a href="https://thinkany.so/zh">https://thinkany.so/zh</a></p></li><li><p>快搜AI（<code>国内直连</code>）：<a href="https://www.kuaisou.com/">https://www.kuaisou.com/</a></p></li><li><p>心流AI（<code>国内直连</code>，阿里巴巴的）:<a href="https://iflow.cn/">https://iflow.cn/</a></p></li><li><p>开搜AI (<code>国内直连</code>):<a href="https://kaisouai.com/?from=wananxz">https://kaisouai.com/?from=wananxz</a></p></li><li><p>纳米搜索(<code>国内直连</code>)：<a href="https://n.cn/">https://n.cn/</a></p></li><li><p>STORM(来自斯坦福):<a href="https://storm.genie.stanford.edu">https://storm.genie.stanford.edu</a></p></li><li><p>HECKAI(<code>国内直连</code>):<a href="https://heck.ai/zh">https://heck.ai/zh</a></p></li></ol><h2 id="ai导航站"><a class="markdownIt-Anchor" href="#ai导航站"></a> <code>AI导航站</code>:</h2><ol><li><p><em>GPT公益导航</em>：<a href="https://dongfang.flowus.cn/">https://dongfang.flowus.cn/</a></p></li><li><p>摸鱼技术网：<a href="https://xn--v4q818bf34b.com/">https://摸鱼儿.com/</a></p></li><li><p>Github统计免费GPT导航网页：<a href="https://github.com/LiLittleCat/awesome-free-chatgpt?tab=readme-ov-file#-chatgpt-%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8">https://github.com/LiLittleCat/awesome-free-chatgpt?tab=readme-ov-file#-chatgpt-镜像列表</a></p></li><li><p>非猪ai导航：<a href="https://feizhuke.com/#term-6606">https://feizhuke.com/#term-6606</a></p></li><li><p>潮点AI导航：<a href="https://aichaodian.com/">https://aichaodian.com/</a></p></li><li><p>公益RawChat：<a href="https://sharedchat.cn/">https://sharedchat.cn/</a></p></li><li><p>AI工具集：<a href="https://ai-bot.cn/">https://ai-bot.cn/</a></p></li></ol><h2 id="ai-排行榜"><a class="markdownIt-Anchor" href="#ai-排行榜"></a> AI 排行榜：</h2><ol><li><p>aider：<a href="https://aider.chat/docs/leaderboards/">https://aider.chat/docs/leaderboards/</a></p></li><li><p>Arena：<a href="https://arena.lmsys.org/">https://arena.lmsys.org/</a></p></li><li><p>全球百大 AI 排行榜:<a href="https://a16z.com/100-gen-ai-apps-3/">https://a16z.com/100-gen-ai-apps-3/</a></p></li><li><p>大模型排行榜：<a href="https://livebench.ai/#/">https://livebench.ai/#/</a></p></li><li><p>AI排行榜：<a href="https://countless.dev/">https://countless.dev/</a></p></li></ol><h2 id="ai使用总结"><a class="markdownIt-Anchor" href="#ai使用总结"></a> AI使用总结：</h2><p>1️⃣ <strong>先随便问，再慢慢细化</strong></p><ul><li>刚开始不用想太多，想到啥问啥（比如&quot;帮我写个方案&quot;）</li><li>如果回答太模糊，就追加问题：“能不能具体说说第2点？”</li><li>如果方向错了，直接说：“撤回！我们重新从XX开始”</li><li>碰到新想法时：“先停一下，我们换个角度想想…”</li></ul><p>2️⃣ <strong>让AI当你的复读机</strong><br />每聊一会儿就让AI帮你总结两份东西：</p><ul><li>📝 <strong>问题清单</strong>：到目前为止我们都讨论了哪些需求？</li><li>🛠️ <strong>答案进度</strong>：现在有哪些已经搞定的方案？</li></ul><p>3️⃣ <strong>让AI反过来问你</strong><br />当需求不清楚时，让AI扮演小白用户提问：<br />“您是要做活动海报还是产品手册？”<br />“需要考虑预算限制吗？”<br />（这样能帮你发现自己没考虑到的细节）</p><p>4️⃣ <strong>货比三家找答案</strong><br />把整理好的需求清单复制到其他AI工具里）<br />对比不同AI给的方案，把好的部分整合到你的答案文档里</p><p>5️⃣ <strong>无限套娃优化</strong><br />重复上面的步骤：<br />提问→总结→对比方案→更新文档→继续提问…<br />直到你看着两份文档说，“完美！”</p><p>💡 小贴士：就像玩你画我猜，先随便比划，再逐步缩小范围，最后用排除法找到完美答案</p><blockquote><p>声明:本文旨在分享个人对各种人工智能工具的使用体验和主观看法,仅供参考。如有不当之处或引起不适,敬请谅解并欢迎与作者联系,拉姆将及时修改或删除相关内容。</p></blockquote><p><em>本文秉持互联网开放共享精神,无任何商业目的。若不慎侵犯了您的权益,烦请及时告知,拉姆将立即采取妥善措施。</em></p><p><em>感谢您的理解与支持。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ## GPT4 

&gt; 注意，套壳网站注册的时候，千万别用自己的qq邮箱还有手机号，密码记得随机生成，容易被开盒（亲身吃瓜）

### `官网`:
&gt; 1. *openAI*⭐⭐⭐（什么实力就不用说了吧）：https://chat.openai.com/

&gt; 2. *</summary>
      
    
    
    
    <category term="Tool" scheme="https://sherry14love.github.io/categories/Tool/"/>
    
    
    <category term="GPT" scheme="https://sherry14love.github.io/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之特征提取-PCA</title>
    <link href="https://sherry14love.github.io/2024/05/31/learn/data4/"/>
    <id>https://sherry14love.github.io/2024/05/31/learn/data4/</id>
    <published>2024-05-30T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:13.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见方法"><a class="markdownIt-Anchor" href="#常见方法"></a> 常见方法</h2><p>在数据分析中，特征提取是一个关键步骤，它涉及从原始数据中提取有意义的特征，以便用于后续的分析和建模。以下是一些常用的特征提取方法：</p><ol><li><p><strong>主成分分析（PCA）</strong>：</p><ul><li>PCA是一种线性降维技术，通过将数据投影到新的正交坐标系中，提取出数据的主要成分。这些主成分是原始特征的线性组合，能够最大程度地保留数据的方差。</li></ul></li><li><p><strong>独立成分分析（ICA）</strong>：</p><ul><li>ICA是一种用于分离混合信号的技术，它假设数据是由独立的非高斯信号源线性混合而成的。ICA的目标是找到这些独立的信号源。</li></ul></li><li><p><strong>线性判别分析（LDA）</strong>：</p><ul><li>LDA是一种监督学习方法，用于在保持类间差异最大化的同时，减少数据的维度。LDA通过找到一个投影方向，使得不同类别的数据点尽可能分开。</li></ul></li><li><p><strong>t-分布随机邻域嵌入（t-SNE）</strong>：</p><ul><li>t-SNE是一种用于高维数据可视化的非线性降维技术。它通过保持数据点之间的相似性关系，将高维数据映射到低维空间。</li></ul></li><li><p><strong>局部线性嵌入（LLE）</strong>：</p><ul><li>LLE是一种非线性降维技术，它通过保持数据点之间的局部线性关系，将高维数据映射到低维空间。LLE假设每个数据点可以由其邻域点的线性组合近似表示。</li></ul></li><li><p><strong>自动编码器（Autoencoders）</strong>：</p><ul><li>自动编码器是一种神经网络模型，用于无监督学习中的特征提取。它通过将输入数据压缩到一个低维编码，然后再解码回原始维度，学习数据的紧凑表示。</li></ul></li><li><p><strong>小波变换（Wavelet Transform）</strong>：</p><ul><li>小波变换是一种信号处理技术，用于将信号分解成不同频率的子信号。它在时间-频率域中提供了一种灵活的分析方法，适用于非平稳信号的特征提取。</li></ul></li><li><p><strong>傅里叶变换（Fourier Transform）</strong>：</p><ul><li>傅里叶变换是一种将信号从时域转换到频域的技术。它可以将信号分解成不同频率的正弦波成分，适用于周期性信号的特征提取。</li></ul></li><li><p><strong>词嵌入（Word Embeddings）</strong>：</p><ul><li>词嵌入是一种自然语言处理技术，用于将单词表示为低维连续向量。常用的词嵌入方法包括Word2Vec、GloVe和FastText等。</li></ul></li><li><p><strong>特征哈希（Feature Hashing）</strong>：</p><ul><li>特征哈希是一种用于处理高维稀疏特征的技术。它通过将特征映射到一个固定大小的哈希空间，减少特征的维度，同时保持特征的多样性。</li></ul></li></ol><p>这些方法各有特点，适用于不同的数据类型和分析任务。在实际应用中，选择合适的特征提取方法需要根据具体的数据和分析目标来决定。</p><h2 id="pca"><a class="markdownIt-Anchor" href="#pca"></a> PCA</h2><p>主成分分析（Principal Component Analysis，简称PCA）是一种统计方法，用于将一组可能相关的变量转换为一组线性不相关的变量，这些新的变量称为主成分。PCA的主要目标是降维，同时尽可能保留原始数据中的变异信息。以下是PCA的详细介绍：</p><h3 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3><p>PCA的基本原理是通过线性变换将原始数据投影到一个新的坐标系中，使得投影后的数据在新的坐标系中的第一个坐标（即第一主成分）具有最大的方差，第二个坐标（即第二主成分）具有次大的方差，依此类推。每个主成分都是原始变量的线性组合，且主成分之间相互正交（即不相关）。</p><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><p>PCA的实施通常包括以下步骤：</p><h4 id="数据标准化"><a class="markdownIt-Anchor" href="#数据标准化"></a> 数据标准化</h4><p>在进行PCA之前，通常需要对数据进行标准化处理，使得每个变量的均值为0，方差为1。这是因为PCA对变量的尺度非常敏感，如果不进行标准化，方差较大的变量将在主成分分析中占据主导地位。</p><h4 id="计算协方差矩阵"><a class="markdownIt-Anchor" href="#计算协方差矩阵"></a> 计算协方差矩阵</h4><p>协方差矩阵反映了变量之间的线性关系。通过计算标准化后数据的协方差矩阵，可以了解变量之间的相关性。</p><h4 id="计算特征值和特征向量"><a class="markdownIt-Anchor" href="#计算特征值和特征向量"></a> 计算特征值和特征向量</h4><p>协方差矩阵的特征值和特征向量是PCA的核心。特征值表示每个主成分所解释的方差大小，特征向量表示每个主成分的方向。特征值越大，对应的主成分解释的方差越大。</p><h4 id="选择主成分"><a class="markdownIt-Anchor" href="#选择主成分"></a> 选择主成分</h4><p>根据特征值的大小，选择保留的主成分数量。通常的做法是保留特征值大于某个阈值的主成分，或者保留累计解释方差达到一定比例的主成分。</p><h4 id="数据投影"><a class="markdownIt-Anchor" href="#数据投影"></a> 数据投影</h4><p>将原始数据投影到所选择的主成分上，得到降维后的数据。</p><h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3><p>PCA广泛应用于数据分析的各个领域，包括但不限于：</p><ul><li><strong>数据降维</strong>：减少数据的维度，去除冗余信息，同时保留主要特征。</li><li><strong>数据可视化</strong>：将高维数据投影到二维或三维空间，便于可视化分析。</li><li><strong>特征提取</strong>：提取数据的主要特征，用于后续的机器学习模型训练。</li><li><strong>噪声过滤</strong>：通过保留主要成分，去除数据中的噪声。</li></ul><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h4><ul><li>计算简单，易于理解和实现。</li><li>能够有效降维，减少数据量，提高计算效率。</li><li>保留了数据的主要结构和变异信息。</li></ul><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h4><ul><li>PCA是一种线性方法，对于非线性数据结构可能效果不佳。</li><li>结果受数据尺度和分布的影响，需要进行标准化处理。</li><li>解释性较差，主成分是原始变量的线性组合，不易于解释其物理或实际意义。</li></ul><h3 id="实现工具"><a class="markdownIt-Anchor" href="#实现工具"></a> 实现工具</h3><p>PCA可以通过多种编程语言和工具实现，如Python中的<code>scikit-learn</code>库、R语言中的<code>prcomp</code>函数等。</p><p>通过PCA，可以在保留数据主要信息的同时，有效地降低数据的维度，从而简化数据分析和模型构建的过程。</p><!-- 主成分分析（Principal Component Analysis，简称PCA）是一种常用的降维技术，主要用于以下几个方面：1. **数据降维**：PCA通过将高维数据投影到低维空间，从而减少数据的维度。这有助于去除数据中的冗余信息，同时保留数据的主要特征。降维后的数据更易于处理和可视化。2. **数据压缩**：通过PCA，可以将高维数据压缩到低维空间，从而减少存储空间和计算资源的消耗。这在处理大规模数据集时尤为重要。3. **去噪**：PCA可以帮助去除数据中的噪声。通过保留主要成分，可以有效地减少噪声对数据分析的影响。4. **数据可视化**：将高维数据降维到二维或三维空间后，可以方便地进行数据可视化。这有助于更好地理解数据的结构和特征。5. **特征提取**：PCA可以用于提取数据的主要特征。通过分析主成分，可以了解数据的主要变化方向，从而更好地理解数据的内在结构。6. **模式识别和分类**：PCA可以用于模式识别和分类任务中，通过降维和特征提取，提高分类算法的性能。7. **数据预处理**：在某些机器学习任务中，PCA可以作为数据预处理的一部分，帮助提高模型的性能和稳定性。 --><p>以下是如何使用<code>scikit-learn</code>进行PCA分析的详细步骤和示例代码：</p><h3 id="安装scikit-learn库"><a class="markdownIt-Anchor" href="#安装scikit-learn库"></a> 安装scikit-learn库</h3><p>如果还没有安装<code>scikit-learn</code>库，可以使用以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn</span><br></pre></td></tr></table></figure><h3 id="导入必要的库"><a class="markdownIt-Anchor" href="#导入必要的库"></a> 导入必要的库</h3><p>在进行PCA分析之前，需要导入<code>scikit-learn</code>库以及其他可能用到的库，如<code>numpy</code>和<code>pandas</code>，还有可视化的matplotlib。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h3 id="加载和准备数据"><a class="markdownIt-Anchor" href="#加载和准备数据"></a> 加载和准备数据</h3><p>假设你已经有一个数据集，可以使用<code>pandas</code>读取数据，并进行必要的数据预处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;your_data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择特征列</span></span><br><span class="line">features = [<span class="string">&#x27;feature1&#x27;</span>, <span class="string">&#x27;feature2&#x27;</span>, <span class="string">&#x27;feature3&#x27;</span>, <span class="string">&#x27;feature4&#x27;</span>]</span><br><span class="line">X = data[features] <span class="comment"># 特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br></pre></td></tr></table></figure><h3 id="进行pca分析"><a class="markdownIt-Anchor" href="#进行pca分析"></a> 进行PCA分析</h3><p>使用<code>scikit-learn</code>的<code>PCA</code>类进行PCA分析。可以指定要保留的主成分数量，或者通过设置解释方差的阈值来确定主成分的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建PCA对象，指定要保留的主成分数量</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者根据解释方差的阈值来确定主成分数量</span></span><br><span class="line"><span class="comment"># pca = PCA(0.95)  # 保留95%的方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合数据并进行转换</span></span><br><span class="line">X_pca = pca.fit_transform(X_scaled)</span><br></pre></td></tr></table></figure><h3 id="解释结果"><a class="markdownIt-Anchor" href="#解释结果"></a> 解释结果</h3><p>可以通过查看PCA对象的属性来解释结果，例如每个主成分解释的方差比例和累计解释方差比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个主成分解释的方差比例</span></span><br><span class="line">explained_variance_ratio = pca.explained_variance_ratio_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Explained Variance Ratio:&quot;</span>, explained_variance_ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 累计解释方差比例</span></span><br><span class="line">cumulative_explained_variance = np.cumsum(explained_variance_ratio)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cumulative Explained Variance:&quot;</span>, cumulative_explained_variance)</span><br></pre></td></tr></table></figure><blockquote><p>解释方差比例：表示每个主成分解释的方差占原始数据总方差的比例，帮助我们了解每个主成分对数据变异性的贡献程度。<br />累计解释方差比例：表示前若干个主成分累计解释的方差占原始数据总方差的比例，帮助我们确定需要多少个主成分才能达到一定的解释方差比例，从而进行有效的降维。</p></blockquote><h3 id="可视化结果"><a class="markdownIt-Anchor" href="#可视化结果"></a> 可视化结果</h3><p>可以使用<code>matplotlib</code>库将降维后的数据进行可视化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化降维后的数据</span></span><br><span class="line">plt.scatter(X_pca[:, <span class="number">0</span>], X_pca[:, <span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal Component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Principal Component 2&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;PCA Visualization&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="特征提取"><a class="markdownIt-Anchor" href="#特征提取"></a> 特征提取</h3><p>在PCA分析之后，我们可以将降维后的数据作为新的特征集，用于后续的机器学习模型或其他分析任务。以下是如何将PCA结果作为特征提取的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将PCA结果转换为DataFrame</span></span><br><span class="line">pca_features = pd.DataFrame(X_pca, columns=[<span class="string">&#x27;PC1&#x27;</span>, <span class="string">&#x27;PC2&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原始标签（如果有）与新的特征集合并</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;label&#x27;</span> <span class="keyword">in</span> data.columns:</span><br><span class="line">    pca_features[<span class="string">&#x27;label&#x27;</span>] = data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新的特征集</span></span><br><span class="line"><span class="built_in">print</span>(pca_features.head())</span><br></pre></td></tr></table></figure><p>通过上述步骤，我们使用<code>scikit-learn</code>库在Python中进行PCA分析，有效降低数据的维度，同时保留数据的主要信息，不仅有助于简化数据结构，还可以将PCA分析的结果作为新的特征集，用于后续的机器学习模型或其他分析任务，从而提高分析的效率和准确性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常见方法&quot;&gt;&lt;/a&gt; 常见方法&lt;/h2&gt;
&lt;p&gt;在数据分析中，特征提取是一个关键步骤，它涉及从原始数据中提取有意义的特征，以便用于后续的分析和建模。以下是一些常用的特征提取方法：&lt;</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>GPT-4o免费分享</title>
    <link href="https://sherry14love.github.io/2024/05/23/Tool/GPT4o/"/>
    <id>https://sherry14love.github.io/2024/05/23/Tool/GPT4o/</id>
    <published>2024-05-22T16:00:00.000Z</published>
    <updated>2024-06-17T12:47:50.103Z</updated>
    
    <content type="html"><![CDATA[<p>注意喔，红色字体可以直接转跳。如果想要免费的ChatGPT4，可以和拉姆联系，拉姆很乐意和小伙伴们进行讨论喔~</p><h2 id="国内可访问的mychandler"><a class="markdownIt-Anchor" href="#国内可访问的mychandler"></a> 国内可访问的mychandler</h2><p><a href="https://mychandler.bet/">mychandler</a>每月免费用户有40次，就是进入的时候很慢很慢，使用魔法也不快（他的CDN肯定有问题）</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/ce0e2643bf94e02164fbba6c147cba4b" alt="mychandler" /></p><h2 id="插件merlin国内可用"><a class="markdownIt-Anchor" href="#插件merlin国内可用"></a> 插件merlin（国内可用）</h2><p><a href="https://www.getmerlin.in/zh-CN/chat">merlin</a>可以在edge中访问，也可以在chrome中，每日102电力，下面是详细价格表：</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/bb2ff479dba6482d4066b238688fcbc3" alt="merlin" /></p><h2 id="coze"><a class="markdownIt-Anchor" href="#coze"></a> Coze</h2><p><a href="https://www.coze.com/">Coze</a>简直是我们的神，每次都是免费的！无论是GPT4还是4o，而且到目前为止，拉姆都不知道他的限制次数或者tokens到底是多少，太伟大了</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/10b01ddb99f4d6bdbd76fa8d0e35dbeb" alt="Coze" /></p><h2 id="you"><a class="markdownIt-Anchor" href="#you"></a> YOU</h2><p><a href="https://you.com/">YOU</a>每日五次访问，使用体验是比较可以的。</p><p><img src="https://www.qiuxs.cn/sharing-tools/img/read/7482489d99d68c7a0aee66978735748d" alt="YOU" /></p><h2 id="poe"><a class="markdownIt-Anchor" href="#poe"></a> Poe</h2><p>拉姆想了想，貌似每次都是这几家可以免费使用，像是<a href="https://arena.lmsys.org/">lmsys.org</a>,<a href="https://poe.com/">poe</a>等，虽然有所限制，但是对于轻度用户还是比较友好的，OpenAI官网其实这次的4o模型也是免费的，但是，这需要等待。</p><blockquote><p>poe如果只用GPT4o可以每日免费10次哦</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意喔，红色字体可以直接转跳。如果想要免费的ChatGPT4，可以和拉姆联系，拉姆很乐意和小伙伴们进行讨论喔~&lt;/p&gt;
&lt;h2 id=&quot;国内可访问的mychandler&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#国内可访问的mychandle</summary>
      
    
    
    
    <category term="Tool" scheme="https://sherry14love.github.io/categories/Tool/"/>
    
    
    <category term="GPT" scheme="https://sherry14love.github.io/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>随机森林与决策树</title>
    <link href="https://sherry14love.github.io/2024/05/20/learn/data2/"/>
    <id>https://sherry14love.github.io/2024/05/20/learn/data2/</id>
    <published>2024-05-19T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:07.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义与基本概念"><a class="markdownIt-Anchor" href="#定义与基本概念"></a> 定义与基本概念</h2><ul><li>决策树: 树形结构的分类或回归模型，通过特征分割进行分类</li><li>随机森林: 集成学习算法，由多个决策树组成</li></ul><h2 id="决策树decision-tree"><a class="markdownIt-Anchor" href="#决策树decision-tree"></a> 决策树（Decision Tree）</h2><p>决策树是一种用于分类和回归问题的基本算法，可以对数据进行分类和预测，主要步骤包括特征选择，决策树生成，剪枝。</p><ol><li><p>特征选择：决策树通过递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类。</p></li><li><p>决策树生成：决策树从根节点开始，每个节点都是基于某个特征的分割条件，最终形成一棵树形结构。</p></li><li><p>剪枝：为了防止过拟合，通常会对生成的树进行剪枝，通过移除预测性能不佳的分支来简化模型。</p></li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, classification_report</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集为训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建决策树分类器</span></span><br><span class="line">model = DecisionTreeClassifier(random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型进行预测</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;准确率: <span class="subst">&#123;accuracy * <span class="number">100</span>&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分类报告</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分类报告:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br></pre></td></tr></table></figure><h2 id="随机森林random-forest"><a class="markdownIt-Anchor" href="#随机森林random-forest"></a> 随机森林（Random Forest）</h2><p>随机森林是一种基于决策树的集成学习算法，由多个决策树构成。其核心思想是“集体智慧”，即多个决策树的平均预测结果通常比单个模型更准确。</p><p>随机森林是一种基于 Bagging 策略的集成学习模型，它能够有效地处理非线性问题，并且擅长处理大量样本和特征。此外，随机森林还注重降低方差。Bagging 方法在训练过程中，各基学习器之间无依赖，可实现并行训练。通过集成多个模型，它可以有效地处理过拟合问题，提高模型的预测准确性和泛化能力。随机森林可用于分类、回归和异常检测任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data <span class="comment"># 特征数据</span></span><br><span class="line">y = iris.target <span class="comment"># 目标标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集为训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机森林模型</span></span><br><span class="line">model = RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特征重要性</span></span><br><span class="line">importances = model.feature_importances_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印特征重要性</span></span><br><span class="line"><span class="keyword">for</span> feature_name, importance <span class="keyword">in</span> <span class="built_in">zip</span>(iris.feature_names, importances):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;feature_name&#125;</span>: <span class="subst">&#123;importance&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型进行预测</span></span><br><span class="line">predictions = model.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印预测结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测结果:&quot;</span>, predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印真实结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;真实结果:&quot;</span>, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = model.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;准确率: <span class="subst">&#123;accuracy * <span class="number">100</span>&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="bootstrap-sampling"><a class="markdownIt-Anchor" href="#bootstrap-sampling"></a> Bootstrap Sampling</h2><p>Bagging（Bootstrap Aggregating）是一种集成学习方法，用于提高机器学习算法的稳定性和准确性。Bagging的核心思想是通过构建多个模型，然后将这些模型的预测结果进行组合，以达到比单个模型更好的预测效果。（这就是随机森林的思想，对不对）</p><p>Bagging的步骤通常为：</p><ol><li><p>自助采样（Bootstrap Sampling）：从原始数据集中随机抽取多个样本，每个样本的大小与原始数据集相同，但允许重复抽取。这意味着每次抽样都会有一些数据点被多次选中，而另一些则可能不被选中。</p></li><li><p>训练模型：使用每个自助采样得到的数据集来训练一个单独的模型。这些模型可以是相同的算法，也可以是不同的算法。</p></li><li><p>预测：对新的数据点进行预测时，每个模型都会给出自己的预测结果。</p></li><li><p>组合预测：将所有模型的预测结果进行组合。对于分类问题，通常采用投票的方式来决定最终的分类结果；对于回归问题，则通常取所有模型预测结果的平均值作为最终的预测值。</p></li></ol><p>Bagging的主要优点是能够减少模型的方差，提高模型的泛化能力。它特别适用于那些高方差的模型（如决策树）</p><p>所以比较著名的一个Bagging算法就是随机森林。</p><h2 id="决策树与随机森林的区别"><a class="markdownIt-Anchor" href="#决策树与随机森林的区别"></a> 决策树与随机森林的区别</h2><p>随机森林（Random Forest）和决策树（Decision Tree）都是流行的机器学习算法，它们在数据分析和预测建模中广泛使用。尽管它们都基于决策树的概念，但它们在结构和应用上有所不同。下面我们来看看随机森林和决策树之间的一些主要区别：</p><ol><li><strong>模型结构</strong>：<ul><li><strong>决策树</strong>：是一个单一的树结构，它通过一系列的决策节点（内部节点）和终端节点（叶子节点）来对数据进行分类或回归。</li><li><strong>随机森林</strong>：是一个集成学习方法，它由多个决策树组成。随机森林通过构建多个树并将它们的预测结果进行组合来提高模型的性能。</li></ul></li><li><strong>预测方式</strong>：<ul><li><strong>决策树</strong>：对新数据进行预测时，从根节点开始，根据特征值沿着树的路径向下移动，直到到达叶子节点，该节点的值即为预测结果。</li><li><strong>随机森林</strong>：对新数据进行预测时，每个决策树都会给出自己的预测结果，然后通过投票（分类问题）或平均（回归问题）的方式来确定最终的预测结果。</li></ul></li><li><strong>过拟合问题</strong>：<ul><li><strong>决策树</strong>：容易过拟合，特别是在树很深的情况下，因为它可以完美地拟合训练数据。</li><li><strong>随机森林</strong>：通过集成多个树，随机森林能够减少过拟合的风险，因为即使单个树可能过拟合，但多个树的组合通常会更加稳定。</li></ul></li><li><strong>特征选择</strong>：<ul><li><strong>决策树</strong>：在每个节点上，决策树会考虑所有可用的特征来选择最佳的分割方式。</li><li><strong>随机森林</strong>：在构建每棵树时，随机森林会在每个节点上随机选择一部分特征来考虑最佳的分割方式，这增加了模型的多样性。</li></ul></li><li><strong>训练时间</strong>：<ul><li><strong>决策树</strong>：通常训练时间较短，因为只需要训练一个模型。</li><li><strong>随机森林</strong>：训练时间较长，因为需要训练多个决策树。</li></ul></li><li><strong>特征重要性</strong>：<ul><li><strong>决策树</strong>：可以提供特征重要性的度量，但通常不如随机森林准确。</li><li><strong>随机森林</strong>：能够提供更准确的特征重要性度量，因为它基于多个树的平均结果。</li></ul></li></ol><p>总的来说，随机森林通过集成多个决策树来提高模型的准确性和鲁棒性，而决策树则是一个更简单、更快速的单模型方法。随机森林通常在处理复杂数据集时表现更好，而决策树则适用于快速原型设计和简单数据集。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义与基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义与基本概念&quot;&gt;&lt;/a&gt; 定义与基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;决策树: 树形结构的分类或回归模型，通过特征分割进行分类&lt;/li&gt;
&lt;li&gt;随机森林: 集成学习算法，</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析与数据挖掘浅谈</title>
    <link href="https://sherry14love.github.io/2024/05/19/learn/data1/"/>
    <id>https://sherry14love.github.io/2024/05/19/learn/data1/</id>
    <published>2024-05-18T16:00:00.000Z</published>
    <updated>2024-09-26T07:27:03.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术栈和工具分析"><a class="markdownIt-Anchor" href="#技术栈和工具分析"></a> 技术栈和工具分析</h2><p>对于python技术栈的我们来说，走数据分析与数据挖掘是一条不错的路。</p><p>虽然也可以走前后端，但是目前的市场份额，Java和PHP仍然是主流，对于大厂而言，正在从Java到Golang过渡，所以python做前后端是有点尴尬的。</p><p>数据分析与数据挖掘常见的技术栈除了python之外，还有R、SQL、Hadoop、Spark、Hive、SPSS、SAS、Weka、Scikit-learn、TensorFlow、Keras等。</p><p>其中拉姆目前所接触的只有python、r、spss、Scikit-learn、TensorFlow、Keras</p><p>比较熟悉的只有python的一些库，Pandas、NumPy就不用说了，Scikit-learn、TensorFlow、Keras则是在机器学习和深度学习里的一点东西（其实也是python的库），大学里开设了相关的专业课与实验课。</p><p>R语言则是最近学习了解的。</p><p>SPSS、SAS、Weka是经典的数据挖掘和统计分析工具，使用起来并不是说很困难，可以尝试进行学习。</p><p>其实除了上面的之外，还有<a href="https://www.spsspro.com/">spsspro</a>、<a href="https://www.finebi.com/">FineBI</a>等，都是要比那种纯粹的工具更好用的。</p><h2 id="数据分析与数据挖掘的联系"><a class="markdownIt-Anchor" href="#数据分析与数据挖掘的联系"></a> 数据分析与数据挖掘的联系</h2><p>数据分析主要是指使用统计学、数学和计算机科学的方法来处理和分析数据，以提取有用的信息和洞察，帮助做出决策。</p><p>数据分析可以包括描述性分析（如计算平均值、中位数、标准差等）、诊断性分析（分析数据变化的原因）、预测性分析（使用历史数据预测未来趋势）和规范性分析（基于预测结果提出行动建议）。</p><p>数据分析通常侧重于已知模式的识别和验证，以及对数据的解释和报告。</p><p>数据挖掘则是一种更深层次的数据分析方法，它侧重于从大量数据中发现未知的、潜在有用的模式和关系。</p><p>数据挖掘通常涉及复杂的算法和技术，如聚类分析、关联规则学习、分类、回归和异常检测等。</p><p>数据挖掘的目的是发现数据中的隐藏模式，这些模式可能对业务决策、市场分析、风险管理等领域有重要价值。</p><p>两者都需要对数据进行预处理，比如清理缺失值、检查异常值、去除噪声什么的。</p><h2 id="食用指南1"><a class="markdownIt-Anchor" href="#食用指南1"></a> 食用指南1</h2><p>1.因为版本等各种因故，导致一些代码在运行的时候会有各种各样的警告，我们可以使用下面的代码进行<strong>忽略警告</strong>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure><p>2.绘图的时候因为字体因故加载不出来中文字体，可以用下面代码：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = False</span><br></pre></td></tr></table></figure><p>3.读取数据：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd <span class="comment">#数据导入 </span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><p>4.数据探索：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.head()) <span class="comment"># 查看数据前几行</span></span><br><span class="line"><span class="built_in">print</span>(data.describe())<span class="comment"># 查看数据统计摘要</span></span><br><span class="line"><span class="built_in">print</span>(data.columns)<span class="comment"># 查看数据列名</span></span><br></pre></td></tr></table></figure><p>5.数据处理的时候难免会遇到缺失值，这个时候我们可以进行之间删除，或者用均值进行填充：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理缺失值</span></span><br><span class="line">data = data.dropna()  <span class="comment"># 删除含有缺失值的行</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">data = data.fillna(data.mean())  <span class="comment"># 用特定值（这里是均值）填充缺失值</span></span><br></pre></td></tr></table></figure><p>6.在数据分析之中，绘图matplotlib是最为常见的一个库，可以绘画各种图像进行数据可视化帮助我们理解：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">data[<span class="string">&#x27;column_name&#x27;</span>].hist()  </span><br><span class="line">plt.show() <span class="comment"># 绘制直方图   </span></span><br><span class="line">plt.scatter(data[<span class="string">&#x27;column_name1&#x27;</span>], data[<span class="string">&#x27;column_name2&#x27;</span>])</span><br><span class="line">plt.show()<span class="comment"># 绘制散点图</span></span><br></pre></td></tr></table></figure><p>7.我们在处理一些数据的时候需要进行<strong>标准化</strong>，为什么呢，因为可以帮助不同的特征具有相似的尺度，提高模型的收敛速度，使特征更符合标准的正态分布，提高模型的准确性和可解释性：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">scaler = StandardScaler()  </span><br><span class="line">scaled_data = scaler.fit_transform(data)<span class="comment"># 数据标准化</span></span><br><span class="line"><span class="comment"># 将标准化后的数据转换为DataFrame</span></span><br><span class="line">scaled_data = pd.DataFrame(scaled_data, columns=data.columns)</span><br></pre></td></tr></table></figure><p>8.进行<strong>特征选择</strong>在数据挖掘和机器学习中是非常必要的，它有助于去除无关或冗余的特征，提升模型性能，并减少计算成本，而且过多的特征可能导致维度灾难，增加模型复杂度，引发过拟合，并增加时间成本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.feature_selection import SelectKBest</span><br><span class="line">from sklearn.feature_selection import chi2</span><br><span class="line"><span class="comment"># 使用卡方检验选择特征选择排名前 10 的特征</span></span><br><span class="line">selector = SelectKBest(score_func=chi2, k=10)</span><br><span class="line">selected_features = selector.fit_transform(data, target)</span><br></pre></td></tr></table></figure><p>9.<strong>建模</strong>更不用说了，是数据挖掘之中必不可少的组成部分：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"><span class="comment"># 线性回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">predictions = model.predict(X_test)</span><br></pre></td></tr></table></figure><p>10.建模之后，还需要对模型进行<strong>评估</strong>，这样可以帮助我们优化模型参数，提高模型性能，选择最佳模型等：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line"><span class="comment"># 计算均方误差</span></span><br><span class="line">mse = mean_squared_error(y_test, predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MSE:&quot;</span>, mse))</span><br></pre></td></tr></table></figure><p>11.<strong>聚类分析</strong>是一种无监督学习方法，通过聚类，我们可以发现数据中相似的群组或簇，更好地理解数据之间的关系，还可以检测出异常值、噪声、离群点等：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.cluster import KMeans</span><br><span class="line"><span class="comment"># KMeans聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=3)</span><br><span class="line">kmeans.fit(data)</span><br><span class="line">labels = kmeans.labels_</span><br></pre></td></tr></table></figure><p>12.分类任务常见的有<strong>随机森林</strong>、<strong>决策树</strong>、<strong>逻辑回归</strong>、<strong>朴素贝叶斯</strong>、<strong>支持向量机</strong>等，我们来简单介绍一下最常见的<strong>SVM</strong>，SVM适用于线性和非线性分类问题，还可以高效处理高维数据集，在多类别分类时具有独特的优势：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.svm import SVC</span><br><span class="line"><span class="comment"># 支持向量机分类</span></span><br><span class="line">svm = SVC()</span><br><span class="line">svm.fit(X_train, y_train)</span><br><span class="line">predictions = svm.predict(X_test)</span><br></pre></td></tr></table></figure><p>这篇博文先写这些，后面有机会再拓展聊一下，下次见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;技术栈和工具分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#技术栈和工具分析&quot;&gt;&lt;/a&gt; 技术栈和工具分析&lt;/h2&gt;
&lt;p&gt;对于python技术栈的我们来说，走数据分析与数据挖掘是一条不错的路。&lt;/p&gt;
&lt;p&gt;虽然也可以走前后端，但</summary>
      
    
    
    
    <category term="learn" scheme="https://sherry14love.github.io/categories/learn/"/>
    
    
    <category term="数据分析" scheme="https://sherry14love.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="卷" scheme="https://sherry14love.github.io/tags/%E5%8D%B7/"/>
    
  </entry>
  
</feed>
