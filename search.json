[{"title":"数据分析之业务拆解和分析","url":"/2024/09/06/learn/business/","content":"\n在当今数据驱动的商业环境中，业务分析已成为企业决策和战略制定的核心。本文将介绍九种常用的业务分析方法，这些方法能帮助分析师和管理者更好地理解复杂的业务问题，并制定有效的解决方案。\n\n## MECE原则：业务拆解的基础\n\n在开始介绍具体的分析方法之前，我们需要了解MECE原则。MECE是\"Mutually Exclusive Collectively Exhaustive\"的缩写，意为\"相互独立，完全穷尽\"。这个原则要求我们在分析问题时，将问题分解为不重叠（相互独立）且无遗漏（完全穷尽）的部分。遵循MECE原则可以帮助我们更系统、全面地分析问题。\n\n## 九种常用业务分析方法\n\n### 流程拆解法\n\n流程拆解法是将复杂的业务流程按时间顺序或逻辑顺序分解为一系列步骤。这种方法特别适用于优化业务流程、识别瓶颈和改进效率。\n\n**应用步骤：**\n1. 确定流程范围\n2. 详细描述每个步骤\n3. 绘制流程图\n4. 识别关键环节\n5. 分析和优化每个步骤\n\n**示例：** 分析电子商务网站的用户购买流程：浏览商品 -> 加入购物车 -> 结算 -> 支付 -> 确认订单\n\n### 二分法\n\n二分法是将问题或数据集分为两个互斥的部分进行分析。这种方法有助于简化复杂问题，快速聚焦关键因素。\n\n**应用示例：**\n- 将客户群分为新客户和老客户\n- 将产品线分为高端产品和大众产品\n- 将市场分为线上渠道和线下渠道\n\n### 象限拆解法\n\n象限拆解法使用两个维度将数据或问题分为四个象限，有助于进行分类分析和优先级排序。\n\n**应用示例：**\n使用\"重要性\"和\"紧急性\"两个维度对任务进行分类：\n- 第一象限：重要且紧急\n- 第二象限：重要但不紧急\n- 第三象限：紧急但不重要\n- 第四象限：既不重要也不紧急\n\n### 杜邦分析法\n\n杜邦分析法是一种财务分析工具，通过分解净资产收益率（ROE）来评估公司的财务状况和经营效率。\n\n**核心公式：**\nROE = 净利润率 × 总资产周转率 × 权益乘数\n\n这种分析方法有助于识别影响公司盈利能力的关键因素。\n\n### AARRR模型（海盗指标）\n\nAARRR模型是一个用户增长框架，包括五个关键阶段：\n\n1. 获取（Acquisition）：如何吸引用户\n2. 激活（Activation）：如何让用户体验产品价值\n3. 留存（Retention）：如何让用户持续使用\n4. 收入（Revenue）：如何从用户获得收入\n5. 推荐（Referral）：如何通过现有用户获得新用户\n\n这个模型帮助企业全面分析和优化用户生命周期。\n\n### PEST分析\n\nPEST分析用于评估宏观环境对企业的影响，包括四个方面：\n\n- 政治（Political）：政府政策、法规等\n- 经济（Economic）：经济增长、通货膨胀等\n- 社会（Social）：人口趋势、文化变迁等\n- 技术（Technological）：技术创新、研发投入等\n\nPEST分析有助于企业识别外部环境的机遇与威胁。\n\n### RFM模型\n\nRFM模型是一种客户价值分析方法，基于三个维度：\n\n- 最近一次购买（Recency）\n- 购买频率（Frequency）\n- 购买金额（Monetary）\n\n通过这三个维度，企业可以对客户进行分类，制定针对性的营销策略。\n\n### SWOT分析\n\nSWOT分析是一种全面评估企业内外部环境的方法：\n\n- 优势（Strengths）：企业的内部优势\n- 劣势（Weaknesses）：企业的内部不足\n- 机会（Opportunities）：外部环境带来的机会\n- 威胁（Threats）：外部环境带来的挑战\n\nSWOT分析有助于企业制定战略，扬长避短。\n\n### 5W1H分析法\n\n5W1H是一种全面分析问题的方法，通过回答六个问题来深入理解问题：\n\n- What（什么）：问题是什么\n- Why（为什么）：为什么会发生\n- Who（谁）：涉及哪些人\n- Where（哪里）：在哪里发生\n- When（何时）：什么时候发生\n- How（如何）：如何解决\n\n这种方法有助于全面、系统地分析和解决问题。\n\n## 重点分析方法\n\n### 工作分解结构（WBS）\n\n工作分解结构（Work Breakdown Structure，WBS）是一种项目管理工具，用于将项目分解成更小、更易管理的部分。WBS不仅是一种流程拆解方法，更是一种系统化的项目规划和控制工具。\n\n**WBS的特点：**\n- 层级结构：从项目总体目标逐级分解到具体工作包\n- 100%原则：下级元素必须完整描述上级元素的所有工作\n- 可交付成果导向：每个工作包都应有明确的可交付成果\n\n**应用步骤：**\n1. 确定项目范围和主要可交付成果\n2. 确定主要工作包\n3. 分解工作包到适当的详细程度\n4. 分配工作包责任\n5. 定义每个工作包的时间、资源和成本估算\n\n**示例：移动应用开发项目的WBS**\n\n1. 移动应用开发项目\n   1.1 **项目启动**\n       1.1.1 需求分析\n       1.1.2 项目章程\n   1.2 **设计阶段**\n       1.2.1 UI/UX设计\n       1.2.2 技术架构设计\n   1.3 **开发阶段**\n       1.3.1 前端开发\n       1.3.2 后端开发\n       1.3.3 数据库开发\n   1.4 **测试阶段**\n       1.4.1 单元测试\n       1.4.2 集成测试\n       1.4.3 用户验收测试\n   1.5 **部署阶段**\n       1.5.1 应用商店提交\n       1.5.2 服务器部署\n   1.6 **项目管理**\n       1.6.1 进度管理\n       1.6.2 风险管理\n       1.6.3 沟通管理\n\n### 泳道流程图\n\n泳道流程图是一种特殊类型的流程图，它通过将流程步骤分配到不同的\"泳道\"中来可视化复杂的业务流程。每个泳道通常代表一个参与者、部门或系统。\n\n**泳道流程图的特点：**\n- 清晰展示不同参与者的职责\n- 易于识别流程中的瓶颈和交接点\n- 有助于优化跨部门或跨系统的流程\n\n**应用步骤：**\n1. 确定流程涉及的所有参与者或部门\n2. 为每个参与者创建一个泳道\n3. 按时间顺序列出流程步骤\n4. 将每个步骤分配到相应的泳道\n5. 用箭头连接步骤，显示流程方向\n6. 标注决策点和条件分支\n\n**示例：电子商务订单处理流程**\n\n![泳道图示例](https://www.qiuxs.cn/sharing-tools/img/read/553aa03ff8a1708b264d22cfe2f7de41)\n客户泳道：\n  开始 -> 浏览商品 -> 添加到购物车 -> 结算 -> 支付 -> 结束\n\n系统泳道：\n  验证库存 -> 生成订单 -> 处理支付 -> 更新库存\n\n仓储部门泳道：\n  接收订单 -> 拣货 -> 包装\n\n物流部门泳道：\n  收件 -> 配送 -> 送达\n\n客服部门泳道：\n  处理查询 -> 处理退换货请求\n\n>对于流程图我们可以用PlantUML代码或者Mermaid来实现。","tags":["数据分析"],"categories":["learn"]},{"title":"数据分析之MySQL食用指南","url":"/2024/07/25/learn/mysql/","content":"\nMySQL作为一种广泛使用的关系型数据库管理系统，是每个数据分析师必备技能，下面让我们来探讨如何利用MySQL进行高效的数据分析。\n\n## 基础语句\n\n为了帮助小伙伴们清晰理解SQL查询的语法结构和运行顺序，我们应该知道下面的：\n- 语法结构：select--from--where--group by--having--order by--limit\n- 运行顺序：from--where--group by--having--order by--limit--select\n\n### SELECT & FROM\n#### 基本语法\n在MySQL中，使用 `SELECT` 语句来指定要查询的字段。语法如下：\n\n```sql\nSELECT 字段名1, 字段名2, ...\n```\n\n使用 `FROM` 语句来指定数据来源的表。语法如下：\n\n```sql\nFROM 表名\n```\n\n**示例：**\n\n假设有一个名为 `students` 的表，包含以下字段：`id`, `name`, `age`, `gender`。\n\n1. 查询所有字段\n\n要查询 `students` 表中的所有字段，可以使用以下语句：\n\n```sql\nSELECT id, name, age, gender\nFROM students\n```\n\n或者简化为：\n\n```sql\nSELECT *\nFROM students\n```\n2. 查询特定字段\n\n如果只需要查询 `name` 和 `age` 字段，可以使用以下语句：\n\n```sql\nSELECT name, age\nFROM students\n```\n通过这些基础的 `SELECT` 和 `FROM` 语句，我们就可以从数据库表中检索所需的数据。\n\n>除此之外，如果我们需要连续执行两三个简单的查询语句，只需要中间用`;`分开，执行的时候就不会报错了。\n\n#### 字段名的——别名\n```sql\nSELECT name AS 姓名, age AS 年龄\nFROM students\n```\n\n>`AS`可以省略，但是`字段名`后面需要加一个空格才可以加上`别名`\n\n使用`AS`我们就可以改变我们的字段名，很简单，并且支持中文。\n\n#### 去重\n在MySQL中，去重操作通常指的是从表中删除重复的记录或查询时排除重复的记录。\n\n以下是两种常见的去重操作：\n\n1. **查询时去重**：\n   - 使用`SELECT DISTINCT`语句来查询不重复的记录。\n   ```sql\n   SELECT DISTINCT column1, column2, ...\n   FROM table_name;\n   ```\n   这条语句将返回指定列中不重复的所有记录。\n\n2. **删除重复记录**：\n   - 删除表中的重复记录稍微复杂一些，需要使用临时表或子查询来实现。以下是一个常见的步骤：\n     - 创建一个临时表，将不重复的记录插入到临时表中。\n     - 删除原表中的所有记录。\n     - 将临时表中的记录插入回原表。\n     - 删除临时表。\n\n   示例代码如下：\n   ```sql\n   -- 创建临时表\n   CREATE TEMPORARY TABLE temp_table AS\n   SELECT DISTINCT * FROM original_table;\n\n   -- 删除原表中的所有记录\n   DELETE FROM original_table;\n\n   -- 将临时表中的记录插入回原表\n   INSERT INTO original_table SELECT * FROM temp_table;\n\n   -- 删除临时表\n   DROP TEMPORARY TABLE temp_table;\n   ```\n\n   另一种方法是使用子查询和`DELETE`语句来删除重复记录：\n   ```sql\n   DELETE t1 FROM original_table t1\n   INNER JOIN original_table t2\n   WHERE t1.id > t2.id AND t1.column = t2.column;\n   ```\n   这条语句将删除`original_table`中所有重复的记录，保留每个重复组中的一个记录。\n\n哦对，去重操作可能会影响数据的完整性和表之间的关系，因此在执行这些操作之前，请确保备份数据并了解其潜在影响。\n\n#### SELECT之中简单的计算\n在MySQL的`SELECT`语句中，我们可以进行各种简单的计算操作，比如加法、减法、乘法、除法等。这些计算可以直接在`SELECT`子句中进行，从而在查询结果中显示计算后的值：\n\n|   操作类型   |   SQL 示例代码   |   描述   |\n|--------------|---------------|------|\n| **加  法** | `SELECT column1, column2, column1 + column2 AS sum_column FROM table_name;` | 返回`column1`和`column2`的值，并在结果中显示它们的和，命名为`sum_column`。 |\n| **减  法** | `SELECT column1, column2, column1 - column2 AS difference_column FROM table_name;` | 返回`column1`和`column2`的值，并在结果中显示它们的差，命名为`difference_column`。 |\n| **乘  法** | `SELECT column1, column2, column1 * column2 AS product_column FROM table_name;` | 返回`column1`和`column2`的值，并在结果中显示它们的乘积，命名为`product_column`。 |\n| **除  法** | `SELECT column1, column2, column1 / column2 AS quotient_column FROM table_name;` | 返回`column1`和`column2`的值，并在结果中显示它们的商，命名为`quotient_column`。注意：如果`column2`的值为0，将会导致除以零的错误。 |\n| **混合计算** | `SELECT column1, column2, (column1 + column2) * 2 AS calculated_column FROM table_name;` | 返回`column1`和`column2`的值，并在结果中显示它们的和乘以2的结果，命名为`calculated_column`。 |\n\n### WHERE\n在MySQL中，`WHERE`子句用于在`SELECT`、`UPDATE`、`DELETE`语句中指定条件，从而对数据进行筛选。`WHERE`子句允许我们根据一个或多个条件过滤数据，只返回满足这些条件的记录。以下是对`WHERE`子句的详细补充：\n\n#### **基本语法**：\n   ```sql\n   SELECT column1, column2, ...\n   FROM table_name\n   WHERE condition;\n   ```\n   这里的`condition`是一个逻辑表达式，用于评估每一行数据是否满足条件。\n\n#### **常见的条件运算符**：\n\n假设我们有一个名为`employees`的表，其中存储了员工的年龄（`age`）、部门（`department`）、工资（`salary`）和电子邮件（`email`）等信息。\n\n我们可以使用各种条件运算符来查询和筛选这个表中的数据：\n\n| 运算符 | 描述 | 示例 | 说明 |\n| --- | --- | --- | --- |\n| `=` | 等于 | `SELECT * FROM employees WHERE age = 30;` | 查询年龄等于30岁的所有员工。 |\n| `<>` 或 `!=` | 不等于 | `SELECT * FROM employees WHERE department <> 'Sales';` | 查询部门不是\"Sales\"的所有员工。 |\n| `>` | 大于 | `SELECT * FROM employees WHERE salary > 5000;` | 查询工资大于5000的所有员工。 |\n| `<` | 小于 | `SELECT * FROM employees WHERE age < 40;` | 查询年龄小于40岁的所有员工。 |\n| `>=` | 大于等于 | `SELECT * FROM employees WHERE salary >= 5000;` | 查询工资大于或等于5000的所有员工。 |\n| `<=` | 小于等于 | `SELECT * FROM employees WHERE age <= 40;` | 查询年龄小于或等于40岁的所有员工。 |\n| `BETWEEN ... AND ...` | 在某个范围内 | `SELECT * FROM employees WHERE salary BETWEEN 5000 AND 10000;` | 查询工资在5000到10000之间的所有员工（包括5000和10000）。 |\n| `IN (...)` | 在某个集合中 | `SELECT * FROM employees WHERE department IN ('Sales', 'Marketing');` | 查询部门是\"Sales\"或\"Marketing\"的所有员工。 |\n| `LIKE` | 匹配某个模式 | `SELECT * FROM employees WHERE name LIKE 'A%';` | 查询名字以\"A\"开头的所有员工（`%`表示任意字符序列）。 |\n| `LIKE` | 匹配某个模式 | `SELECT * FROM employees WHERE name LIKE '_A%';` | 查询名字以\"A\"第二个字母的所有员工（第一个字符可以是任意字符（用`_`表示））|\n| `IS NULL` | 为空 | `SELECT * FROM employees WHERE email IS NULL;` | 查询没有电子邮件地址的所有员工。 |\n| `IS NOT NULL` | 不为空 | `SELECT * FROM employees WHERE email IS NOT NULL;` | 查询有电子邮件地址的所有员工。 |\n| `AND` | 逻辑与 | `SELECT * FROM employees WHERE age > 30 AND department = 'Sales';` | 查询年龄大于30岁且部门是\"Sales\"的所有员工。 |\n| `OR` | 逻辑或 | `SELECT * FROM employees WHERE age > 30 OR salary > 10000;` | 查询年龄大于30岁或工资大于10000的所有员工。 |\n| `NOT` | 逻辑非 | `SELECT * FROM employees WHERE NOT department = 'Sales';` | 查询部门不是\"Sales\"的所有员工。 |\n\n#### **组合条件**：\n   - 使用`AND`和`OR`组合多个条件：\n     ```sql\n     SELECT * FROM employees WHERE age > 30 AND department = 'Sales';\n     ```\n   - 使用括号来明确优先级：\n     ```sql\n     SELECT * FROM employees WHERE (age > 30 AND department = 'Sales') OR salary > 10000;\n     ```\n\n#### 简化\n```sql\nselect name \nfrom world \nwhere name like '%a%'\nand name like '%e%' \nand name like '%i%'\nand name like '%o%' \nand name like '%u%' \nand name not like '% %'\n```\n对于上面的SQL语句，我们可以进行简化。\n\n通过正则表达式（Regular Expression）来简化这个查询。MySQL支持使用`REGEXP`或`RLIKE`运算符来进行正则表达式匹配：\n\n```sql\nSELECT name\nFROM world\nWHERE name REGEXP '[aeiou]'\n  AND name NOT LIKE '% %';\n```\n\n解释：\n- `name REGEXP '[aeiou]'`：这个条件检查名字中是否包含至少一个元音字母（a, e, i, o, u）。\n- `name NOT LIKE '% %'`：这个条件确保名字中不包含空格。\n\n\n`WHERE`子句是SQL查询中非常强大和灵活的工具，它允许我们精确地控制返回的数据集，从而满足各种数据分析和操作的需求。\n\n### ORDER BY\n\n`ORDER BY` 是 SQL 中用于对查询结果进行排序的关键字。通过 `ORDER BY`，我们可以根据一个或多个列的值对结果集进行升序（ASC）或降序（DESC）排序。以下是 `ORDER BY` 的基本用法和一些示例：\n\n#### 基本语法\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition\nORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;\n```\n\n- `column1`, `column2`, ...：指定用于排序的列。\n- `ASC`：表示升序排序（默认）。\n- `DESC`：表示降序排序。\n\n#### 示例\n\n1. **单列升序排序**：\n   ```sql\n   SELECT name, age\n   FROM employees\n   ORDER BY age;\n   ```\n   这个查询将返回所有员工的名字和年龄，并按年龄升序排序。\n\n2. **单列降序排序**：\n   ```sql\n   SELECT name, age\n   FROM employees\n   ORDER BY age DESC;\n   ```\n   这个查询将返回所有员工的名字和年龄，并按年龄降序排序。\n\n3. **多列排序**：\n   ```sql\n   SELECT name, department, salary\n   FROM employees\n   ORDER BY department, salary DESC;\n   ```\n   这个查询将首先按部门升序排序，然后在每个部门内按工资降序排序。\n\n4. **使用列别名排序**：\n   ```sql\n   SELECT name, age AS employee_age\n   FROM employees\n   ORDER BY employee_age;\n   ```\n   这个查询将返回所有员工的名字和年龄（使用别名 `employee_age`），并按年龄升序排序。\n\n5. **使用列位置排序**：\n   ```sql\n   SELECT name, age\n   FROM employees\n   ORDER BY 2;\n   ```\n   这个查询将返回所有员工的名字和年龄，并按第二列（即 `age`）升序排序。\n\n6. **使用IN**：\n   ```sql\n   SELECT name, age, address\n   FROM employees\n   ORDER BY address IN ('上海', '北京'), name, age;\n   ```\n  这个查询首先是根据`address`列是否为'上海'或'北京'进行排序。\n\n  这里的`address IN ('上海', '北京')`会返回一个布尔值（TRUE或FALSE），TRUE会被视为1，FALSE会被视为0。\n\n  因为默认是升序排序，所以地址为'上海'或'北京'的记录会被排在后面。\n\n#### 注意事项\n- `ORDER BY` 通常放在 `SELECT` 语句的最后。\n- 如果不指定排序顺序（即不使用 `ASC` 或 `DESC`），默认是升序排序。\n- 多列排序时，先按第一个列排序，然后在第一个列的每个值内按第二个列排序，依此类推。\n\n### LIMIT\n`LIMIT`是SQL中用于限制查询结果返回行数的子句。它通常用于以下几种情况：\n\n1. **限制返回的行数**：当你只需要查询结果的前几行时，可以使用`LIMIT`。\n2. **分页查询**：在实现分页功能时，`LIMIT`和`OFFSET`结合使用可以指定从哪一行开始返回多少行数据。\n\n#### 基本语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nLIMIT number;\n```\n\n**示例:**\n\n假设我们有一个`employees`表，我们只想获取前5名员工的信息：\n\n```sql\nSELECT name, age, address\nFROM employees\nLIMIT 5;\n```\n\n#### 结合`OFFSET`使用\n\n`OFFSET`用于指定从哪一行开始返回数据。通常用于分页查询。\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nLIMIT number OFFSET offset;\n```\n\n或者更常见的写法是：\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nLIMIT offset, number;\n```\n\n**示例:**\n\n假设我们有一个`employees`表，我们想获取第7到第10名员工的信息：\n\n```sql\nSELECT name, age, address\nFROM employees\nLIMIT 4 OFFSET 6;\n```\n\n或者：\n\n```sql\nSELECT name, age, address\nFROM employees\nLIMIT 6, 4;\n```\n从6+1开始，然后获取4个数据的意思（即获取第7到第10名员工的信息）\n\n#### 注意事项\n\n1. **性能考虑**：使用`LIMIT`可以提高查询性能，尤其是在处理大数据集时。\n2. **排序**：在使用`LIMIT`时，通常需要结合`ORDER BY`子句来确保结果的顺序是确定的。\n\n**示例:**\n\n假设我们想获取年龄最大的前5名员工的信息：\n\n```sql\nSELECT name, age, address\nFROM employees\nORDER BY age DESC\nLIMIT 5;\n```\n\n### 聚合函数 & group by\n\n聚合函数在SQL中用于对一组值进行计算，并返回单个值。它们通常与`GROUP BY`子句一起使用，以便对数据进行分组并计算每个组的聚合值。下面是一些常用的聚合函数及其使用示例：\n\n#### 常用的聚合函数\n\n1. **COUNT**：计算行数。\n2. **SUM**：计算总和。\n3. **AVG**：计算平均值。\n4. **MAX**：找出最大值。\n5. **MIN**：找出最小值。\n\n**示例：**\n\n假设我们有一个名为`sales`的表，包含以下列：`product_id`、`sale_date`、`quantity`和`revenue`。\n\n1. COUNT\n\n计算总行数：\n```sql\nSELECT COUNT(*) AS total_rows\nFROM sales;\n```\n\n计算特定产品的销售记录数：\n```sql\nSELECT product_id, COUNT(*) AS sales_count\nFROM sales\nGROUP BY product_id;\n```\n\n2. SUM\n\n计算总销售额：\n```sql\nSELECT SUM(revenue) AS total_revenue\nFROM sales;\n```\n\n计算每个产品的总销售额：\n```sql\nSELECT product_id, SUM(revenue) AS total_revenue\nFROM sales\nGROUP BY product_id;\n```\n\n3. AVG\n\n计算平均销售额：\n```sql\nSELECT AVG(revenue) AS average_revenue\nFROM sales;\n```\n\n计算每个产品的平均销售额：\n```sql\nSELECT product_id, AVG(revenue) AS average_revenue\nFROM sales\nGROUP BY product_id;\n```\n\n4. MAX\n\n找出最大销售额：\n```sql\nSELECT MAX(revenue) AS max_revenue\nFROM sales;\n```\n\n找出每个产品的最大销售额：\n```sql\nSELECT product_id, MAX(revenue) AS max_revenue\nFROM sales\nGROUP BY product_id;\n```\n\n5. MIN\n\n找出最小销售额：\n```sql\nSELECT MIN(revenue) AS min_revenue\nFROM sales;\n```\n\n找出每个产品的最小销售额：\n```sql\nSELECT product_id, MIN(revenue) AS min_revenue\nFROM sales\nGROUP BY product_id;\n```\n\n#### 结合`GROUP BY`和`HAVING`\n\n`HAVING`子句用于对分组后的结果进行筛选。例如，找出销售额总和超过1000的产品：\n\n```sql\nSELECT product_id, SUM(revenue) AS total_revenue\nFROM sales\nGROUP BY product_id\nHAVING SUM(revenue) > 1000;\n```\n\n#### 聚合函数注意事项\n\n1. **NULL值**：聚合函数通常会忽略`NULL`值。例如，`COUNT(*)`会计算所有行，而`COUNT(column_name)`会忽略该列中的`NULL`值。\n2. **数据类型**：确保聚合函数应用于正确的数据类型。例如，`SUM`和`AVG`通常用于数值类型。\n\n#### `GROUP BY`基本语法\n`GROUP BY`子句在SQL中用于将行分组，通常与聚合函数（如`COUNT`、`SUM`、`AVG`、`MAX`、`MIN`等）一起使用，以便对每个组进行计算。\n\n```sql\nSELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY column1, column2;\n```\n\n**示例：**\n\n假设我们有一个名为`orders`的表，包含以下列：`customer_id`、`order_date`、`product_id`和`quantity`。\n\n1. 按单个列分组\n\n计算每个客户的订单总数：\n```sql\nSELECT customer_id, COUNT(*) AS order_count\nFROM orders\nGROUP BY customer_id;\n```\n\n2. 按多个列分组\n\n计算每个客户和每个产品的订单总数：\n```sql\nSELECT customer_id, product_id, COUNT(*) AS order_count\nFROM orders\nGROUP BY customer_id, product_id;\n```\n3. 结合聚合函数\n\n计算每个客户的订单总数量：\n```sql\nSELECT customer_id, SUM(quantity) AS total_quantity\nFROM orders\nGROUP BY customer_id;\n```\n\n4. 结合`HAVING`子句\n\n筛选出订单总数超过10的客户：\n```sql\nSELECT customer_id, COUNT(*) AS order_count\nFROM orders\nGROUP BY customer_id\nHAVING COUNT(*) > 10;\n```\n\n#### `GROUP BY`注意事项\n\n1. **选择列**：在`SELECT`子句中，除了聚合函数外，所有列都必须出现在`GROUP BY`子句中。\n2. **NULL值**：`GROUP BY`会将所有`NULL`值视为相同的组。\n3. **性能考虑**：`GROUP BY`操作可能会消耗较多资源，尤其是在处理大数据集时。可以考虑使用索引优化性能。\n\n**示例：结合多个聚合函数**\n\n计算每个客户的订单总数、总数量和平均数量：\n```sql\nSELECT customer_id, \n       COUNT(*) AS order_count, \n       SUM(quantity) AS total_quantity, \n       AVG(quantity) AS average_quantity\nFROM orders\nGROUP BY customer_id;\n```\n### HAVING\n\n在SQL中，`HAVING`子句用于对聚合函数的结果进行筛选。它通常与`GROUP BY`子句一起使用，以便在分组后对组进行条件过滤：\n\n#### 语法\n```sql\nSELECT 列1, 列2, 聚合函数(列3)\nFROM 表名\nGROUP BY 列1, 列2\nHAVING 聚合函数(列3) 条件;\n```\n\n**示例:**\n假设我们有一个名为`sales`的表，其中包含以下列：`id`, `product`, `quantity`, `price`。我们想要找出每个产品的总销售额，并且只显示总销售额大于1000的产品。\n\n```sql\nSELECT product, SUM(quantity * price) AS total_sales\nFROM sales\nGROUP BY product\nHAVING SUM(quantity * price) > 1000;\n```\n\n在这个示例中：\n1. `SELECT product, SUM(quantity * price) AS total_sales`：选择产品名称和总销售额。\n2. `FROM sales`：从`sales`表中获取数据。\n3. `GROUP BY product`：按产品名称分组。\n4. `HAVING SUM(quantity * price) > 1000`：筛选出总销售额大于1000的产品。\n\n#### 注意事项\n- `HAVING`子句只能用于包含聚合函数的查询。\n- `HAVING`子句在`GROUP BY`之后执行，因此它用于对分组后的结果进行筛选。\n- 如果不需要对分组后的结果进行筛选，可以直接使用`WHERE`子句对原始数据进行筛选。\n\n> `where`是对原始数据进行筛选(数据不改变)，而`having`是针对聚合函数的筛选(数据改变)\n\n### 常见函数\n#### 数学函数\n1. round(x,y)——四舍五入函数：\n  - round函数对x值进行四舍五入，精确到小数点后y位\n  - y为负值时，保留小数点左边相应的位数为0，不进行四舍五入\n\n下面是示例：\n\n| 表达式                | 结果 | 说明                                       |\n|----------------------|------|------------------------------------------|\n| `ROUND(3.15, 1)`     | 3.2  | 对小数部分的第一位进行四舍五入，结果是3.2   |\n| `ROUND(14.15, -1)`   | 10   | 对整数部分的十位进行四舍五入，结果是10      |\n| `ROUND(152.15, 0)`   | 152  | 对小数部分的第一位进行四舍五入，结果是152   |\n| `ROUND(155.15, -1)`  | 160  | 对整数部分的十位进行四舍五入，结果是160     |\n| `ROUND(152.15, -2)`  | 200  | 对整数部分的百位进行四舍五入，结果是200     |\n| `ROUND(152.15, -3)`  | 0    | 对整数部分的千位进行四舍五入，结果是0       |\n\n#### 字符串函数\n1. concat(s1,s2,...)——连接字符串函数：\n  - concat函数返回连接的参数s1,s2等产生的字符串\n  - 任以参数为null时，返回null\n    - 示例1：`concat('My',' ','SQL')`\n    - 结果：`My SQL`(中间有空格哦)\n    - 示例2：`concat('My',null,'SQL')`\n    - 结果：`null`(只要有一个为null结果就返回null)\n2. replace(s,s1,s2)——替换函数：\n  - replace函数使用字符串s2替代s中**所有**的s1\n    - 示例：`replace('MySQLMySQL','SQL','sql')`\n    - 结果：`MysqlMysql`\n3. left(s,n)、right(s,n)&substring(s,n,len)——截取字符串一部分的函数：\n  - left函数返回字符串s最左边n个字符\n    - 示例：`left(\"Hello, World!\", 5)`\n    - 结果：`\"Hello\"`\n  - right函数返回字符串s最右边n个字符\n    - 示例：`right(\"Hello, World!\", 6)`\n    - 结果：`\"World!\"`\n  - substring函数返回字符串s从第n个字符起取长度为len的子字符串，n可以做为**负值**，则从**倒数**第n个字符起取长度为len的子字符串，没有len值则从第n个字符取到最后一位。\n    - 示例1：`substring(\"Hello, World!\", 7, 5)`\n    - 结果：`\"World\"`\n    - 示例2：`substring(\"Hello, World!\", -6, 5)`\n    - 结果：`\"World\"`\n    - 示例3：`substring(\"Hello, World!\", 7)`\n    - 结果：`\"World!\"`\n4. length()——统计字符串长度的函数：\n  - 用于返回字符串的长度（即字符串中字符的数量）\n    - 示例：`select ... where length(content) > 15`\n    - 结果：返回content列字符串数量大于15的列\n  - **MySQL**和**SQLite**使用`length`函数。\n    **PostgreSQL**使用`length`函数。\n    **SQL Server**使用`len`函数。 \n    **Oracle**使用`length`函数。\n#### 数据类型转换函数\n1. cast(x as type)——转换数据类型的函数\n  - cast函数将一个类型的x值转换为另一类型的值\n  - type参数可以填写char(n)、date、time、datetime、decimal等转换为对应的数值类型\n  1. **将整数转换为字符串**\n    - 示例：`cast(123 as char(5))`\n    - 结果：`\"  123\"`（注意：这里假设`char(5)`会在左侧填充空格以达到5个字符的长度）\n  2. **将字符串转换为日期**\n    - 示例：`cast(\"2023-04-05\" as date)`\n    - 结果：`2023-04-05`（日期类型）\n  3. **将字符串转换为时间**\n    - 示例：`cast(\"14:23:55\" as time)`\n    - 结果：`14:23:55`（时间类型）\n  4. **将字符串转换为日期时间**\n    - 示例：`cast(\"2023-04-05 14:23:55\" as datetime)`\n    - 结果：`2023-04-05 14:23:55`（日期时间类型）\n  5. **将浮点数转换为十进制数**\n    - 示例：`cast(123.456 as decimal(10, 2))`\n    - 结果：`123.46`（十进制数类型，保留两位小数）\n\n#### 日期时间函数\n1. **获取年月日函数**\n   - `year(date)`\n     - 示例：`year('2023-04-05')`\n     - 结果：`2023`\n   - `month(date)`\n     - 示例：`month('2023-04-05')`\n     - 结果：`4`\n   - `day(date)`\n     - 示例：`day('2023-04-05')`\n     - 结果：`5`\n2. **对指定起始时间进行加减操作**\n   - `date_add(date, interval expr type)`\n     - 示例：`date_add('2023-04-05', interval 10 day)`\n     - 结果：`2023-04-15`\n   - `date_sub(date, interval expr type)`\n     - 示例：`date_sub('2023-04-05', interval 5 day)`\n     - 结果：`2023-03-31`\n3. **计算两个日期之间间隔的天数**\n   - `datediff(date1, date2)`\n     - 示例：`datediff('2023-04-10', '2023-04-05')`\n     - 结果：`5`\n4. **将日期和时间格式化**\n   - `date_format(date, format)`\n     - 示例：`date_format('2023-04-05 14:23:55', '%Y-%m-%d %H:%i:%s')`\n     - 结果：`2023-04-05 14:23:55`\n     - 示例：`date_format('2023-04-05 14:23:55', '%d/%m/%Y')`\n     - 结果：`05/04/2023`\n5. 格式化符号说明：\n\n| 格式化符号 | 说明 | 格式化符号 | 说明 |\n|------------|------|------------|------|\n| %Y         | 4位数的年份（例如：2023） | %y         | 2位数的年份（例如：23） |\n| %m         | 2位数的月份（01到12） | %c         | 月份的数字表示（1到12） |\n| %d         | 2位数的日期（01到31） | %e         | 日期的数字表示（1到31） |\n| %H         | 2位数的小时（00到23） | %k         | 小时（0到23） |\n| %h         | 2位数的小时（01到12） | %I         | 2位数的小时（01到12） |\n| %l         | 小时（1到12） |            |            |\n| %i         | 2位数的分钟（00到59） |            |            |\n| %S         | 2位数的秒（00到59） | %s         | 秒（从1970-01-01 00:00:00 UTC开始的秒数） |\n| %f         | 微秒（000000到999999） |            |            |\n| %p         | AM或PM |            |            |\n| %r         | 时间，12小时制（hh:mm:ss AM/PM） | %T         | 时间，24小时制（hh:mm:ss） |\n| %W         | 星期几的全名（例如：Sunday） | %a         | 星期的缩写名（例如：Sun） |\n| %w         | 星期几的数字表示（0=Sunday, 6=Saturday） |            |            |\n| %j         | 一年中的第几天（001到366） |            |            |\n| %U         | 一年中的第几周（00到53），星期天是一周的第一天 | %u         | 一年中的第几周（00到53），星期一是一周的第一天 |\n| %V         | 一年中的第几周（01到53），星期天是一周的第一天，用于ISO 8601 | %v         | 一年中的第几周（01到53），星期一是一周的第一天，用于ISO 8601 |\n\n#### 条件判断函数\n1. if(expr,v1,v2)\n  - 如果表达式expr是true返回v1，否则返回v2\n    - 示例：`if(5 > 3, 'Yes', 'No')`\n    - 结果：`'Yes'`\n    - 示例：`if(length('hello') > 10, 'Long', 'Short')`\n    - 结果：`'Short'`\n2. case when\n  - case expr when v1 then r1 [when v2 then r2]...[else rn] end\n    - 例如：`case 2 when 1 then 'one' when 2 then 'two' else 'more' end` \n    - 结果：`two`\n  - case when v1 then r1 [when v2 then r2]...[else rn] end\n    - 例如：`case when 1<0 then 'T' else 'F' end `\n    - 结果：`F`\n3. 详细说明`case when`\n`case when` 语句用于多条件判断，可以根据不同的条件返回不同的结果。它有两种常见的形式,第一种形式是基于表达式的判断，第二种形式是基于条件的判断。\n\n##### 形式一：基于表达式的 `case when`\n```sql\nCASE expr \n  WHEN v1 THEN r1 \n  [WHEN v2 THEN r2]\n  ...\n  [ELSE rn] \nEND\n```\n- **示例**：\n  ```sql\n  SELECT \n    CASE 2 \n      WHEN 1 THEN 'one' \n      WHEN 2 THEN 'two' \n      ELSE 'more' \n    END AS result;\n  ```\n- **结果**：`two`\n##### 形式二：基于条件的 `case when`\n```sql\nCASE \n  WHEN v1 THEN r1 \n  [WHEN v2 THEN r2]\n  ...\n  [ELSE rn] \nEND\n```\n- **示例**：\n  ```sql\n  SELECT \n    CASE \n      WHEN 1 < 0 THEN 'T' \n      ELSE 'F' \n    END AS result;\n  ```\n- **结果**：`F`\n`case when`语句在处理复杂逻辑和多分支场景时非常有用：\n## 高级语句\n\nSQL高级语句可以用于数据处理、分析和转换等，是数据岗工作所必备的技能。\n\n### 窗口函数\n\n窗口函数是SQL中用于对数据进行分组、排序和计算的高级功能。它们可以在不改变数据行数的情况下，对数据进行复杂的分析和处理。\n\n#### 标准语法\n\n窗口函数的标准语法如下：\n\n```sql\n<窗口函数> OVER (\n    [PARTITION BY <分区列>]\n    [ORDER BY <排序列>]\n    [<窗口框架>]\n)\n```\n\n- `窗口函数`：可以是聚合函数（如 `SUM`、`AVG`）或者是其他的窗口函数（如 `ROW_NUMBER`）。\n- `PARTITION BY`：可选，指定分区列。\n- `ORDER BY`：可选，指定排序列。\n- `窗口框架`：可选，定义窗口的范围，如 `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`。\n\n#### 滑动窗口：rows&range用法\n```sql\n<ROWS or RANGE clause> BETWEEN <Start expr> AND <End expr>\n```\n\nROWS: 表示按照行的范围进行定义框架，根据order by子句排序后，取的前N行及后N行的数据计算（与当前行的值无关，只与排序后的行号相关）。\n\n常用：rows n perceding表示从当前行到前n行（一共n+1行）\n\nRANGE：表示按照值的范围进行定义框架，根据order by子句排序后，指定当前行对应值的范围取值，行数不固定，只要行值在范围内，对应行都包含在内。适用于对日期、时间、数值排序分组\n\n| 边界可取值 (Start expr & End expr) | 说明 |\n|------------------------------------|------|\n| `CURRENT ROW`                      | 当前行 |\n| `N PRECEDING`                      | 前 n 行，n 为数字，比如 `2 PRECEDING` 表示前2行 |\n| `UNBOUNDED PRECEDING`              | 开头 |\n| `N FOLLOWING`                      | 后 N 行，n 为数字，比如 `2 FOLLOWING` 表示后2行 |\n| `UNBOUNDED FOLLOWING`              | 结尾 |\n\n| `RANGE` 取特定日期区间 | 说明 |\n|------------------------|------|\n| `RANGE INTERVAL '7-1' DAY PRECEDING` | 最近7天的值 |\n| `RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND INTERVAL '1' DAY FOLLOWING` | 前后一天和当天的值 |\n\n**示例1：**\n```sql\nSELECT\n    id,\n    name,\n    salary,\n    departmentld,\n    sum(salary)over(order by id) as '累计工资',\n    sum(salary)over(order by id rows 1 preceding) as '本行加前一行',\n    sum(salary)over(order by id rows 2 preceding) as '本行加前两行',\n    sum(salary)over(order by id rows between 2 preceding and 1 following ) as '前两行加到后一行',\n    sum(salary)over(order by id rows between current row and 1 unbounded following ) as '当前行加到后一行'\nFROM employees;\n```\n这段 SQL 查询使用了窗口函数来计算不同范围内的工资累计值。如下图：\n\n![1](https://www.qiuxs.cn/sharing-tools/img/read/3aae9b54b94e6c6d61ea1cab1887271d)\n\n下面来让我们逐行解释每个窗口函数的含义：\n\n1. **累计工资**：\n    ```sql\n    sum(salary) over (order by id) as '累计工资'\n    ```\n    这个窗口函数计算从第一行到当前行的工资累计值。由于没有指定 `ROWS` 或 `RANGE` 子句，默认是 `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`，即从分区的第一行到当前行的累计值。\n2. **本行加前一行**：\n    ```sql\n    sum(salary) over (order by id rows 1 preceding) as '本行加前一行'\n    ```\n    这个窗口函数计算当前行和前一行的工资总和。`ROWS 1 PRECEDING` 表示窗口从当前行的前一行开始，到当前行结束。\n3. **本行加前两行**：\n    ```sql\n    sum(salary) over (order by id rows 2 preceding) as '本行加前两行'\n    ```\n    这个窗口函数计算当前行和前两行的工资总和。`ROWS 2 PRECEDING` 表示窗口从当前行的前两行开始，到当前行结束。\n4. **前两行加到后一行**：\n    ```sql\n    sum(salary) over (order by id rows between 2 preceding and 1 following) as '前两行加到后一行'\n    ```\n    这个窗口函数计算从当前行的前两行到当前行的后一行的工资总和。`ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING` 表示窗口从当前行的前两行开始，到当前行的后一行结束。\n5. **当前行加到后一行**：\n    ```sql\n    sum(salary) over (order by id rows between current row and 1 unbounded following) as '当前行加到后一行'\n    ```\n    这个窗口函数计算从当前行到分区的最后一行的工资总和。`ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING` 表示窗口从当前行开始，到分区的最后一行结束。\n\n**示例2：**\n```sql\nSELECT\n    id,\n    name,\n    salary,\n    departmentld,\n    count(*)over(order by salary range between 10000 preceding and 10000 following) as '员工人数（薪资在±10000）',\n    count(*)over(order by salary range between 5000 preceding and 5000 following) as '员工人数（薪资在±5000）'\nFROM employees;\n```\n这段 SQL 查询使用了窗口函数来计算在特定薪资范围内的员工人数。具体来说，它使用了 `RANGE` 子句来定义窗口，该窗口基于薪资的值范围。如下图：\n\n![2](https://www.qiuxs.cn/sharing-tools/img/read/d2420c572cc95fa9bb7eb24963b10385)\n让我们逐行解释每个窗口函数的含义：\n1. **员工人数（薪资在±10000）**：\n    ```sql\n    count(*) over (order by salary range between 10000 preceding and 10000 following) as '员工人数（薪资在±10000）'\n    ```\n    这个窗口函数计算薪资在当前行薪资的±10000范围内的员工人数。例如，如果当前员工的薪资是 15000 元，那么薪资在5000元到25000元之间的所有员工都会被统计在内。\n    \n    `RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING` 表示窗口从当前行薪资的前 10000 开始，到当前行薪资的后 10000 结束。\n2. **员工人数（薪资在±5000）**：\n    ```sql\n    count(*) over (order by salary range between 5000 preceding and 5000 following) as '员工人数（薪资在±5000）'\n    ```\n    这个窗口函数计算薪资在当前行薪资的±5000范围内的员工人数。例如，如果当前员工的薪资是 15000 元，那么薪资在10000元到20000元之间的所有员工都会被统计在内。\n\n    `RANGE BETWEEN 5000 PRECEDING AND 5000 FOLLOWING` 表示窗口从当前行薪资的前 5000 开始，到当前行薪资的后 5000 结束。\n\n#### 排序窗口函数\n\n排序窗口函数用于为结果集中的每一行分配一个唯一的序号或排名。常见的排序窗口函数包括：\n\n- `ROW_NUMBER()`：为每一行分配一个唯一的序号。\n- `RANK()`：为每一行分配一个排名，排名相同的行会有相同的序号，后续的排名会跳过。\n- `DENSE_RANK()`：与 `RANK()` 类似，但后续的排名不会跳过。\n- `NTILE(n)`：将结果集分成 `n` 个桶，并为每一行分配一个桶号。\n- `PERCENT_RANK()`：计算每一行的百分比排名，结果在0到1之间。\n- `CUME_DIST()`：计算每一行的累积分布，结果在0到1之间。\n\n\n1. 窗口函数只能写在`select`字句中\n2. 窗口函数中的`partition by`子句可以指定数据的分区，和`group by`要去重分组不同的是，`partition by`**只分区不去重**\n3. 窗口函数中没有`partition by`子句时，即不对数据分区，直接整个表为一个区\n4. 排序窗口函数中`order by`子句是**必选项**，窗口函数中`order by`子句在**分区内**，依据指定字段和排序方法对数据行排序\n5. `rank()、dense_rank0、row_number()`指定排序赋值方法，对比三个排序窗口函数的异同：\n    - rank():跳跃式排序--比如数值为99，99，90，89，那么通过这个函数得到的排名为1，1，3，4\n    - dense_rank():并列连续型排序--比如数值为99，99，90，89，那么通过这个函数得到的排名为1，1，2，3\n    - row_number():连续型排序--比如数值为99，99，90，89，那么通过这个函数得到的排名为1，2，3，4\n    - 根据对排序值的需求选择相应的排序窗口函数，由于值的不同特性(比如数值不重复)，这三个函数可以通用\n**示例**：\n\n```sql\nSELECT\n    department,\n    employee_name,\n    salary,\n    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank,\n    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank\nFROM employees;\n```\n\n在这个示例中，我们对每个部门的员工按工资从高到低进行排序，并为每个员工分配行号、排名和密集排名。\n\n#### 偏移分析函数\n\n偏移分析函数用于访问窗口内其他行的数据，常见的偏移分析函数包括：\n- `LAG(expression, offset, default)`：用于访问当前行之前的第 `offset` 行的数据，如果没有找到则返回 `default`。\n- `LEAD(expression, offset, default)`：用于访问当前行之后的第 `offset` 行的数据，如果没有找到则返回 `default`。\n\n**示例**：\n\n```sql\nSELECT\n    employee_name,\n    department,\n    salary,\n    LAG(salary, 1, 0) OVER (PARTITION BY department ORDER BY salary) AS previous_salary,\n    LEAD(salary, 1, 0) OVER (PARTITION BY department ORDER BY salary) AS next_salary\nFROM employees;\n```\n\n在这个示例中，我们使用 `LAG` 函数获取当前行的上一行的工资，使用 `LEAD` 函数获取当前行的下一行的工资。如果没有找到对应的行，则返回默认值 `0`。这样可以方便地进行比较分析。\n\n### 表连接\n表连接是关系型数据库中用于合并两个或多个表的数据的一种操作。表连接基于这些表之间的相关列进行操作。\n\n#### **内连接（INNER JOIN）**：\n   内连接返回两个表中满足连接条件的记录。只有当连接条件为真时，记录才会被包含在结果集中。\n   ```sql\n   SELECT column1, column2, ...\n   FROM table1\n   INNER JOIN table2\n   ON table1.common_field = table2.common_field;\n   ```\n   解释：\n   - `SELECT column1, column2, ...`：选择需要查询的列。\n   - `FROM table1`：指定主表。\n   - `INNER JOIN table2`：指定要连接的表。\n   - `ON table1.common_field = table2.common_field`：指定连接条件，即两个表中用于匹配的列。\n#### **左连接（LEFT JOIN 或 LEFT OUTER JOIN）**：\n   左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中对应的部分为 NULL。\n   ```sql\n   SELECT column1, column2, ...\n   FROM table1\n   LEFT JOIN table2\n   ON table1.common_field = table2.common_field;\n   ```\n   解释：\n   - `SELECT column1, column2, ...`：选择需要查询的列。\n   - `FROM table1`：指定主表。\n   - `LEFT JOIN table2`：指定要连接的表。\n   - `ON table1.common_field = table2.common_field`：指定连接条件。\n#### **右连接（RIGHT JOIN 或 RIGHT OUTER JOIN）**：\n   右连接返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中对应的部分为 NULL。\n   ```sql\n   SELECT column1, column2, ...\n   FROM table1\n   RIGHT JOIN table2\n   ON table1.common_field = table2.common_field;\n   ```\n   解释：\n   - `SELECT column1, column2, ...`：选择需要查询的列。\n   - `FROM table1`：指定主表。\n   - `RIGHT JOIN table2`：指定要连接的表。\n   - `ON table1.common_field = table2.common_field`：指定连接条件。\n#### **全外连接（FULL OUTER JOIN 或 FULL JOIN）**：\n   全外连接返回两个表中的所有记录，当没有匹配的记录时，结果集中对应的部分为 NULL。MySQL本身不支持FULL OUTER JOIN，但可以通过UNION操作实现类似效果。\n   ```sql\n   SELECT column1, column2, ...\n   FROM table1\n   LEFT JOIN table2\n   ON table1.common_field = table2.common_field\n   UNION\n   SELECT column1, column2, ...\n   FROM table1\n   RIGHT JOIN table2\n   ON table1.common_field = table2.common_field;\n   ```\n   解释：\n   - `SELECT column1, column2, ...`：选择需要查询的列。\n   - `FROM table1`：指定主表。\n   - `LEFT JOIN table2`：指定要连接的表。\n   - `ON table1.common_field = table2.common_field`：指定连接条件。\n   - `UNION`：合并两个查询结果。\n#### **交叉连接（CROSS JOIN）**：\n   交叉连接返回两个表的笛卡尔积，即第一个表的每一行与第二个表的每一行组合。\n   ```sql\n   SELECT column1, column2, ...\n   FROM table1\n   CROSS JOIN table2;\n   ```\n   解释：\n   - `SELECT column1, column2, ...`：选择需要查询的列。\n   - `FROM table1`：指定主表。\n   - `CROSS JOIN table2`：指定要连接的表。\n\n### 子查询\n子查询是嵌套在另一个查询中的查询，是优先于主查询的，它可以出现在SQL语句的多个部分，如SELECT、FROM、WHERE、HAVING等子句中。子查询可以返回单个值、一列值或一个表。\n\n#### **标量子查询（Scalar Subquery）**：\n标量子查询返回单个值，通常用在SELECT子句或WHERE子句中。\n```sql\nSELECT column1, column2, (SELECT scalar_column FROM table2 WHERE condition) AS alias\nFROM table1\nWHERE condition;\n```\n解释：\n- `SELECT column1, column2, ...`：选择需要查询的列。\n- `(SELECT scalar_column FROM table2 WHERE condition)`：标量子查询，返回单个值。\n- `AS alias`：为子查询结果指定别名。\n- `FROM table1`：指定主表。\n- `WHERE condition`：指定查询条件。\n\n#### **列子查询（Column Subquery）**：\n列子查询返回一列值，通常用在WHERE子句中，与IN、ANY、ALL等操作符一起使用。\n```sql\nSELECT column1, column2\nFROM table1\nWHERE column1 IN (SELECT column1 FROM table2 WHERE condition);\n```\n解释：\n- `SELECT column1, column2`：选择需要查询的列。\n- `FROM table1`：指定主表。\n- `WHERE column1 IN (SELECT column1 FROM table2 WHERE condition)`：列子查询，返回一列值。\n\n#### **行子查询（Row Subquery）**：\n行子查询返回一行值，通常用在WHERE子句中，与比较操作符一起使用。\n```sql\nSELECT column1, column2\nFROM table1\nWHERE (column1, column2) = (SELECT column1, column2 FROM table2 WHERE condition);\n```\n解释：\n- `SELECT column1, column2`：选择需要查询的列。\n- `FROM table1`：指定主表。\n- `WHERE (column1, column2) = (SELECT column1, column2 FROM table2 WHERE condition)`：行子查询，返回一行值。\n\n#### **表子查询（Table Subquery）**：\n表子查询返回一个表，通常用在FROM子句中，作为临时表使用。\n```sql\nSELECT a.column1, a.column2\nFROM (SELECT column1, column2 FROM table2 WHERE condition) AS a\nJOIN table1 ON a.common_field = table1.common_field;\n```\n解释：\n- `SELECT a.column1, a.column2`：选择需要查询的列。\n- `FROM (SELECT column1, column2 FROM table2 WHERE condition) AS a`：表子查询，返回一个表。\n- `JOIN table1 ON a.common_field = table1.common_field`：与主表进行连接。\n\n#### **相关子查询（Correlated Subquery）**：\n相关子查询依赖于外部查询的值，它会对每个外部查询的行进行一次评估。\n```sql\nSELECT column1, column2\nFROM table1 a\nWHERE column1 = (SELECT MAX(column1) FROM table2 WHERE table2.common_field = a.common_field);\n```\n解释：\n- `SELECT column1, column2`：选择需要查询的列。\n- `FROM table1 a`：指定主表，并为其指定别名。\n- `WHERE column1 = (SELECT MAX(column1) FROM table2 WHERE table2.common_field = a.common_field)`：相关子查询，依赖于外部查询的值。\n","tags":["数据分析"],"categories":["learn"]},{"title":"随机森林如何调参","url":"/2024/07/15/learn/data6/","content":"随机森林是一种强大的集成学习方法，通过构建多个决策树并取它们的平均值来进行预测。为了获得最佳性能，需要对随机森林模型进行调参。以下是一些常见的参数和调参方法：\n\n### 常见参数\n\n1. **n_estimators**: 决策树的数量。通常，增加树的数量可以提高模型的性能，但也会增加计算成本。\n2. **max_depth**: 每棵树的最大深度。限制树的深度可以防止过拟合。\n3. **min_samples_split**: 内部节点再划分所需最小样本数。增加这个值可以防止过拟合。\n4. **min_samples_leaf**: 叶子节点最少样本数。增加这个值可以防止过拟合。\n5. **max_features**: 寻找最佳分割时要考虑的特征数量。通常，默认值（\"auto\"或\"sqrt\"）效果较好。\n6. **bootstrap**: 是否进行自助采样。通常设置为True。\n\n### 调参方法\n\n#### 1. 网格搜索（Grid Search）\n\n网格搜索是一种穷举搜索方法，通过遍历给定的参数组合来找到最佳参数。\n\n```python\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.ensemble import RandomForestRegressor\n\n# 定义参数网格\nparam_grid = {\n    'n_estimators': [50, 100, 200],\n    'max_depth': [None, 10, 20, 30],\n    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4],\n    'max_features': ['auto', 'sqrt']\n}\n\n# 创建随机森林模型\nrf_model = RandomForestRegressor(random_state=42)\n\n# 创建GridSearchCV对象\ngrid_search = GridSearchCV(estimator=rf_model, param_grid=param_grid, \n                           cv=3, n_jobs=-1, verbose=2, scoring='neg_mean_squared_error')\n\n# 训练模型\ngrid_search.fit(X_train, y_train)\n\n# 获取最佳参数\nbest_params = grid_search.best_params_\nprint(f\"Best Parameters: {best_params}\")\n```\n\n#### 2. 随机搜索（Randomized Search）\n\n随机搜索是一种在参数空间中随机采样的方法，适用于参数空间较大的情况。\n\n```python\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom scipy.stats import randint as sp_randint\n\n# 定义参数分布\nparam_dist = {\n    'n_estimators': sp_randint(50, 200),\n    'max_depth': [None, 10, 20, 30],\n    'min_samples_split': sp_randint(2, 11),\n    'min_samples_leaf': sp_randint(1, 5),\n    'max_features': ['auto', 'sqrt']\n}\n\n# 创建随机森林模型\nrf_model = RandomForestRegressor(random_state=42)\n\n# 创建RandomizedSearchCV对象\nrandom_search = RandomizedSearchCV(estimator=rf_model, param_distributions=param_dist, \n                                   n_iter=100, cv=3, n_jobs=-1, verbose=2, scoring='neg_mean_squared_error')\n\n# 训练模型\nrandom_search.fit(X_train, y_train)\n\n# 获取最佳参数\nbest_params = random_search.best_params_\nprint(f\"Best Parameters: {best_params}\")\n```\n\n#### 3. 基于贝叶斯优化的调参\n\n贝叶斯优化是一种更高效的调参方法，通过构建概率模型来选择最有可能改善性能的参数。\n\n```python\nfrom skopt import BayesSearchCV\nfrom skopt.space import Integer, Categorical\n\n# 定义参数空间\nparam_space = {\n    'n_estimators': Integer(50, 200),\n    'max_depth': Categorical([None, 10, 20, 30]),\n    'min_samples_split': Integer(2, 11),\n    'min_samples_leaf': Integer(1, 5),\n    'max_features': Categorical(['auto', 'sqrt'])\n}\n\n# 创建随机森林模型\nrf_model = RandomForestRegressor(random_state=42)\n\n# 创建BayesSearchCV对象\nbayes_search = BayesSearchCV(estimator=rf_model, search_spaces=param_space, \n                             n_iter=50, cv=3, n_jobs=-1, verbose=2, scoring='neg_mean_squared_error')\n\n# 训练模型\nbayes_search.fit(X_train, y_train)\n\n# 获取最佳参数\nbest_params = bayes_search.best_params_\nprint(f\"Best Parameters: {best_params}\")\n```","tags":["数据分析"],"categories":["learn"]},{"title":"数据分析之Tableau食用指南","url":"/2024/07/12/learn/tableau/","content":"\n**Tableau：最易上手且功能强大的可视化操作BI工具**\n\nTableau是一款广受欢迎的商业智能（BI）工具，以其直观的用户界面和强大的数据可视化功能而闻名。无论是数据分析师、业务用户还是IT专业人员，都能快速上手并利用Tableau进行高效的数据分析和可视化展示。\n\n相对于**Excel**，Tableau可以处理以亿为级别的数据，展现出其卓越的数据处理能力。而Excel在处理几十万条数据的时候，往往会出现卡顿现象，限制了其在大型数据集上的应用。\n\n相较于**MySQL**，Tableau不仅提供了强大的数据连接和处理功能，还以其可视化操作和丰富的图表选项著称。用户可以通过Tableau直观地展示数据，进行深入的数据探索和分析，而MySQL虽然在业务取数方面表现出色，但在可视化能力上相对有限，无法全面满足复杂的数据展示需求。\n\n相较于**Python**，Tableau的上手难度显著降低，用户无需深厚的编程基础，即可通过简单的操作实现复杂的数据分析和可视化。这种即学即用的特性，使得Tableau成为非专业人士进行数据分析的理想选择，而Python则需要用户投入较大的精力进行学习和实践。\n\n相较于其他**BI工具**，Tableau在多个方面展现出其独特的优势：\n\n- **更直观的用户界面**：Tableau的拖放式操作界面和直观的图表生成方式，使得数据分析变得更加简单和直观。\n- **更灵活的数据连接**：Tableau支持多种数据源的连接和混合分析，能够无缝集成各类数据，提供全面的数据洞察。\n- **更强大的交互功能**：Tableau的仪表板支持丰富的交互功能，用户可以通过点击、筛选等操作深入探索数据，提升分析的深度和广度。\n- **更丰富的社区支持**：Tableau拥有庞大的用户社区和丰富的在线资源，用户可以轻松获取帮助和学习资料，加速问题的解决和技能的提升。\n\n## 数据连接\n\nTableau支持与多种数据源的连接，包括本地文件、数据库、云服务等。以下是一些常见的数据连接方式：\n\n- **本地文件**：Tableau可以直接打开多种类型的本地文件，包括：\n  - **CSV文件**：通常使用文本编辑器打开。\n  - **Excel文件（xlsx）**：使用Microsoft Excel打开。\n  - **JSON文件**：用于存储结构化数据的轻量级格式。\n  - **Microsoft Access文件（mdb, accdb）**：用于存储关系型数据的桌面数据库文件。\n  - **PDF文件**：虽然PDF主要用于文档展示，但Tableau可以通过插件或外部工具提取其中的数据。\n  - **空间文件（如Shapefile, GeoJSON）**：用于地理空间数据的存储和分析。\n  - **统计文件（如SPSS, SAS）**：用于存储统计分析数据的文件格式。\n- **数据库**：Tableau支持与多种数据库的连接，如MySQL、Oracle、SQL Server等。用户只需提供数据库的连接信息，即可将数据库中的数据导入Tableau进行分析。\n- **云服务**：Tableau还支持与各种云服务的连接，如Amazon Redshift、Google BigQuery等。通过与云服务的集成，用户可以轻松访问和分析存储在云端的大量数据。\n---\n\n在Tableau的数据连接世界中，实时连接与数据提取是两种核心的数据接入方式，它们各自拥有独特的优势和适用场景，共同构成了Tableau强大的数据处理能力。\n\n### 实时连接\n\n实时连接是Tableau的一项关键功能，它允许用户直接连接到数据源，实时获取和分析数据。这种方式的优势在于：\n\n- **即时性**：用户可以实时查看和分析最新的数据，无需等待数据提取和加载的过程，确保了分析结果的时效性和准确性。\n- **动态性**：实时连接支持数据的动态更新和变化，用户可以在Tableau中观察到数据随时间的变化趋势，适用于需要频繁更新数据的场景。\n- **灵活性**：用户可以根据需要灵活地调整查询条件和分析维度，实时获取所需的数据洞察，提高了数据分析的灵活性和响应速度。\n\n然而，实时连接也存在一定的局限性，例如在处理大规模数据集时可能会遇到性能瓶颈，以及对数据源的稳定性和响应速度有一定要求。\n\n### 数据提取\n\n数据提取是Tableau的另一种数据连接方式，它通过将数据从源系统提取到Tableau的本地存储中，实现数据的离线分析和处理。这种方式的优势在于：\n\n- **性能优化**：数据提取可以将大规模数据集加载到Tableau的本地存储中，通过优化数据结构和索引，提高数据查询和分析的性能，适用于处理复杂和大规模的数据集。\n- **稳定性**：数据提取不受源系统性能和稳定性的影响，用户可以在Tableau中稳定地进行数据分析和可视化，确保了分析过程的连续性和可靠性。\n- **灵活性**：用户可以根据需要定期更新数据提取，保持数据的最新状态，同时也可以对提取的数据进行预处理和清洗，提高数据分析的质量和效率。\n\n数据提取的局限性在于它需要定期更新以保持数据的最新状态，以及在处理实时数据变化时可能存在一定的延迟。\n\n### 适用场景\n\n- **实时连接**：适用于需要实时查看和分析最新数据的场景，如实时监控、实时报表、实时决策支持等。\n- **数据提取**：适用于需要处理大规模数据集、进行复杂数据分析和可视化的场景，如历史数据分析、趋势预测、数据挖掘等。\n\n通过灵活运用实时连接和数据提取两种方式，Tableau为用户提供了全面的数据接入和分析能力，无论是实时数据监控还是深度数据挖掘，Tableau都能提供强大的支持。\n\n\n## 数据保存\n\n数据保存确保了用户的工作成果得以安全存储，便于后续的访问、分享和进一步分析。Tableau提供了多种数据保存方式，以满足不同用户的需求和场景。\n\n### 工作簿保存\n\nTableau工作簿是用户进行数据分析和可视化的主要成果，包含了所有的数据连接、图表、仪表板和分析逻辑。Tableau支持将工作簿保存为`.twb`或`.twbx`格式：\n\n- **.twb格式**：这种格式保存了工作簿的结构和设置，但不包含数据提取。用户在打开`.twb`文件时需要重新连接到原始数据源。\n- **.twbx格式**：这种格式是Tableau打包工作簿，包含了工作簿的所有内容，包括数据提取。用户在打开`.twbx`文件时无需重新连接数据源，可以直接进行分析。\n\n### 数据提取保存\n\n对于通过数据提取方式连接的数据，Tableau允许用户将提取的数据保存为`.tde`或`.hyper`格式：\n\n- **.tde格式**：这是Tableau Data Extract的旧格式，适用于Tableau 10.x及更早版本。它支持数据的压缩和优化，便于快速加载和分析。\n- **.hyper格式**：这是Tableau Data Extract的新格式，从Tableau 10.5开始引入。它提供了更高的性能和更灵活的数据模型，支持更复杂的数据类型和操作。\n\n### 数据源保存\n\nTableau还支持将数据源保存为`.tds`或`.tdsx`格式：\n\n- **.tds格式**：这种格式保存了数据源的连接信息和设置，但不包含数据提取。用户在打开`.tds`文件时需要重新连接到原始数据源。\n- **.tdsx格式**：这种格式是Tableau打包数据源，包含了数据源的所有内容，包括数据提取。用户在打开`.tdsx`文件时无需重新连接数据源，可以直接使用。\n\n### 云端保存\n\n随着云计算的普及，Tableau也提供了云端保存的选项，支持将工作簿和数据提取保存到Tableau Online或Tableau Server：\n\n- **Tableau Online**：这是Tableau的云服务平台，用户可以将工作簿和数据提取上传到云端，实现跨设备的访问和协作。\n- **Tableau Server**：这是Tableau的企业级服务器解决方案，支持在企业内部部署，提供更强大的数据管理和安全控制。\n\n### 数据备份与恢复\n\n为了确保数据的安全性，Tableau还提供了数据备份和恢复的功能。用户可以定期备份工作簿、数据提取和数据源，以防止数据丢失或损坏。在需要时，用户可以通过备份文件快速恢复数据，确保分析工作的连续性和可靠性。\n\n## 数据解释器\n数据解释器清理是Tableau中的一项功能，主要用于处理和清理导入的数据，以便更有效地进行数据分析和可视化。以下是数据解释器清理的具体含义和作用：\n\n### 含义\n数据解释器清理是指在Tableau中导入数据时，自动识别和处理数据中的常见问题，如重复行、缺失值、格式不一致等。这一过程旨在提高数据的质量和一致性，确保后续的数据分析和可视化更加准确和可靠。\n\n### 作用\n1. **数据清洗**：自动识别和删除重复的行，填充或删除缺失值，统一数据格式，从而提高数据的整体质量。\n2. **简化分析**：通过清理数据，减少分析过程中的干扰因素，使分析师能够更专注于数据的实质内容和洞察。\n3. **提升可视化效果**：高质量的数据是生成有效可视化图表的基础。数据解释器清理确保数据在可视化过程中能够准确反映实际情况，避免误导性的图表和结论。\n4. **节省时间**：手动清理数据通常耗时且容易出错。数据解释器清理功能能够自动完成这些任务，节省分析师的时间和精力，使其能够更快地进行数据探索和分析。\n\n在Tableau中，数据解释器清理功能通常在数据源设置阶段启用。用户可以在导入数据时选择启用数据解释器，Tableau将自动进行数据清理。这一功能特别适用于处理来自不同来源和格式的数据，确保数据在导入后即可用于分析和可视化。\n\n## 数据可视化\n\n我们之所以需要数据可视化，是因为在缺乏专业训练的情况下，面对一堆数字，我们往往难以迅速识别出其中的最大值、最小值等关键信息。人类对数据的敏感度实际上是相对较低的。\n\n然而，一旦我们通过可视化操作，将这些数字转化为直观的图像，我们的数据敏感度便会显著提升。这是因为人类天生就是图像视觉动物，我们的大脑更擅长处理和理解视觉信息。通过图表、图形等视觉元素，我们能够更快速、更直观地捕捉到数据的核心特征和内在规律，从而更有效地进行数据分析和决策。\n\n其实对于tableau，我们要做的，熟能生巧就可以了，除此之外，要掌握做表格、做词云、做其他基础图表的能力。\n\n其实总结来说，就是：\n- 度量默认聚合\n- 度量值会形成图形标记，图形标记可以切换\n- 维度会对度量值进行区分，增加度量值的信息密度\n- 图表分为有轴图表和无轴图表(极坐标图表)\n- 离散形成标签，连续形成数轴\n\n## 基础图表制作指南\n\n### 柱状图\n在成功连接数据源后，创建一个新的工作表。将所需数据分别拖拽至`行`和`列`区域，即可轻松生成柱状图。\n\n### 条形图\n若需将柱状图转换为条形图，只需点击工具栏中的排序快捷图标左侧，选择`交换行和列`（快捷键：Ctrl+W）。此外，通过在维度数据上右键点击并选择`创建分层结构`，可实现数据的分层展示，这是一个非常便捷的功能。\n\n#### 筛选器\n筛选器是基础且实用的功能之一。在点击`显示筛选器`后，右侧将出现筛选面板，可用于按数值、日期、门店等条件进行图像筛选。\n\n### 热力图\n首先创建一个表格，然后将度量值数据拖至`颜色`区域，并将标记类型更改为`方形`，即可完成热力图的制作。\n\n### 气泡图和词云\n将数值度量放置于`大小`区域，将名称等维度量放置于`标签`或`文本`区域，并将标记类型改为`圆`，即可生成气泡图或词云。\n\n### 饼图\n制作饼图的方法与气泡图类似。将标记类型更改为`饼图`，将数值度量放置于`角度`区域，将名称等维度量放置于`颜色`区域。若需显示百分比或标签，按住`Ctrl`键将相应内容拖至`标签`区域。对于百分比显示，右键点击数值度量（位于`标签`中），选择`快速表计算` -> `合计百分比`，并在`设置格式` -> `数字` -> `百分比`中进行进一步设置。\n\n### 树地图\n树地图的制作与饼图相似。将维度量放置于`颜色`区域，将`角度`区域中的数据度量拖至`大小`区域，并将标记类型更改为`方形`。\n\n### 堆积图\n堆积图适用于对比分析。首先将一个维度量放置于`列`区域，将数据度量放置于`行`区域，然后将另一个维度量放置于`颜色`区域。\n\n#### 编辑表计算 - 数值\n选择`标签`区域中的数据度量，右键点击并选择`编辑表计算`，然后选择`表向下`，即可查看每列不同维度量之间的百分比差异。\n\n#### 编辑表计算 - 数轴\n选择`行`区域中的数据度量，右键点击并依次选择`快速表计算` -> `合计百分比`，然后选择`编辑表计算`并点击`表向下`，以显示相对百分比，使占比变化更加明显。\n\n### 折线图\n选择相应的行列数据，并将标记类型设置为`线`。通过添加筛选器，可以在`分析`菜单中点击`预测`，以获得一定的可信度分析。日期数据通常放置于`列`区域，右键点击可选择离散或连续的年月周日数据，通常使用连续数据进行操作。此外，还可以在`分析`菜单中添加趋势线、盒须图等分析工具。\n\n### 面积图\n选择相应的行列数据，将标记类型设置为`区域`，并将具有区分性的维度量放置于`颜色`区域，即可生成面积图。\n\n### 散点图\n选择相应的行列数据，将标记类型设置为`自动`，并将具有区分性的维度量放置于`颜色`或`详细信息`区域。最后，添加`分析`菜单中的`趋势线`，以完善散点图。根据需求，还可以添加`群集`功能进行分类。\n\n### 直方图\n首先创建一个`数据桶`，然后将其拖至相应的行和列区域。可根据需要添加其他维度量进行区分。\n\n### 地图\n将城市、省份、国家等维度量右键点击并选择`地理角色`，更改为相应的角色。然后双击或使用智能推荐功能，即可生成相应的地理图。后续可加入行列数据和其他筛选条件进行进一步区分。\n\n>在进行`距离`类型的维度量分析时，我们通常会通过右键选择`创建`->`组`的方式，将不同距离区间进行分组。以美化可视化效果并清晰区分各组与门店的距离,从而提升数据解读的直观性和效率。\n\n#### 主键\n在处理大量数据时，为了便于区分和识别，我们通常会创建一个主键，以实现数据的唯一标识。在操作界面的左侧，我们可以看到`查看数据`和`查找字段`等功能选项，而右侧则提供了`创建计算字段`的选项。通过点击`创建计算字段`，我们可以选择合适的维度量来构建一个具有唯一标识的主键。这样，在后续的数据处理过程中，我们便能够更加准确地区分和识别每一条数据。\n\n## BI仪表盘\n\n在精心打造BI仪表盘的过程中，我们首先需要精准定位我们的目标观众，这包括但不限于业务人员、中层管理者、高级管理者以及用人单位等。\n\n每类观众因其职责和需求的不同，对仪表盘的功能和呈现方式有着各自独特的要求：\n\n- 对于业务人员而言，他们更关注与自身业务紧密相关的数据细节，因此仪表盘应提供直观、具体的数据展示，以便他们快速获取所需信息，辅助日常业务决策。\n- 中层管理者则需要一个全面而精炼的总结报告，涵盖各个关键维度的数据。这样的仪表盘应具备多维度分析能力，能够帮助他们从宏观层面把握业务动态，同时也能深入到具体细节，以便进行更为精准的管理和指导。\n- 高级管理者通常关注的是整体战略层面的总结报告。因此，他们的仪表盘应简洁明了，突出关键指标和趋势，以便他们迅速把握全局，做出高层次的决策。\n- 至于用人单位，他们往往需要一个明确的分析主题，且分析的维度越深入、图表越高级，越能满足他们的需求。这类仪表盘应具备强大的数据挖掘和可视化能力，能够提供深入的分析结果，帮助用人单位洞察数据背后的深层次信息。\n\n### 如何明确主题\n\n在明确目标观众后，我们需要进一步确定仪表盘的主题。这一步骤至关重要，因为它直接关系到仪表盘的内容和结构。我们可以通过以下几个步骤来明确主题：\n\n1. **需求调研**：深入了解目标观众的具体需求和痛点，通过访谈、问卷等方式收集信息。这一阶段，我们需要关注观众对数据的具体需求，包括他们希望看到哪些数据、这些数据的重要程度是否相同，以及他们希望通过这些数据解决什么问题。\n2. **数据梳理与分类**：根据调研结果，对涉及的数据进行梳理和分类。这一步骤中，我们需要识别出哪些数据是核心数据，哪些是辅助数据，以及它们之间的关联性。同时，我们还需要评估每类数据的重要程度，确保在后续的仪表盘设计中能够合理分配展示空间。\n3. **关键指标筛选**：在数据梳理的基础上，筛选出与主题紧密相关的关键指标。这些指标应能够全面反映主题的核心内容，并且具有较高的重要程度。通过这一步骤，我们可以确保仪表盘的主题突出，避免信息过载。\n4. **数据整合与分析**：对筛选出的关键指标进行数据整合和深入分析，挖掘数据背后的关联和趋势。这一阶段，我们需要运用各种数据分析工具和方法，对数据进行深入剖析，以便为可视化设计提供有力的支撑。\n5. **可视化设计**：根据分析结果，设计直观、易懂的可视化图表，确保观众能够迅速理解数据含义。在设计过程中，我们需要充分考虑观众的认知习惯和视觉偏好，力求使图表既美观又实用。\n6. **反馈与迭代**：在仪表盘初步完成后，邀请目标观众进行试用，并根据反馈进行迭代优化。这一步骤中，我们需要关注观众的实际使用体验，及时调整和优化仪表盘的设计，确保其能够真正满足观众的需求。\n\n### 最适合数据的图表\n1. 对比：\n  - 绝对值对比——条形图/柱状图\n2. 变化：\n  - 没有累计关系——折线图+柱状图\n  - 有累计关系——面积图/堆积图\n3. 构成：\n  - 对象少于3个——环形图\n  - 对象大于3个——树地图\n4. 分布：\n  - 单变量分布——直方图\n  - 多变量分布——散点图/气泡图\n\n### 度量名称显示\n首先先把一个数据度量放在`文本`里，再拖动一个数据度量放在画布里那个显示的数据上，拖到上面会发现有个`+`或者`智能显示`，这样，就可以发现`行`上面显示一个`度量名称`，下面我们把`度量名称`拖到`列`上，然后把其他所需要的度量值托到左侧的`度量值`里就可以了。\n\n> 其实我们在做仪表盘的时候，会在筛选器里通常加入日期一类的维度量，然后右键点击`应用于工作表`->`使用相关数据源的所有项`，再`显示筛选器`，操作筛选器之后，你会发现，所有的表图都会根据你对筛选器变动，而不是只变动一张图表的。\n\n### 双轴\n\n在Tableau中创建双轴（Dual Axis）可以帮助我们在一个图表中同时显示两个不同的度量，每个度量有自己的轴。这对于比较两个不同量级的数据或者展示两个相关但不同类型的数据非常有用。以下是如何在Tableau中创建双轴的步骤：\n\n1. **准备数据**：确保你的数据源中有至少两个不同的度量（Metrics），这些度量将分别显示在两个轴上。\n2. **创建第一个视图**：将第一个度量拖到`行`或`列`功能区。例如，将`销售额`拖到`行`功能区。\n3. **创建第二个视图**：将第二个度量拖到与第一个度量相同的位置，例如，将`利润`拖到`行`功能区，并且放在`销售额`的旁边。\n4. **转换为双轴**：右键点击第二个度量（例如`利润`），然后选择`双轴`（Dual Axis）。\n5. **调整轴和格式**：你可以通过右键点击轴标签来调整每个轴的格式，比如设置轴的最小值、最大值、刻度间隔等。\n\n双轴的作用主要包括：\n- **比较不同量级的数据**：例如，销售额和利润，这两个数据可能量级不同，通过双轴可以更直观地比较。\n- **展示相关但不同类型的数据**：例如，温度和降雨量，这两个数据虽然相关，但类型不同，通过双轴可以同时展示。\n- **增强可视化效果**：双轴图表可以提供更丰富的信息，帮助用户更好地理解数据之间的关系。\n\n最后我们发现，这个双轴图并不美观，没关系，我们点击第一个视图，将其调整为条形图，并通过调整透明度和条形大小来增强视觉效果。具体操作如下：\n\n1. **选择条形图**：在`标记`卡中，将图表类型从默认的折线图改为条形图。\n2. **调整透明度**：在`标记`卡下找到`颜色`选项，调整透明度滑块，降低条形图的透明度，使其更加柔和，不至于过于突兀。\n3. **缩小条形大小**：在`标记`卡中，找到`大小`选项，适当减小条形的大小，使其与后续的折线图更好地融合，保持图表的整体协调性。\n4. **保持折线图**：对于第二个视图，继续使用折线图，以保持数据的连续性和趋势的清晰展示。\n\n咳，最后的最后，我们再加一个`分析`里的`趋势线`，完美收工。\n\n### 环形图\n\n先做一个饼形图，然后在`行`的上面双击输入`0`，重复两次，可以得到两个图表，然后右键`双轴`，在左侧的下面的`总和(0)`里进行以下操作，首先把所有标签删除，把`颜色`改为纯白，最后把`大小`拉小，就可以得到一个环形图了。\n\n不过这个时候会发现左右两侧会有轴线，我们右键轴线段，点击`显示标题`，就可以把轴线给隐藏掉。\n\n还有一个零值线，我们右键画布，点击`设置格式`，点击字段左边的图标，里面是设置工作表的各种线和刻度的，找到`零值线`，将其设置为`无`，这样我们就可以得到一个干净的环形图了。\n\n> 如果遇到标签的名字不符合我们所期望的，我们可以右键`编辑别名`进行设置。\n\n### 仪表盘布局\n\n常见的仪表盘布局有两种，一种是纵向的，另一种是横向的。\n\n### 仪表盘制作\n\n当你根据数据源做好各类图表的时候，直接在右下侧建立仪表盘，然后把图表拖拽到仪表盘中，进行布局调试和交互设计/记得加上边框哦，这样我们的仪表盘就制作成功了，如下图所示，这是拉姆自己用一个小项目进行的练手：\n![图表1](https://www.qiuxs.cn/sharing-tools/img/read/f294f36b1c59f4262381d6ecb16fd7d9)\n\n","tags":["数据分析"],"categories":["learn"]},{"title":"数据分析之Excel食用指南","url":"/2024/07/02/learn/excel/","content":"\nExcel，作为微软公司开发的一款强大电子表格软件，不仅在数据分析、财务计算、项目管理、统计分析等领域发挥着重要作用，还因其丰富的数据处理和计算功能，以及多样化的图表和图形工具，成为高效管理和分析数据的得力助手。\n\n如下图，是拉姆在系统学习Excel时制作的某店铺报表，其中利用了切片器灵活筛选美团、饿了么的数据情况，这是初级数据分析师所必须掌握的。接下来，我们要介绍关于excel的各类用法，帮助大家胜任数据分析师。\n\n![报表](https://www.qiuxs.cn/sharing-tools/img/read/2775923e3ecc6eeb946155c4b77dfe86)\n\n## 基础篇\n\n首先，为了确保数据的安全性和便于分析计算结果，我们需采取以下步骤：\n1. 创建一个新的工作簿（例如工作簿2），专门用于存储和分析计算结果。\n2. 这样做的好处是可以避免在原始数据工作簿（例如工作簿1）中进行操作时可能导致的数据丢失或错误。\n3. 通过将分析和计算结果独立出来，可以更清晰地管理和查看数据，同时也便于进行后续的数据处理和报告生成。\n\n这种做法有助于保持数据的原貌，同时提供了一个专门的空间来进行数据分析和计算，确保了工作的有序性和高效性。\n\n### 等号的基础使用\n\n在Excel中，使用等号`=`是创建公式或引用其他单元格数据的关键步骤：\n\n1. 打开一个新的工作簿（例如工作簿2），在任意一个单元格中输入等号`=`。\n2. 切换到另一个含有数据的工作簿（例如工作簿1）。\n3. 在工作簿1中选择我们想要引用的数据单元格，然后按回车键。\n4. 会自动回到工作簿2，可以发现所选单元格中显示了工作簿1中选定的数据。\n5. 如果需要引用工作簿1中同一列的连续数据，可以向下拖动工作簿2中单元格的填充柄（即单元格右下角的小方块），这样会自动引用工作簿1中相应列的后续数据。\n\n通过这种方式，可以方便地在不同工作簿之间引用和复制数据。\n\n还有在一个单元格内输入等号`=`，可以选择各类函数，包括求和求平均的常用函数、财务、工程、日期与时间、统计、数学与三角函数等。\n\n### 绝对引用\n在Excel中，锁定引用通常指的是使用绝对引用，这样在复制公式时，引用的单元格不会改变。可以通过以下步骤来锁定引用：\n\n1. **选择单元格**：首先，选择包含我们要锁定引用的公式的单元格。\n2. **编辑公式**：点击公式栏，进入公式编辑模式。\n3. **锁定引用**：在公式中，将光标放在我们要锁定的单元格引用上，然后按下 `F4` 键。每按一次 `F4` 键，引用就会在以下四种模式之间切换：\n   - **绝对引用**：例如 `$A$1`，行和列都被锁定。\n   - **混合引用（锁定行）**：例如 `A$1`，只有行被锁定。\n   - **混合引用（锁定列）**：例如 `$A1`，只有列被锁定。\n   - **相对引用**：例如 `A1`，行和列都没有锁定。\n4. **完成公式**：根据需要调整引用后，按 `Enter` 键完成公式的编辑。\n\n例如，如果我们有一个公式 `=A1`，并且想锁定这个引用，我们可以将光标放在 `A1` 上，然后按 `F4` 键，公式会变成 `=$A$1`。\n\n这样，当我们复制这个公式到其他单元格时，`$A$1` 的引用不会改变，而相对引用会根据新单元格的位置自动调整。\n### 排序\n\n**Ctrl + Shift + L**是排序和筛选功能的快捷键，选中数据，进行排序。\n\n### 快捷键\n\n#### 常用快捷键\n- **Ctrl + C**：复制选中的单元格\n- **Ctrl + V**：粘贴复制的内容\n- **Ctrl + X**：剪切选中的单元格\n- **Ctrl + Z**：撤销上一步操作\n- **Ctrl + Y**：重做上一步操作\n- **Ctrl + S**：保存当前工作簿\n- **Ctrl + P**：打印当前工作表\n- **Ctrl + F**：查找内容\n- **Ctrl + H**：替换内容\n- **Ctrl + A**：全选当前工作表\n- **Ctrl + B**：应用或取消加粗格式\n- **Ctrl + I**：应用或取消斜体格式\n- **Ctrl + U**：应用或取消下划线\n- **Ctrl + K**：插入或编辑超链接\n- **Ctrl + Shift + L**：排序和筛选\n\n#### 导航快捷键\n- **Ctrl + 方向键**：快速移动到数据区域的边缘\n- **Ctrl + Home**：移动到工作表的第一个单元格（A1）\n- **Ctrl + End**：移动到工作表的最后一个单元格（数据区域的右下角）\n- **Page Up**：向上翻页\n- **Page Down**：向下翻页\n- **Alt + Page Up**：向左翻页\n- **Alt + Page Down**：向右翻页\n\n#### 选择和编辑快捷键\n- **Shift + 方向键**：扩展选定区域\n- **Shift + Ctrl + 方向键**：快速选择数据区域\n- **F2**：编辑活动单元格\n- **Enter**：完成单元格输入并移动到下方单元格\n- **Tab**：完成单元格输入并移动到右侧单元格\n- **Esc**：取消单元格或编辑栏中的输入\n\n#### 格式化快捷键\n- **Ctrl + 1**：打开“单元格格式”对话框\n- **Ctrl + Shift + $**：应用货币格式\n- **Ctrl + Shift + %**：应用百分比格式\n- **Ctrl + Shift + #**：应用日期格式\n- **Ctrl + Shift + @**：应用时间格式\n- **Ctrl + Shift + !**：应用数字格式\n\n#### 工作表和窗口管理快捷键\n- **Ctrl + N**：新建工作簿\n- **Ctrl + O**：打开工作簿\n- **Ctrl + W**：关闭当前工作簿\n- **Ctrl + F6**：切换到下一个工作簿\n- **Ctrl + Shift + F6**：切换到上一个工作簿\n- **Alt + F1**：创建当前数据区域的图表\n- **F11**：创建当前数据区域的图表并插入到新工作表中\n\n## 进阶篇\n\n### 数据透视表\n\n在Excel中，数据透视表是一种强大的数据分析工具，能够帮助用户快速汇总、分析和展示大量数据。以下是创建和使用数据透视表的详细步骤：\n1. **创建数据透视表**：\n   - 首先，选择我们想要分析的数据区域。确保数据区域包含标题行，以便数据透视表能够正确识别字段名称。\n   - 然后，点击Excel顶部菜单栏中的“插入”选项卡。\n   - 在“插入”选项卡中，找到并点击最左侧的“数据透视表”按钮。\n   - 在弹出的“创建数据透视表”对话框中，确认数据区域无误，并选择“新工作表”选项，以便将数据透视表放置在一个新的工作表中，保持原始数据的整洁。\n2. **配置数据透视表**：\n   - 创建数据透视表后，Excel会显示一个新的工作表，并在右侧打开“数据透视表字段”窗格。\n   - 在“数据透视表字段”窗格中，我们可以通过拖拽字段到不同的区域（行、列、值、筛选器）来配置数据透视表的布局。\n     - **行区域**：拖拽字段到行区域，数据透视表将按该字段进行行排列。\n     - **列区域**：拖拽字段到列区域，数据透视表将按该字段进行列排列。\n     - **值区域**：拖拽字段到值区域，数据透视表将对该字段进行汇总计算（如求和、计数、平均值、方差等）。\n     - **筛选器区域**：拖拽字段到筛选器区域，可以对数据透视表进行条件筛选，以便查看特定数据子集。\n3. **优化数据透视表**：\n   - 根据需要，我们可以进一步调整数据透视表的格式和布局，例如更改汇总方式、添加计算字段、设置条件格式等。\n   - 数据透视表还支持多种图表类型，我们可以通过点击“数据透视图”按钮，将数据透视表转换为图表，以便更直观地展示数据分析结果。\n4. **插入切片器**：\n   - 切片器是数据透视表的一个交互式组件，可以方便地对数据进行动态筛选。\n   - 要插入切片器，首先确保我们的数据透视表已经创建并配置好。\n   - 然后，点击“插入”选项卡中的“切片器”按钮。\n   - 在弹出的“插入切片器”对话框中，选择我们想要作为筛选条件的字段，然后点击“确定”。\n   - 切片器将以一个小窗口的形式出现在工作表中，我们可以通过点击切片器中的选项来动态筛选数据透视表中的数据。\n5. **刷新数据透视表**：\n   - 如果我们的原始数据发生了变化，需要更新数据透视表以反映最新的数据。\n   - 右键点击数据透视表中的任意单元格，选择“刷新”，或者点击“数据”选项卡中的“刷新”按钮。\n   - 数据透视表将重新计算并显示最新的数据。\n6. **数据透视表的高级功能**：\n   - **计算字段和计算项**：在数据透视表中添加自定义的计算字段或计算项，以进行更复杂的分析。\n   - **数据透视表选项**：通过“数据透视表选项”对话框，可以调整数据透视表的各种设置，如布局和格式、汇总和筛选、显示和打印等。\n   - **数据模型**：对于大型和复杂的数据集，可以使用数据模型来创建多表数据透视表，进行更深入的数据分析。\n\n### 数据透视图表\n\n在Excel中，数据透视图表是一种强大的可视化工具，它与数据透视表紧密结合，能够直观地展示数据的汇总和分析结果。以下是创建和使用数据透视图表的详细步骤：\n\n1. **创建数据透视图表**：\n   - 首先，确保我们已经创建并配置好了一个数据透视表。\n   - 然后，点击Excel顶部菜单栏中的“数据透视表分析”选项卡。\n   - 在“数据透视表分析”选项卡中，找到并点击“数据透视图”按钮。\n   - 在弹出的“插入图表”对话框中，选择我们想要的图表类型，如柱状图、折线图、饼图等。\n   - 点击“确定”，Excel将根据数据透视表的内容自动生成相应的数据透视图表。\n2. **配置数据透视图表**：\n   - 创建数据透视图表后，我们可以通过“数据透视图字段”窗格来配置图表的布局和内容。\n   - 在“数据透视图字段”窗格中，我们可以拖拽字段到不同的区域（轴、图例、值、筛选器）来调整图表的显示方式。\n     - **轴区域**：拖拽字段到轴区域，图表将按该字段进行分类。\n     - **图例区域**：拖拽字段到图例区域，图表将按该字段进行分组。\n     - **值区域**：拖拽字段到值区域，图表将对该字段进行汇总计算（如求和、计数、平均值等）。\n     - **筛选器区域**：拖拽字段到筛选器区域，可以对图表进行条件筛选，以便查看特定数据子集。\n3. **优化数据透视图表**：\n   - 根据需要，我们可以进一步调整数据透视图表的格式和样式，例如更改颜色、添加数据标签、调整图表标题等。\n   - 数据透视图表还支持交互式功能，如通过切片器进行动态筛选，使图表更加灵活和直观。\n4. **插入切片器**：\n   - 切片器是数据透视图表的一个交互式组件，可以方便地对数据进行动态筛选。\n   - 要插入切片器，首先确保我们的数据透视图表已经创建并配置好。\n   - 然后，点击“插入”选项卡中的“切片器”按钮。\n   - 在弹出的“插入切片器”对话框中，选择我们想要作为筛选条件的字段，然后点击“确定”。\n   - 切片器将以一个小窗口的形式出现在工作表中，我们可以通过点击切片器中的选项来动态筛选数据透视图表中的数据。\n\n### VLOOKUP函数\nVLOOKUP函数是Excel中非常常用的函数之一，用于在表格或区域中按行查找数据。它的基本语法如下：\n\n```excel\nVLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])\n```\n\n各参数的含义如下：\n1. **lookup_value**：要查找的值。\n2. **table_array**：包含数据的表格区域。\n3. **col_index_num**：返回值在表格区域中的列号。\n4. **range_lookup**：可选参数，指定查找方式。TRUE（或省略）表示近似匹配，FALSE（或0）表示精确匹配。\n\n#### 示例\n\n假设有以下数据表格：\n\n| 编号 | 姓名 | 年龄 |\n|------|------|------|\n| 1    | 张三 | 25   |\n| 2    | 李四 | 30   |\n| 3    | 王五 | 28   |\n\n如果我们想根据编号查找对应的姓名，可以使用以下公式：\n\n```excel\n=VLOOKUP(2; sheet2！A2:C4; 2; FALSE)\n```\n\n这个公式的含义是：\n- 查找值为2（编号为2的行）。\n- 在A2:C4区域中查找。\n- 返回第2列的值（即姓名）。\n- 使用精确匹配（FALSE）。\n\n因此，结果将返回“李四”。\n\n#### 注意事项\n\n1. **table_array**的第一列必须包含要查找的值（lookup_value）。\n2. **col_index_num**必须大于0且小于等于table_array的总列数。\n3. 使用精确匹配时，确保lookup_value在table_array的第一列中存在，否则会返回错误。\n\nVLOOKUP函数在处理大量数据时非常有用，但也有一些局限性，例如无法从右向左查找。在这种情况下，可以考虑使用INDEX和MATCH函数的组合来实现更灵活的查找。\n\n### IF函数\nIF函数是Excel中非常基础且常用的逻辑函数，用于根据指定的条件返回不同的结果。它的基本语法如下：\n\n```excel\nIF(logical_test; [value_if_true]; [value_if_false])\n```\n\n各参数的含义如下：\n\n1. **logical_test**：要进行测试的逻辑表达式，结果为TRUE或FALSE。\n2. **value_if_true**：如果logical_test为TRUE，则返回的值。\n3. **value_if_false**：如果logical_test为FALSE，则返回的值。\n\n#### 示例\n\n假设有以下数据表格：\n\n| 姓名 | 分数 |\n|------|------|\n| 张三 | 85   |\n| 李四 | 72   |\n| 王五 | 90   |\n\n如果我们想根据分数判断学生是否及格（假设及格分数为60），可以使用以下公式：\n\n```excel\n=IF(B2>=60; \"及格\"; \"不及格\")\n```\n\n这个公式的含义是：\n- 测试B2单元格的值是否大于或等于60。\n- 如果是，返回“及格”。\n- 如果不是，返回“不及格”。\n\n因此，对于张三（分数为85），结果将返回“及格”。\n\n#### 嵌套IF函数\n\nIF函数还可以嵌套使用，以处理更复杂的逻辑判断。例如，如果我们想根据分数划分等级（优秀、良好、及格、不及格），可以使用以下公式：\n\n```excel\n=IF(B2>=90; \"优秀\"; IF(B2>=80; \"良好\"; IF(B2>=60; \"及格\"; \"不及格\")))\n```\n\n这个公式的含义是：\n- 如果B2单元格的值大于或等于90，返回“优秀”。\n- 否则，如果B2单元格的值大于或等于80，返回“良好”。\n- 否则，如果B2单元格的值大于或等于60，返回“及格”。\n- 否则，返回“不及格”。\n\n#### 注意事项\n\n1. **logical_test**必须是一个可以计算为TRUE或FALSE的表达式。\n2. **value_if_true**和**value_if_false**可以是文本、数字、其他公式或函数的结果。\n3. 嵌套IF函数时，确保逻辑清晰且完整，避免出现逻辑错误。\n\nIF函数在处理简单的条件判断时非常方便，但在处理复杂逻辑时，可能需要结合其他函数（如AND、OR、NOT等）来实现更复杂的逻辑判断。\n\n> 通过巧妙地结合这些函数，我们能够实现更为复杂且精准的逻辑判断。\n  完成这一系列逻辑判断后，只需轻轻回车，即可得到我们期望的值。此时，若双击单元格右下角的填充柄，整列便会自动填充上我们期望的结果，从而避免了手动逐个拖动的繁琐操作，大大提升了工作效率。\n\n### SumIF函数\n\n在Excel中，SumIF函数是一个非常实用的工具，它能够根据指定的条件对数据进行求和。这个函数在处理大量数据时尤为高效，能够帮助我们快速筛选并汇总符合特定条件的数据。\n\n#### 基本语法\n\nSumIF函数的基本语法如下：\n\n```excel\n=SUMIF(range; criteria; [sum_range])\n```\n\n- **range**：需要进行条件判断的单元格区域。\n- **criteria**：用于筛选的条件，可以是数字、文本、表达式或单元格引用。\n- **[sum_range]**：实际需要求和的单元格区域。如果省略此参数，则默认对range区域中符合条件的单元格进行求和。\n\n#### 应用示例\n\n假设我们有一个销售数据表，其中A列是产品名称，B列是销售数量。我们希望统计“苹果”产品的总销售数量，可以使用以下公式：\n\n```excel\n=SUMIF(A:A; \"苹果\"; B:B)\n```\n\n在这个例子中，A列是range，\"苹果\"是criteria，B列是sum_range。函数会筛选出A列中所有名为“苹果”的单元格，并对对应的B列单元格进行求和。\n\n#### 进阶技巧\n\n1. **使用通配符**：在criteria中可以使用通配符，如`*`和`?`。例如，`=SUMIF(A:A; \"苹果*\"; B:B)`可以统计所有以“苹果”开头的产品销售数量。\n2. **引用单元格作为条件**：可以将criteria设置为单元格引用，如`=SUMIF(A:A; D1; B:B)`，其中D1单元格中存放着需要筛选的产品名称。\n3. **多条件求和**：如果需要进行多条件求和，可以考虑使用SumIFS函数，它支持多个条件同时进行筛选和求和。\n\n### SumIFS函数\n\n在Excel中，SumIFS函数是一个强大的工具，它允许用户根据多个条件对数据进行求和。与SumIF函数相比，SumIFS函数能够处理更为复杂的筛选需求，使得数据分析和汇总变得更加灵活和精确。\n\n#### 基本语法\n\nSumIFS函数的基本语法如下：\n\n```excel\n=SUMIFS(sum_range; criteria_range1; criteria1; [criteria_range2;  criteria2]; ...)\n```\n\n- **sum_range**：实际需要求和的单元格区域。\n- **criteria_range1**：第一个条件判断的单元格区域。\n- **criteria1**：第一个用于筛选的条件。\n- **[criteria_range2, criteria2]**：可选参数，用于添加更多的条件判断区域和条件。\n\n#### 应用示例\n\n假设我们有一个销售数据表，其中A列是产品名称，B列是销售数量，C列是销售地区。我们希望统计“苹果”产品在“北京”地区的总销售数量，可以使用以下公式：\n\n```excel\n=SUMIFS(B:B; A:A; \"苹果\"; C:C; \"北京\")\n```\n\n在这个例子中，B列是sum_range，A列是第一个criteria_range，\"苹果\"是第一个criteria，C列是第二个criteria_range，\"北京\"是第二个criteria。函数会筛选出A列中所有名为“苹果”且C列中地区为“北京”的单元格，并对对应的B列单元格进行求和。\n\n#### 进阶技巧\n\n1. **使用通配符**：在criteria中可以使用通配符，如`*`和`?`。例如，`=SUMIFS(B:B; A:A; \"苹果*\"; C:C; \"北京\")`可以统计所有以“苹果”开头的产品在“北京”地区的销售数量。\n2. **引用单元格作为条件**：可以将criteria设置为单元格引用，如`=SUMIFS(B:B; A:A; D1; C:C; E1)`，其中D1单元格中存放着需要筛选的产品名称，E1单元格中存放着需要筛选的地区。\n3. **日期和数值条件**：SumIFS函数也支持日期和数值条件。例如，`=SUMIFS(B:B; A:A; \"苹果\"; C:C, \"北京\"; D:D; \">2023-01-01\")`可以统计“苹果”产品在“北京”地区且销售日期在2023年1月1日之后的销售数量。\n\n### 同比和环比\n\n下面，让我们了解一下常用的数据比较方法：同比和环比，这两者主要用于分析时间序列数据的变化情况。它们在经济分析、市场研究、财务报告等领域有着广泛的应用。\n\n#### 同比（Year-on-Year）\n\n同比是指将某一时期的数据与上一年同一时期的数据进行比较。这种比较方法主要用于观察长期趋势和季节性因素的影响。\n\n**同比公式：同比增减率 = (本期数值 - 同期数值) / 同期数值 * 100%**\n\n\n例如，如果2023年第二季度的销售额为100万元，而2022年第二季度的销售额为80万元，那么同比增减率为：**同比增减率 = (100 - 80) / 80 * 100% = 25%**\n\n\n这意味着2023年第二季度的销售额比2022年第二季度增长了25%。\n\n#### 环比（Month-on-Month或 Quarter-on-Quarter）\n\n环比是指将某一时期的数据与上一个相邻时期的数据进行比较。这种比较方法主要用于观察短期内的变化趋势，尤其是季节性因素和市场波动的影响。\n**环比公式：环比增减率 = (本期数值 - 上期数值) / 上期数值 * 100%**\n\n例如，如果2023年第二季度的销售额为100万元，而2023年第一季度的销售额为90万元，那么环比增减率为：**环比增减率 = (100 - 90) / 90 * 100% = 11.11%**\n这意味着2023年第二季度的销售额比2023年第一季度增长了11.11%。\n\n- **同比**：比较同一时期不同年份的数据，用于观察长期趋势和季节性因素。\n- **环比**：比较相邻时期的数据，用于观察短期内的变化趋势和市场波动。\n\n### 数据验证\n\n在Excel中，数据验证是一项强大的功能，它允许用户设定特定的规则来限制输入到单元格中的数据类型和范围。这不仅有助于确保数据的准确性和一致性，还能提升工作表的整体质量。以下是一些关于Excel数据验证功能的详细介绍和使用技巧（在业务中常用作切片器功能）：\n\n#### 1. 设置数据验证规则\n\n- **数据类型限制**：我们可以选择允许输入的数据类型，如整数、小数、日期、时间等。\n- **范围限制**：通过设定最小值和最大值，可以限制输入的数据必须在某个特定范围内。\n- **列表限制**：创建一个下拉列表，用户只能从预定义的选项中选择。\n- **自定义公式**：使用公式来定义更复杂的验证规则，如确保输入的数据符合特定的业务逻辑。\n\n#### 2. 数据验证的提示信息\n\n- **输入提示**：当用户选择一个设置了数据验证的单元格时，可以显示输入提示信息，帮助用户理解应该输入什么样的数据。\n- **错误警告**：如果用户输入的数据不符合设定的规则，可以显示错误警告信息，并提供重试、取消或帮助选项。\n\n#### 3. 数据验证的高级应用\n\n- **跨单元格验证**：可以设置规则来验证多个单元格之间的关系，例如确保一个单元格的值总是大于另一个单元格的值。\n- **动态数据验证**：结合公式和函数，可以使数据验证规则根据其他单元格的内容动态变化。\n\n#### 4. 数据验证的维护和更新\n\n- **复制数据验证**：可以通过复制和粘贴的方式，将数据验证规则应用到其他单元格或工作表中。\n- **更新验证规则**：当业务需求变化时，可以方便地更新数据验证规则，以适应新的数据要求。\n\n### 迷你图\n\n迷你图（Sparklines）是Excel中一种简洁而强大的数据可视化工具，它能够在单个单元格内展示数据的趋势和波动，非常适合用于展示时间序列数据或对比分析。以下是对Excel迷你图功能的详细介绍和使用技巧：\n\n#### 1. 迷你图的类型\n\n- **折线图**：展示数据随时间的变化趋势，适用于时间序列数据。\n- **柱形图**：通过柱子的高低来展示数据的对比，适用于比较不同类别的数据。\n- **盈亏图**：通过不同的颜色来区分正负值，适用于展示盈亏或正负变化。\n\n#### 2. 创建迷你图\n\n- **选择数据**：首先，选择我们要创建迷你图的数据范围。\n- **插入迷你图**：在“插入”选项卡中，点击“迷你图”组中的相应图表类型（折线图、柱形图或盈亏图）。\n- **设置位置**：在弹出的对话框中，指定迷你图的位置范围，即我们希望迷你图显示的单元格。\n- **确认创建**：点击“确定”，迷你图就会出现在指定的单元格中。\n\n#### 3. 迷你图的格式设置\n\n- **样式调整**：通过“设计”选项卡中的样式库，可以快速更改迷你图的颜色和样式。\n- **标记设置**：可以添加高点、低点、首点、末点等标记，以突出显示数据中的关键点。\n- **轴线设置**：对于折线图，可以显示或隐藏轴线，以更好地展示数据趋势。\n\n#### 4. 迷你图的高级应用\n\n- **动态迷你图**：结合数据验证和条件格式，可以创建动态更新的迷你图，实时反映数据变化。\n- **组合迷你图**：在同一单元格内组合不同类型的迷你图，以展示更丰富的数据信息。\n\n#### 5. 迷你图的维护和更新\n\n- **更新数据**：当源数据发生变化时，迷你图会自动更新，保持数据的实时性。\n- **复制迷你图**：可以通过复制和粘贴的方式，将迷你图应用到其他单元格或工作表中。\n\n通过合理使用Excel的迷你图功能，可以在有限的单元格空间内直观地展示数据趋势和对比，提升数据分析的效率和效果。无论是制作报告、仪表盘还是进行日常的数据监控，迷你图都是一种非常实用的工具。\n\n### 条件格式\n\n条件格式是Excel中一项强大的数据可视化工具，它允许用户根据特定的条件自动格式化单元格，从而使数据分析更加直观和高效。以下是对Excel条件格式功能的详细介绍和使用技巧，包括数据条和突出显示单元格规则的应用。\n\n#### 1. 数据条的应用\n\n- **业务进度百分比显示**：通过数据条，可以在单元格内直观地展示业务进度的百分比。数据条的长度与百分比数据成正比，使得进度一目了然。\n- **设置数据条**：选择包含百分比数据的单元格范围，然后在“开始”选项卡中点击“条件格式”，选择“数据条”并选择合适的样式。\n- **高级设置**：在“条件格式规则管理器”中，可以设置数据条的最小值和最大值，以及负值的显示方式，确保数据条的准确性和美观性。\n\n#### 2. 突出显示单元格规则\n\n- **特定值的突出显示**：可以设置规则，使得包含特定值（如关键绩效指标、异常值等）的单元格自动以不同的颜色或格式突出显示。\n- **条件设置**：在“开始”选项卡中点击“条件格式”，选择“突出显示单元格规则”，然后选择“等于”、“大于”、“小于”等条件，并设置相应的格式。\n- **自定义规则**：可以使用公式创建自定义的突出显示规则，以满足更复杂的格式化需求。\n\n#### 3. 条件格式的高级应用\n\n- **数据条与突出显示规则的结合**：可以在同一数据范围内同时应用数据条和突出显示规则，以提供更丰富的数据可视化效果。\n- **动态更新**：当数据发生变化时，条件格式会自动更新，保持数据的实时性和准确性。\n- **复制和应用规则**：可以通过复制条件格式规则，将相同的格式化效果应用到其他单元格或工作表中。\n\n#### 4. 条件格式的维护和更新\n\n- **管理规则**：在“条件格式规则管理器”中，可以查看、编辑和删除已设置的条件格式规则。\n- **优先级调整**：可以调整规则的优先级，确保重要的规则优先执行。\n\n通过合理使用Excel的条件格式功能，可以在单元格内直观地展示业务进度百分比，并突出显示关键数据，提升数据的可读性和分析效率。无论是进行日常的业务监控，还是制作专业的报告和仪表盘，条件格式都是一种非常实用的工具。\n\n## excel自动化：宏与VBA\n\n### 宏\n\n**宏** 是一组预先录制的命令和操作，目的是自动化重复性任务，从而节省时间并减少人为错误。在Excel中，宏通过录制或编写VBA（Visual Basic for Applications）代码实现。以下是关于宏操作的详细介绍：\n\n#### 1. 录制宏\n\n录制宏是创建宏的一种简单方法，无需编写任何代码。通过录制宏，你可以自动执行一系列手动操作。以下是录制宏的步骤：\n\n1. **打开宏录制工具**\n   - 在Excel中，转到“开发工具”选项卡。如果“开发工具”选项卡未显示，可以通过“文件”->“选项”->“自定义功能区”来启用。\n   - 点击“录制宏”按钮。\n2. **设置宏参数**\n   - 弹出对话框中，输入宏的名称（必须以字母开头，不得包含空格）。\n   - 选择宏的存储位置，可以选择存储在当前工作簿、新工作簿或个人宏工作簿中。\n   - 输入描述，便于将来识别宏的用途。\n3. **执行操作**\n   - 录制开始后，所有的操作都会被记录下来。可以执行希望自动化的步骤，如格式化单元格、输入数据、创建图表等。\n   - 完成所有操作后，点击“停止录制”按钮。\n4. **运行宏**\n   - 可以通过“开发工具”选项卡中的“宏”按钮来查看和运行录制的宏。\n\n#### 2. 编辑宏\n\n录制的宏生成的VBA代码可以在VBA编辑器中进行编辑和修改。以下是编辑宏的步骤：\n1. **打开VBA编辑器**\n   - 在“开发工具”选项卡中，点击“Visual Basic”按钮，打开VBA编辑器。\n2. **查找录制的宏**\n   - 在项目资源管理器中，找到包含宏的模块，双击模块名称打开代码窗口。\n3. **编辑VBA代码**\n   - 可以直接在代码窗口中修改录制的VBA代码。例如，修改单元格格式、添加新的操作等。\n\n### VBA\n\n**VBA（Visual Basic for Applications）** 是一种事件驱动的编程语言，用于编写宏和自动化任务。VBA提供了比录制宏更强大的功能，可以实现复杂的自动化和定制化操作。以下是使用VBA的一些基本知识和工具：\n\n#### 1. 打开VBA编辑器\n- 在Excel中，转到“开发工具”选项卡，点击“Visual Basic”按钮，打开VBA编辑器。\n\n#### 2. VBA编辑器界面\n\nVBA编辑器由以下几个部分组成：\n- **项目资源管理器**：显示所有打开的工作簿及其包含的工作表、模块等。\n- **属性窗口**：显示所选对象的属性。\n- **代码窗口**：编写和编辑VBA代码的地方。\n\n#### 3. 创建模块\n\n模块是存放VBA代码的地方。以下是创建模块的步骤：\n1. 在项目资源管理器中，右键单击工作簿名称。\n2. 选择“插入”->“模块”，创建一个新的代码模块。\n\n#### 4. 编写VBA代码\n\n在模块中编写VBA代码。例如，创建一个简单的宏来显示消息框：\n```vba\nSub ShowMessage()\n    MsgBox \"Hello, Excel VBA!\"\nEnd Sub\n```\n\n#### 5. 运行VBA代码\n\n在VBA编辑器中，点击“运行”按钮（绿色三角形）或按下F5键来运行代码。\n\n#### 6. 调试VBA代码\n\n调试是发现和修正错误的重要步骤。VBA编辑器提供了多种调试工具：\n- **断点**：按F9键设置断点，在代码执行到断点时暂停。\n- **单步执行**：按F8键逐行执行代码，便于观察每一步的执行情况。\n- **立即窗口**：可以在代码运行时输入命令，查看变量值或执行VBA语句。\n\n#### 7. 示例宏与VBA代码\n\n以下是一些常用的宏和VBA代码示例：\n\n1. **自动化格式化**\n   - 录制一个宏，将选定单元格的字体设置为粗体，颜色设置为红色。\n2. **批量处理数据**\n   - 编写VBA代码，将工作表中A列中的所有空单元格填充为“NA”：\n```vba\nSub FillEmptyCells()\n    Dim cell As Range\n    For Each cell In Range(\"A1:A100\")\n        If IsEmpty(cell) Then\n            cell.Value = \"NA\"\n        End If\n    Next cell\nEnd Sub\n```\n3. **生成报告**\n   - 录制一个宏，将数据表中的数据复制到新的工作表，并插入图表。\n\n### 末梢\n\n通过宏和VBA，Excel用户可以极大地提高工作效率，自动化繁琐的任务。录制宏适用于简单的自动化需求，而VBA则提供了更强大和灵活的功能，适用于复杂的自动化和定制化操作。掌握这些工具，愿我们都胜任数据分析师，找到合适的工作，拿到满意的薪资。","tags":["数据分析"],"categories":["learn"]},{"title":"数据分析食用指南2-优化与连接","url":"/2024/06/15/learn/data5/","content":"## 优化算法\n\n曾经有一次面试的时候，HR问拉姆优化算法都是有哪些，拉姆很懵，因为拉姆下意识以为这是算法岗的内容，就磕磕绊绊得回答的很糟糕。\n\n现在了解一下，其实数据分析和数据挖掘中常用的优化算法是有很多的，这些算法可以帮助我们找到最优或近似最优的解决方案。\n\n以下是一些常见的优化算法及其应用场景：\n\n### 梯度下降（Gradient Descent）\n梯度下降是一种迭代优化算法，用于最小化一个函数。在机器学习中，它通常用于最小化损失函数，以找到模型的最佳参数。\n\n**应用场景**：线性回归、逻辑回归、神经网络等模型的参数优化。\n\n### 随机梯度下降（Stochastic Gradient Descent, SGD）\n随机梯度下降是梯度下降的一种变体，它在每次迭代中使用一个随机样本的梯度来更新参数，这使得算法更快，但可能会导致收敛路径更加震荡。\n\n**应用场景**：大规模数据集的模型训练，如图像识别、自然语言处理等。\n\n### 牛顿法（Newton's Method）\n牛顿法是一种二阶优化算法，它使用目标函数的二阶导数（海森矩阵）来寻找最小值。牛顿法通常比梯度下降更快收敛，但计算海森矩阵及其逆矩阵可能非常耗时。\n\n**应用场景**：数据维度较低的优化问题，如支持向量机（SVM）的参数优化。\n\n### 拟牛顿法（Quasi-Newton Methods）\n拟牛顿法是一类使用近似海森矩阵来代替精确海森矩阵的优化算法，其中最著名的是BFGS和L-BFGS。这些方法在保持牛顿法快速收敛特性的同时，避免了直接计算海森矩阵。\n\n**应用场景**：中等规模数据集的模型训练，如逻辑回归、神经网络等。\n\n### 坐标下降（Coordinate Descent）\n坐标下降是一种迭代算法，它在每次迭代中只优化一个参数，而保持其他参数不变。这种方法在参数之间相互独立或近似独立时非常有效。\n\n**应用场景**：LASSO回归、弹性网络等正则化模型的参数优化。\n\n### 遗传算法（Genetic Algorithms）\n遗传算法是一种模拟自然选择和遗传机制的搜索启发式算法。它通过模拟生物进化过程来寻找问题的最优解。\n\n**应用场景**：复杂的优化问题，如调度问题、旅行商问题（TSP）等。\n\n### 粒子群优化（Particle Swarm Optimization, PSO）\n粒子群优化是一种基于群体智能的优化算法，它模拟鸟群或鱼群的社会行为来寻找最优解。\n\n**应用场景**：多目标优化问题，如工程设计、机器人路径规划等。\n\n### 模拟退火（Simulated Annealing）\n模拟退火是一种概率性优化算法，它通过模拟固体退火过程来寻找全局最优解。算法在搜索过程中允许接受劣解，以避免陷入局部最优。\n\n**应用场景**：组合优化问题，如旅行商问题、调度问题等。\n\n### 蚁群算法（Ant Colony Optimization, ACO）\n蚁群算法是一种模拟蚂蚁觅食行为的优化算法，它通过模拟蚂蚁在寻找食物过程中留下的信息素来解决优化问题。\n\n**应用场景**：路径规划、网络路由等优化问题。\n\n### 支持向量机（Support Vector Machines, SVM）\n虽然SVM本身不是一种优化算法，但它使用了一种称为序列最小优化（Sequential Minimal Optimization, SMO）的算法来解决其优化问题。\n\n**应用场景**：分类和回归问题，如文本分类、图像识别等。\n\n上面算是对优化算法的一个小介绍。\n\n## 数据连接\n\n数据连接（Data Joining 或 Data Merging）是数据分析和处理中的一项核心操作，它将两个或多个数据集合并在一起，以便进行更深入的分析。这个过程通常基于一个或多个共同的键（key），这些键在不同的数据集中对应相同的实体或观测值。\n\n我们将介绍常见的数据连接类型，并通过Python的pandas库展示如何实现这些连接。\n\n## 数据连接类型\n\n### 内连接（Inner Join）\n内连接只保留两个数据集中键值匹配的记录。换句话说，只有当两个数据集中的键值完全匹配时，这些记录才会被包含在结果中。\n\n**示例场景**：假设你有两个数据集，一个包含客户信息（如客户ID、姓名、地址），另一个包含客户的购买记录（如客户ID、购买日期、购买金额）。通过内连接这两个数据集，你可以得到一个包含所有客户购买信息的新数据集，其中只包含那些在两个数据集中都有记录的客户。\n\n### 左连接（Left Join）或左外连接（Left Outer Join）\n左连接保留左边的数据集中的所有记录，以及右边数据集中与左边数据集键值匹配的记录。如果右边数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。\n\n**示例场景**：在上述客户和购买记录的例子中，使用左连接可以得到一个包含所有客户信息及其购买记录的数据集，即使某些客户没有购买记录。\n\n### 右连接（Right Join）或右外连接（Right Outer Join）\n右连接保留右边的数据集中的所有记录，以及左边数据集中与右边数据集键值匹配的记录。如果左边数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。\n\n**示例场景**：在客户和购买记录的例子中，使用右连接可以得到一个包含所有购买记录及其对应客户信息的数据集，即使某些购买记录没有对应的客户信息。\n\n### 全连接（Full Join）或全外连接（Full Outer Join）\n全连接保留两个数据集中的所有记录，无论它们是否在另一个数据集中有匹配的记录。如果一个数据集中没有匹配的记录，则结果中对应的字段为空（或缺失值）。\n\n**示例场景**：在客户和购买记录的例子中，使用全连接可以得到一个包含所有客户信息和购买记录的数据集，无论它们是否相互匹配。\n\n### 交叉连接（Cross Join）或笛卡尔积（Cartesian Product）\n交叉连接将两个数据集中的每一行与另一个数据集中的每一行进行配对，生成所有可能的组合。这种连接不依赖于任何键值匹配。\n\n**示例场景**：假设你有两个数据集，一个包含产品列表，另一个包含促销活动。通过交叉连接这两个数据集，你可以得到一个包含所有可能的产品和促销组合的数据集。\n\n### 自连接（Self Join）\n自连接是将数据集与其自身连接的操作，通常用于处理层次结构数据或需要比较数据集中不同记录的情况。\n\n**示例场景**：假设你有一个员工数据集，其中包含员工ID、姓名和经理ID。通过自连接，你可以创建一个包含所有员工及其直接经理信息的数据集。\n\n在实际操作中，数据连接可以通过多种编程语言和工具来实现，如SQL、Python（使用pandas库）、R等。\n\n## Python实现\n\n下面我们将使用Python的pandas库来演示这些连接类型。首先，我们需要创建示例数据集：\n\n```python\nimport pandas as pd\n\n# 创建第一个数据集：客户信息\ndata1 = {'CustomerID': [1, 2, 3, 4, 5],\n         'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],\n         'Address': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix']}\ndf1 = pd.DataFrame(data1)\n\n# 创建第二个数据集：购买记录\ndata2 = {'CustomerID': [3, 4, 6, 7],\n         'PurchaseDate': ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04'],\n         'Amount': [100, 200, 300, 400]}\ndf2 = pd.DataFrame(data2)\n\nprint(\"客户信息数据集:\")\nprint(df1)\nprint(\"\\n购买记录数据集:\")\nprint(df2)\n```\n\n现在，让我们展示如何实现不同类型的连接：\n\n### 内连接\n\n```python\ninner_join = pd.merge(df1, df2, on='CustomerID', how='inner')\nprint(\"\\n内连接结果:\")\nprint(inner_join)\n```\n\n### 左连接\n\n```python\nleft_join = pd.merge(df1, df2, on='CustomerID', how='left')\nprint(\"\\n左连接结果:\")\nprint(left_join)\n```\n\n### 右连接\n\n```python\nright_join = pd.merge(df1, df2, on='CustomerID', how='right')\nprint(\"\\n右连接结果:\")\nprint(right_join)\n```\n\n### 全连接\n\n```python\nfull_join = pd.merge(df1, df2, on='CustomerID', how='outer')\nprint(\"\\n全连接结果:\")\nprint(full_join)\n```\n\n### 交叉连接\n\n```python\ncross_join = pd.merge(df1, df2, how='cross')\nprint(\"\\n交叉连接结果:\")\nprint(cross_join)\n```\n\n### 自连接\n\n自连接通常用于同一个数据集内部的不同记录之间的连接。以下是一个简单的自连接示例：\n\n```python\n# 创建一个简单的员工数据集\ndata3 = {'EmployeeID': [1, 2, 3, 4],\n         'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n         'ManagerID': [None, 1, 1, 2]}\ndf3 = pd.DataFrame(data3)\n\n# 使用自连接\nself_join = pd.merge(df3, df3, left_on='ManagerID', right_on='EmployeeID', suffixes=('_Employee', '_Manager'))\nprint(\"\\n自连接结果:\")\nprint(self_join[['EmployeeID_Employee', 'Name_Employee', 'Name_Manager']])\n```\n","tags":["数据分析"],"categories":["learn"]},{"title":"回归与分类","url":"/2024/06/05/learn/data3/","content":"\n回归（Regression）和分类（Classification）是机器学习中两种常见的监督学习任务，它们在目标和方法上有所不同。\n\n## 回归（Regression）\n\n回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测一个具体的数值，如房价、股票价格、温度等。\n\n**关键特点：**\n- **目标变量**：连续值。\n- **输出**：一个数值。\n- **例子**：线性回归、多项式回归、决策树回归、随机森林回归等。\n\n**应用场景**：\n- 房价预测\n- 销售预测\n- 股票价格预测\n\n### 线性回归\n线性回归（Linear Regression）是统计学和机器学习中最基础的预测建模技术之一，它用于建立和估计一个变量（因变量）与一个或多个变量（自变量）之间的线性关系。线性回归假设因变量和自变量之间的关系可以用一条直线（在一维情况下）或一个超平面（在多维情况下）来近似表示。\n\n### 基本概念\n**因变量（Dependent Variable）**：我们试图预测的变量，通常表示为 $y$。\n**自变量（Independent Variables）**：用于预测因变量的变量，通常表示为 $x_1, x_2, \\ldots, x_n$。\n**参数（Parameters）**：模型中的系数，用于确定自变量和因变量之间的关系，通常表示为 $\\beta_0, \\beta_1, \\ldots, \\beta_n$。其中 $\\beta_0$ 是截距，$\\beta_1, \\ldots, \\beta_n$ 是各自变量的系数。\n\n### 模型表示\n在一元线性回归（只有一个自变量）中，模型可以表示为：\n$y = \\beta_0 + \\beta_1x + \\epsilon$\n在多元线性回归（有多个自变量）中，模型可以表示为：\n$y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + ... + \\beta_nx_n + \\epsilon$\n其中$\\epsilon$ 是误差项，表示模型未能捕捉到的随机变异。\n### 参数估计\n线性回归模型的参数通常使用最小二乘法（Least Squares Method）来估计，目的是找到使所有观测值的残差平方和（RSS，Residual Sum of Squares）最小的参数值。数学上，这可以通过求解最小化问题来实现：\n$$\\min_{\\beta_0, \\beta_1, ..., \\beta_n} \\sum_{i=1}^{N} (y_i - (\\beta_0 + \\beta_1x_{i1} + \\beta_2x_{i2} + ... + \\beta_nx_{in}))^2$$\n\n### 假设\n\n线性回归模型基于几个关键假设：\n1. **线性关系**：因变量和自变量之间的关系是线性的。\n2. **独立性**：观测值之间是相互独立的。\n3. **同方差性**：误差项的方差对于所有观测值都是相同的。\n4. **无自相关**：误差项之间不存在自相关（即序列相关）。\n5. **正态性**：误差项是正态分布的。\n\n### 评估指标\n\n- **均方误差（MSE）**：衡量预测值和实际值之间差异的平均平方值。\n- **决定系数（R-squared）**：表示模型解释的数据变异性的比例。\n\n### 应用\n\n线性回归广泛应用于各种领域，包括经济学、金融学、社会科学、物理学等，用于预测和分析变量之间的关系。\n\n### 注意事项\n\n- 线性回归对异常值敏感。\n- 需要满足模型的假设条件。\n- 在处理非线性关系时，可能需要使用多项式回归或其他非线性模型。\n\n线性回归虽然简单，但它是理解更复杂模型的基础，并且在许多实际问题中仍然非常有效。 \n\n## 分类（Classification）\n\n分类是另一种预测模型，它涉及将数据分到预定义的类别或标签中。分类模型通常用于识别模式，并根据这些模式对数据进行分类。\n\n**关键特点：**\n- **目标变量**：离散值，通常是预定义的类别。\n- **输出**：一个类别或标签。\n- **例子**：逻辑回归、决策树分类、支持向量机（SVM）、随机森林分类、神经网络等。\n\n**应用场景**：\n- 垃圾邮件检测\n- 图像识别\n- 信用评分\n\n## 主要区别\n\n- **目标变量的类型**：回归分析处理连续数值，而分类处理离散的类别。\n- **输出的性质**：回归输出一个数值，分类输出一个类别。\n- **损失函数**：回归通常使用均方误差（MSE）等，分类则使用交叉熵损失等。\n\n### 逻辑回归\n逻辑回归（Logistic Regression）是一种广泛使用的统计学习方法，用于解决分类问题。尽管它的名字中包含“回归”，但实际上它主要用于分类任务，特别是二分类问题。逻辑回归通过使用逻辑函数（也称为Sigmoid函数）来估计概率，从而将线性回归的输出转换为0到1之间的概率值，这个概率值可以用来预测样本属于某一类别的概率。\n\n### 基本概念\n\n- **因变量（Dependent Variable）**：通常是二元的，表示为$y$，取值为0或1。\n- **自变量（Independent Variables）**：用于预测因变量的变量，表示为$x_1, x_2, ..., x_n$。\n- **参数（Parameters）**：模型中的系数，用于确定自变量和因变量之间的关系，表示为$\\beta_0, \\beta_1, ..., \\beta_n$。\n\n### 模型表示\n\n逻辑回归模型可以表示为：\n$$P(y=1|X) = \\frac{1}{1 + e^{-(\\beta_0 + \\beta_1x_1 + \\beta_2x_2 + ... + \\beta_nx_n)}}$$\n其中$P(y=1|X)$是给定自变量$X$时，因变量$y$取值为1的概率。逻辑函数（Sigmoid函数）定义为：\n$$\\sigma(z) = \\frac{1}{1 + e^{-z}}$$\n\n其中$z = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + ... + \\beta_nx_n$。\n\n### 参数估计\n\n逻辑回归的参数通常使用最大似然估计（Maximum Likelihood Estimation, MLE）来估计。目标是找到最大化观测数据似然函数的参数值。数学上，这可以通过求解优化问题来实现，通常使用梯度下降或其变体（如随机梯度下降、牛顿法等）来找到最优参数。\n\n### 假设\n\n逻辑回归模型基于以下假设：\n1. **线性关系**：自变量和因变量之间的关系可以通过线性组合来近似。\n2. **概率输出**：模型的输出是样本属于正类的概率。\n\n### 评估指标\n\n- **准确率（Accuracy）**：正确预测的比例。\n- **混淆矩阵（Confusion Matrix）**：显示真正例（True Positives）、假正例（False Positives）、真反例（True Negatives）和假反例（False Negatives）的数量。\n- **精确率（Precision）**：真正例占所有预测为正例的比例。\n- **召回率（Recall）**：真正例占所有实际正例的比例。\n- **F1分数（F1 Score）**：精确率和召回率的调和平均。\n\n### 应用\n\n逻辑回归广泛应用于各种领域，包括医学、金融、社会科学等，用于预测和分类任务，如信用评分、疾病诊断、垃圾邮件检测等。\n\n### 注意事项\n\n- 逻辑回归对自变量的缩放和异常值敏感。\n- 它假设数据是线性可分的，这在某些情况下可能不成立。\n- 逻辑回归不直接提供概率的置信区间。\n\n逻辑回归是一种强大且易于实现的分类算法，尤其适合于二分类问题，并且在实际应用中非常受欢迎。\n\n## 小总结\n\n回归和分类是机器学习中的基本任务，它们各自适用于不同类型的问题。选择哪种方法取决于问题的性质和所需解决的具体任务。在实际应用中，这两种方法都有广泛的应用，并且经常需要根据数据的特点和业务需求来选择合适的模型。\n","tags":["数据分析"],"categories":["learn"]},{"title":"GPT食用分享","url":"/2024/06/01/Tool/ChatGPTfree/","content":"## GPT4\n\n> 注意，套壳网站注册的时候，千万别用自己的qq邮箱还有手机号，密码记得随机生成，容易被开盒（亲身吃瓜）\n\n### `官网`:\n> 1. *openAI*⭐⭐⭐（什么实力就不用说了吧）：https://chat.openai.com/\n\n> 2. *Claude*⭐⭐⭐（唯一一家在正面上能力比OpenAI强的）：https://claude.ai/\n\n> 3. Copilot⭐⭐⭐（最早联网的AI，微软的心头宝）：https://copilot.microsoft.com/\n\n> 4. *DeepSeek*（写报告不错，就是敏感词太严格）：https://chat.deepseek.com/\n\n> 5. 智谱清言（国内的免费挡NO.1了几乎）：https://chatglm.cn/\n\n> 6. Kimi（除了上传文档多之外，逻辑能力有点堪忧）：https://kimi.moonshot.cn/\n\n> 7. 通义千问（没细用过，不太清楚）：https://tongyi.aliyun.com/qianwen/\n\n> 8. 讯飞星火（没细用过，不太清楚）：https://xinghuo.xfyun.cn/\n\n> 9. 文心一言（嗯...3.5一言难尽）：https://yiyan.baidu.com/\n\n> 10. 豆包（逻辑能力还可以）：https://www.doubao.com/chat/\n\n> 11. 万知AI（恩...一般）：https://www.wanzhi.com/\n\n> 12. 复仇者联盟AI（整合了国内的所有的AI）：https://bot.360.com/\n\n### `套壳`: 有删除线的是已失效的\n\n**注意，有`国内直连`标志的，如果用手机或者电脑访问不成功，基本上是你所在地区的运营商不支持这个网址，换一个运营商或者借助魔法，就可以访问了(也有概率是挂了)。**\n\n1. Poe（每日10次4o）：https://poe.com/\n\n2. Coze（现在不推荐了）：https://www.coze.com/\n\n3. 慧AI（`国内直连`、每日150次4o）：https://huiai.io/signup/?code=2926\n\n4. Arena（`国内直连`、免费，拥挤）：https://arena.lmsys.org/\n\n5. ChatGate（`国内直连`、所有模型可用但不能上传文件）：https://chatgate.ai/\n\n6. ChatData（`国内直连`、免费可用所有模型，不稳定）：https://chat.chatdata.online/chat\n\n7. *Aicnn*（`国内直连`、联系拉姆）：http://aicnn.cn/loginPage?aff=zypTghoVaW\n\n<!-- *Aicnn*：http://www.aicnn.cn/oaifree -->\n\n8. ~~套壳1(不推荐）~~： https://oai.aitopk.com/ \n\n9. ~~套壳2（可用4o）~~： https://share.bpj666.xyz/\n\n10. 套壳3（`国内直连`、可体验4）：https://jvip.ccaiai.com/#/chat/1002\n\n11. 套壳4（免费公共账户-4）：https://share.wendaalpha.net/\n\n12. ~~套壳5（可用4o）~~：https://jialeopen.love/chat/#/\n\n13. WRTN（免费4，韩国）：https://wrtn.ai/\n\n14. Dify（免费Claude）：https://cloud.dify.ai/\n\n15. Merlin（`国内直连`、每日4o四次）：https://www.getmerlin.in/zh-CN/chat\n\n16. LibreChat（`国内直连`、慈善家，免费）：https://get.multibotapp.com/c/new\n\n17. OhMyGpt（不推荐）：https://www.ohmygpt.com/\n\n18. Free For Ai（`国内直连`、慈善家，Open WebUI）：https://ffa.chat/\n\n19. ChandlerAi（`国内直连`、每月四十次）:https://mychandler.bet/\n<!-- 20. 套壳6（50次3小时4o）：https://share.sydney-ai.com/ -->\n20. 套壳6（`国内直连`、50次3小时4o）：https://share.tu-zi.com/\n\n21. 套壳7（`国内直连`、一日五次4o）：https://gpt4o.so/zh-CN/app\n\n22. 套壳8（`国内直连`、所有模型免费，Open WebUI）：https://chat.sorapi.dev/ \n\n23. 套壳9（`国内直连`、领悟AI，免费4o）：https://www.chatgpt.sh/?inviteCode=ad824001\n\n24. morphic（`国内直连`、免费4o、Claude3.5）：https://www.morphic.sh/\n\n25. julius（`国内直连`、`专攻`数据分析的AI）：https://julius.ai/\n\n26. 套壳9（`国内直连`、早8点到9点和周四全天可白嫖gtp-4o）：https://www.zaiwen.top/\n\n27. hiplotAI（`国内直连`、`专攻`生物信息分析）：https://hiplot.cn/?lang=zh_cn\n\n28. VecMul Chat(`国内直连`、可联系拉姆):https://www.vecmul.com?inviteCode=HBFLI9K7\n\n29. wordware(`国内直连`、目前免费):https://www.wordware.ai/\n\n30. SambaVova(Meta-Llama3.1-405B):https://sambanova.ai/\n\n31. 套壳10(`国内直连`、目前免费405B、Claude3.5)：https://openai-x.net/\n\n32. RawChat公益站点(`国内直连`、Claude3.5)：https://kelaode.ai/\n\n33. 套壳11(`国内直连`、4o和Claude3.5万完全免费)：https://aichatru.ru/zh-CN/app\n\n34. **Notiamond**(每月100000次免费请求额度)：https://www.notdiamond.ai/\n\n## AI搜索\n1. 清华的AMiner（`国内直连`、AI学术搜索平台）：https://www.aminer.cn/\n\n2. 秘塔AI（`国内直连`、全网、学术、文库、播客搜索AI）：https://metaso.cn/\n\n3. ScholarAI（学术AI）https://app.scholarai.io/home\n\n3. DevvAI（特色：有GitHub库搜索）：https://devv.ai/zh/referral?code=driyivdqpn9c\n\n4. Genspark（在检索某些信息方面个人感觉比秘塔好一点）：https://www.genspark.ai\n\n5. Perplexity（AI搜索鼻祖）：https://www.perplexity.ai/\n\n6. Phind（有IDE支持，还可以）https://www.phind.com/\n\n7. **Copilot**（最早联网的AI，涵盖AI搜索的功能）：https://copilot.microsoft.com/\n\n8. 百小应（`国内直连`、百度的）：https://ying.baichuan-ai.com/chat\n\n9. 360搜索（`国内直连`、360）：https://so.chat.360.cn/\n\n10. 博查AI（`国内直连`、提供联网搜索、AI搜索、智能体搜索等API服务）：https://bochaai.com/\n\n11. 天工AI（`国内直连`）：https://www.tiangong.cn/\n\n12. ThinkAny（`国内直连`、提供GitHub、twitter、Wikipedia搜索）https://thinkany.so/zh\n\n13. 快搜AI（`国内直连`）：https://www.kuaisou.com/\n\n14. 心流AI（`国内直连`，阿里巴巴的）:https://iflow.cn/\n\n15. 开搜AI (`国内直连`):https://kaisouai.com/?from=wananxz\n\n## `AI导航站`:\n\n1. *GPT公益导航*：https://dongfang.flowus.cn/\n\n2. 摸鱼技术网：https://xn--v4q818bf34b.com/\n\n3. Github统计免费GPT导航网页：https://github.com/LiLittleCat/awesome-free-chatgpt?tab=readme-ov-file#-chatgpt-%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8\n\n4. 非猪ai导航：https://feizhuke.com/#term-6606\n\n5. 潮点AI导航：https://aichaodian.com/\n\n6. 公益RawChat：https://sharedchat.cn/\n\n7. AI工具集：https://ai-bot.cn/\n\n","tags":["GPT"],"categories":["Tool"]},{"title":"数据分析之特征提取-PCA","url":"/2024/05/31/learn/data4/","content":"\n## 常见方法 \n\n在数据分析中，特征提取是一个关键步骤，它涉及从原始数据中提取有意义的特征，以便用于后续的分析和建模。以下是一些常用的特征提取方法：\n\n1. **主成分分析（PCA）**：\n   - PCA是一种线性降维技术，通过将数据投影到新的正交坐标系中，提取出数据的主要成分。这些主成分是原始特征的线性组合，能够最大程度地保留数据的方差。\n\n2. **独立成分分析（ICA）**：\n   - ICA是一种用于分离混合信号的技术，它假设数据是由独立的非高斯信号源线性混合而成的。ICA的目标是找到这些独立的信号源。\n\n3. **线性判别分析（LDA）**：\n   - LDA是一种监督学习方法，用于在保持类间差异最大化的同时，减少数据的维度。LDA通过找到一个投影方向，使得不同类别的数据点尽可能分开。\n\n4. **t-分布随机邻域嵌入（t-SNE）**：\n   - t-SNE是一种用于高维数据可视化的非线性降维技术。它通过保持数据点之间的相似性关系，将高维数据映射到低维空间。\n\n5. **局部线性嵌入（LLE）**：\n   - LLE是一种非线性降维技术，它通过保持数据点之间的局部线性关系，将高维数据映射到低维空间。LLE假设每个数据点可以由其邻域点的线性组合近似表示。\n\n6. **自动编码器（Autoencoders）**：\n   - 自动编码器是一种神经网络模型，用于无监督学习中的特征提取。它通过将输入数据压缩到一个低维编码，然后再解码回原始维度，学习数据的紧凑表示。\n\n7. **小波变换（Wavelet Transform）**：\n   - 小波变换是一种信号处理技术，用于将信号分解成不同频率的子信号。它在时间-频率域中提供了一种灵活的分析方法，适用于非平稳信号的特征提取。\n\n8. **傅里叶变换（Fourier Transform）**：\n   - 傅里叶变换是一种将信号从时域转换到频域的技术。它可以将信号分解成不同频率的正弦波成分，适用于周期性信号的特征提取。\n\n9. **词嵌入（Word Embeddings）**：\n   - 词嵌入是一种自然语言处理技术，用于将单词表示为低维连续向量。常用的词嵌入方法包括Word2Vec、GloVe和FastText等。\n\n10. **特征哈希（Feature Hashing）**：\n    - 特征哈希是一种用于处理高维稀疏特征的技术。它通过将特征映射到一个固定大小的哈希空间，减少特征的维度，同时保持特征的多样性。\n\n这些方法各有特点，适用于不同的数据类型和分析任务。在实际应用中，选择合适的特征提取方法需要根据具体的数据和分析目标来决定。\n\n## PCA\n\n主成分分析（Principal Component Analysis，简称PCA）是一种统计方法，用于将一组可能相关的变量转换为一组线性不相关的变量，这些新的变量称为主成分。PCA的主要目标是降维，同时尽可能保留原始数据中的变异信息。以下是PCA的详细介绍：\n\n### 基本原理\nPCA的基本原理是通过线性变换将原始数据投影到一个新的坐标系中，使得投影后的数据在新的坐标系中的第一个坐标（即第一主成分）具有最大的方差，第二个坐标（即第二主成分）具有次大的方差，依此类推。每个主成分都是原始变量的线性组合，且主成分之间相互正交（即不相关）。\n\n### 步骤\nPCA的实施通常包括以下步骤：\n\n#### 数据标准化\n在进行PCA之前，通常需要对数据进行标准化处理，使得每个变量的均值为0，方差为1。这是因为PCA对变量的尺度非常敏感，如果不进行标准化，方差较大的变量将在主成分分析中占据主导地位。\n\n#### 计算协方差矩阵\n协方差矩阵反映了变量之间的线性关系。通过计算标准化后数据的协方差矩阵，可以了解变量之间的相关性。\n\n#### 计算特征值和特征向量\n协方差矩阵的特征值和特征向量是PCA的核心。特征值表示每个主成分所解释的方差大小，特征向量表示每个主成分的方向。特征值越大，对应的主成分解释的方差越大。\n\n#### 选择主成分\n根据特征值的大小，选择保留的主成分数量。通常的做法是保留特征值大于某个阈值的主成分，或者保留累计解释方差达到一定比例的主成分。\n\n#### 数据投影\n将原始数据投影到所选择的主成分上，得到降维后的数据。\n\n### 应用\nPCA广泛应用于数据分析的各个领域，包括但不限于：\n\n- **数据降维**：减少数据的维度，去除冗余信息，同时保留主要特征。\n- **数据可视化**：将高维数据投影到二维或三维空间，便于可视化分析。\n- **特征提取**：提取数据的主要特征，用于后续的机器学习模型训练。\n- **噪声过滤**：通过保留主要成分，去除数据中的噪声。\n\n### 优缺点\n#### 优点：\n- 计算简单，易于理解和实现。\n- 能够有效降维，减少数据量，提高计算效率。\n- 保留了数据的主要结构和变异信息。\n\n#### 缺点：\n- PCA是一种线性方法，对于非线性数据结构可能效果不佳。\n- 结果受数据尺度和分布的影响，需要进行标准化处理。\n- 解释性较差，主成分是原始变量的线性组合，不易于解释其物理或实际意义。\n\n### 实现工具\nPCA可以通过多种编程语言和工具实现，如Python中的`scikit-learn`库、R语言中的`prcomp`函数等。\n\n通过PCA，可以在保留数据主要信息的同时，有效地降低数据的维度，从而简化数据分析和模型构建的过程。\n<!-- 主成分分析（Principal Component Analysis，简称PCA）是一种常用的降维技术，主要用于以下几个方面：\n\n1. **数据降维**：PCA通过将高维数据投影到低维空间，从而减少数据的维度。这有助于去除数据中的冗余信息，同时保留数据的主要特征。降维后的数据更易于处理和可视化。\n\n2. **数据压缩**：通过PCA，可以将高维数据压缩到低维空间，从而减少存储空间和计算资源的消耗。这在处理大规模数据集时尤为重要。\n\n3. **去噪**：PCA可以帮助去除数据中的噪声。通过保留主要成分，可以有效地减少噪声对数据分析的影响。\n\n4. **数据可视化**：将高维数据降维到二维或三维空间后，可以方便地进行数据可视化。这有助于更好地理解数据的结构和特征。\n\n5. **特征提取**：PCA可以用于提取数据的主要特征。通过分析主成分，可以了解数据的主要变化方向，从而更好地理解数据的内在结构。\n\n6. **模式识别和分类**：PCA可以用于模式识别和分类任务中，通过降维和特征提取，提高分类算法的性能。\n\n7. **数据预处理**：在某些机器学习任务中，PCA可以作为数据预处理的一部分，帮助提高模型的性能和稳定性。\n -->\n\n以下是如何使用`scikit-learn`进行PCA分析的详细步骤和示例代码：\n\n### 安装scikit-learn库\n如果还没有安装`scikit-learn`库，可以使用以下命令进行安装：\n\n```bash\npip install scikit-learn\n```\n\n### 导入必要的库\n在进行PCA分析之前，需要导入`scikit-learn`库以及其他可能用到的库，如`numpy`和`pandas`，还有可视化的matplotlib。\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt\n```\n\n### 加载和准备数据\n假设你已经有一个数据集，可以使用`pandas`读取数据，并进行必要的数据预处理。\n\n```python\n# 读取数据\ndata = pd.read_csv('your_data.csv')\n\n# 选择特征列\nfeatures = ['feature1', 'feature2', 'feature3', 'feature4']\nX = data[features] # 特征矩阵\n\n# 数据标准化\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\n```\n\n### 进行PCA分析\n使用`scikit-learn`的`PCA`类进行PCA分析。可以指定要保留的主成分数量，或者通过设置解释方差的阈值来确定主成分的数量。\n\n```python\n# 创建PCA对象，指定要保留的主成分数量\npca = PCA(n_components=2)\n\n# 或者根据解释方差的阈值来确定主成分数量\n# pca = PCA(0.95)  # 保留95%的方差\n\n# 拟合数据并进行转换\nX_pca = pca.fit_transform(X_scaled)\n```\n\n### 解释结果\n可以通过查看PCA对象的属性来解释结果，例如每个主成分解释的方差比例和累计解释方差比例。\n\n```python\n# 每个主成分解释的方差比例\nexplained_variance_ratio = pca.explained_variance_ratio_\nprint(\"Explained Variance Ratio:\", explained_variance_ratio)\n\n# 累计解释方差比例\ncumulative_explained_variance = np.cumsum(explained_variance_ratio)\nprint(\"Cumulative Explained Variance:\", cumulative_explained_variance)\n```\n> 解释方差比例：表示每个主成分解释的方差占原始数据总方差的比例，帮助我们了解每个主成分对数据变异性的贡献程度。\n累计解释方差比例：表示前若干个主成分累计解释的方差占原始数据总方差的比例，帮助我们确定需要多少个主成分才能达到一定的解释方差比例，从而进行有效的降维。\n\n### 可视化结果\n可以使用`matplotlib`库将降维后的数据进行可视化。\n\n```python\nimport matplotlib.pyplot as plt\n\n# 可视化降维后的数据\nplt.scatter(X_pca[:, 0], X_pca[:, 1])\nplt.xlabel('Principal Component 1')\nplt.ylabel('Principal Component 2')\nplt.title('PCA Visualization')\nplt.show()\n```\n### 特征提取\n在PCA分析之后，我们可以将降维后的数据作为新的特征集，用于后续的机器学习模型或其他分析任务。以下是如何将PCA结果作为特征提取的示例：\n\n```python\n# 将PCA结果转换为DataFrame\npca_features = pd.DataFrame(X_pca, columns=['PC1', 'PC2'])\n\n# 将原始标签（如果有）与新的特征集合并\nif 'label' in data.columns:\n    pca_features['label'] = data['label']\n\n# 查看新的特征集\nprint(pca_features.head())\n```\n\n通过上述步骤，我们使用`scikit-learn`库在Python中进行PCA分析，有效降低数据的维度，同时保留数据的主要信息，不仅有助于简化数据结构，还可以将PCA分析的结果作为新的特征集，用于后续的机器学习模型或其他分析任务，从而提高分析的效率和准确性。","tags":["数据分析"],"categories":["learn"]},{"title":"GPT-4o免费分享","url":"/2024/05/23/Tool/GPT4o/","content":"\n  注意喔，红色字体可以直接转跳。如果想要免费的ChatGPT4，可以和拉姆联系，拉姆很乐意和小伙伴们进行讨论喔~\n\n## 国内可访问的mychandler\n\n  [mychandler](https://mychandler.bet/)每月免费用户有40次，就是进入的时候很慢很慢，使用魔法也不快（他的CDN肯定有问题）\n\n  ![mychandler](https://www.qiuxs.cn/sharing-tools/img/read/ce0e2643bf94e02164fbba6c147cba4b)\n  \n## 插件merlin（国内可用）\n\n  [merlin](https://www.getmerlin.in/zh-CN/chat)可以在edge中访问，也可以在chrome中，每日102电力，下面是详细价格表：\n\n  ![merlin](https://www.qiuxs.cn/sharing-tools/img/read/bb2ff479dba6482d4066b238688fcbc3)\n\n## Coze\n\n  [Coze](https://www.coze.com/)简直是我们的神，每次都是免费的！无论是GPT4还是4o，而且到目前为止，拉姆都不知道他的限制次数或者tokens到底是多少，太伟大了\n\n  ![Coze](https://www.qiuxs.cn/sharing-tools/img/read/10b01ddb99f4d6bdbd76fa8d0e35dbeb)\n\n## YOU\n\n  [YOU](https://you.com/)每日五次访问，使用体验是比较可以的。\n\n  ![YOU](https://www.qiuxs.cn/sharing-tools/img/read/7482489d99d68c7a0aee66978735748d)\n\n## Poe\n\n  拉姆想了想，貌似每次都是这几家可以免费使用，像是[lmsys.org](https://arena.lmsys.org/),[poe](https://poe.com/)等，虽然有所限制，但是对于轻度用户还是比较友好的，OpenAI官网其实这次的4o模型也是免费的，但是，这需要等待。\n\n  >poe如果只用GPT4o可以每日免费10次哦\n\n  ","tags":["GPT"],"categories":["Tool"]},{"title":"随机森林与决策树","url":"/2024/05/20/learn/data2/","content":"\n## 定义与基本概念\n\n* 决策树: 树形结构的分类或回归模型，通过特征分割进行分类\n* 随机森林: 集成学习算法，由多个决策树组成\n\n## 决策树（Decision Tree）\n\n  决策树是一种用于分类和回归问题的基本算法，可以对数据进行分类和预测，主要步骤包括特征选择，决策树生成，剪枝。\n\n  1. 特征选择：决策树通过递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类。\n\n  2. 决策树生成：决策树从根节点开始，每个节点都是基于某个特征的分割条件，最终形成一棵树形结构。\n\n  3. 剪枝：为了防止过拟合，通常会对生成的树进行剪枝，通过移除预测性能不佳的分支来简化模型。\n\n  ```python\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, classification_report\n\n# 加载数据\niris = load_iris()\nX = iris.data\ny = iris.target\n\n# 分割数据集为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 创建决策树分类器\nmodel = DecisionTreeClassifier(random_state=42)\n\n# 训练模型\nmodel.fit(X_train, y_train)\n\n# 使用模型进行预测\ny_pred = model.predict(X_test)\n\n# 计算准确率\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"准确率: {accuracy * 100}%\")\n\n# 打印分类报告\nprint(\"分类报告:\")\nprint(classification_report(y_test, y_pred))\n  ```\n## 随机森林（Random Forest）\n\n  随机森林是一种基于决策树的集成学习算法，由多个决策树构成。其核心思想是“集体智慧”，即多个决策树的平均预测结果通常比单个模型更准确。\n\n  随机森林是一种基于 Bagging 策略的集成学习模型，它能够有效地处理非线性问题，并且擅长处理大量样本和特征。此外，随机森林还注重降低方差。Bagging 方法在训练过程中，各基学习器之间无依赖，可实现并行训练。通过集成多个模型，它可以有效地处理过拟合问题，提高模型的预测准确性和泛化能力。随机森林可用于分类、回归和异常检测任务。\n\n```python\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\n\n# 加载数据\niris = load_iris()\nX = iris.data # 特征数据\ny = iris.target # 目标标签\n\n# 分割数据集为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 创建随机森林模型\nmodel = RandomForestClassifier(n_estimators=100, random_state=42)\n\n# 训练模型\nmodel.fit(X_train, y_train)\n\n# 获取特征重要性\nimportances = model.feature_importances_\n\n# 打印特征重要性\nfor feature_name, importance in zip(iris.feature_names, importances):\n    print(f\"{feature_name}: {importance}\")\n\n# 使用模型进行预测\npredictions = model.predict(X_test)\n\n# 打印预测结果\nprint(\"预测结果:\", predictions)\n\n# 打印真实结果\nprint(\"真实结果:\", y_test)\n\n# 计算准确率\naccuracy = model.score(X_test, y_test)\nprint(f\"准确率: {accuracy * 100}%\")\n```\n## Bootstrap Sampling\n\n  Bagging（Bootstrap Aggregating）是一种集成学习方法，用于提高机器学习算法的稳定性和准确性。Bagging的核心思想是通过构建多个模型，然后将这些模型的预测结果进行组合，以达到比单个模型更好的预测效果。（这就是随机森林的思想，对不对）\n\n  Bagging的步骤通常为：\n\n  1. 自助采样（Bootstrap Sampling）：从原始数据集中随机抽取多个样本，每个样本的大小与原始数据集相同，但允许重复抽取。这意味着每次抽样都会有一些数据点被多次选中，而另一些则可能不被选中。\n\n  2. 训练模型：使用每个自助采样得到的数据集来训练一个单独的模型。这些模型可以是相同的算法，也可以是不同的算法。\n\n  3. 预测：对新的数据点进行预测时，每个模型都会给出自己的预测结果。\n\n  4. 组合预测：将所有模型的预测结果进行组合。对于分类问题，通常采用投票的方式来决定最终的分类结果；对于回归问题，则通常取所有模型预测结果的平均值作为最终的预测值。\n  \n  Bagging的主要优点是能够减少模型的方差，提高模型的泛化能力。它特别适用于那些高方差的模型（如决策树）\n\n  所以比较著名的一个Bagging算法就是随机森林。\n\n  ## 决策树与随机森林的区别\n\n  随机森林（Random Forest）和决策树（Decision Tree）都是流行的机器学习算法，它们在数据分析和预测建模中广泛使用。尽管它们都基于决策树的概念，但它们在结构和应用上有所不同。下面我们来看看随机森林和决策树之间的一些主要区别：\n\n1. **模型结构**：\n   - **决策树**：是一个单一的树结构，它通过一系列的决策节点（内部节点）和终端节点（叶子节点）来对数据进行分类或回归。\n   - **随机森林**：是一个集成学习方法，它由多个决策树组成。随机森林通过构建多个树并将它们的预测结果进行组合来提高模型的性能。\n2. **预测方式**：\n   - **决策树**：对新数据进行预测时，从根节点开始，根据特征值沿着树的路径向下移动，直到到达叶子节点，该节点的值即为预测结果。\n   - **随机森林**：对新数据进行预测时，每个决策树都会给出自己的预测结果，然后通过投票（分类问题）或平均（回归问题）的方式来确定最终的预测结果。\n3. **过拟合问题**：\n   - **决策树**：容易过拟合，特别是在树很深的情况下，因为它可以完美地拟合训练数据。\n   - **随机森林**：通过集成多个树，随机森林能够减少过拟合的风险，因为即使单个树可能过拟合，但多个树的组合通常会更加稳定。\n4. **特征选择**：\n   - **决策树**：在每个节点上，决策树会考虑所有可用的特征来选择最佳的分割方式。\n   - **随机森林**：在构建每棵树时，随机森林会在每个节点上随机选择一部分特征来考虑最佳的分割方式，这增加了模型的多样性。\n5. **训练时间**：\n   - **决策树**：通常训练时间较短，因为只需要训练一个模型。\n   - **随机森林**：训练时间较长，因为需要训练多个决策树。\n6. **特征重要性**：\n   - **决策树**：可以提供特征重要性的度量，但通常不如随机森林准确。\n   - **随机森林**：能够提供更准确的特征重要性度量，因为它基于多个树的平均结果。\n\n  总的来说，随机森林通过集成多个决策树来提高模型的准确性和鲁棒性，而决策树则是一个更简单、更快速的单模型方法。随机森林通常在处理复杂数据集时表现更好，而决策树则适用于快速原型设计和简单数据集。\n","tags":["数据分析"],"categories":["learn"]},{"title":"数据分析与数据挖掘浅谈","url":"/2024/05/19/learn/data1/","content":"## 技术栈和工具分析\n\n  对于python技术栈的我们来说，走数据分析与数据挖掘是一条不错的路。\n\n  虽然也可以走前后端，但是目前的市场份额，Java和PHP仍然是主流，对于大厂而言，正在从Java到Golang过渡，所以python做前后端是有点尴尬的。\n\n  数据分析与数据挖掘常见的技术栈除了python之外，还有R、SQL、Hadoop、Spark、Hive、SPSS、SAS、Weka、Scikit-learn、TensorFlow、Keras等。\n\n  其中拉姆目前所接触的只有python、r、spss、Scikit-learn、TensorFlow、Keras\n\n  比较熟悉的只有python的一些库，Pandas、NumPy就不用说了，Scikit-learn、TensorFlow、Keras则是在机器学习和深度学习里的一点东西（其实也是python的库），大学里开设了相关的专业课与实验课。\n\n  R语言则是最近学习了解的。\n\n  SPSS、SAS、Weka是经典的数据挖掘和统计分析工具，使用起来并不是说很困难，可以尝试进行学习。\n\n  其实除了上面的之外，还有[spsspro](https://www.spsspro.com/)、[FineBI](https://www.finebi.com/)等，都是要比那种纯粹的工具更好用的。\n\n## 数据分析与数据挖掘的联系\n\n  数据分析主要是指使用统计学、数学和计算机科学的方法来处理和分析数据，以提取有用的信息和洞察，帮助做出决策。\n\n  数据分析可以包括描述性分析（如计算平均值、中位数、标准差等）、诊断性分析（分析数据变化的原因）、预测性分析（使用历史数据预测未来趋势）和规范性分析（基于预测结果提出行动建议）。\n\n  数据分析通常侧重于已知模式的识别和验证，以及对数据的解释和报告。\n\n  数据挖掘则是一种更深层次的数据分析方法，它侧重于从大量数据中发现未知的、潜在有用的模式和关系。\n\n  数据挖掘通常涉及复杂的算法和技术，如聚类分析、关联规则学习、分类、回归和异常检测等。\n\n  数据挖掘的目的是发现数据中的隐藏模式，这些模式可能对业务决策、市场分析、风险管理等领域有重要价值。\n\n  两者都需要对数据进行预处理，比如清理缺失值、检查异常值、去除噪声什么的。\n\n## 食用指南1\n  \n  1.因为版本等各种因故，导致一些代码在运行的时候会有各种各样的警告，我们可以使用下面的代码进行**忽略警告**：\n  ```bash\n    import warnings\n    warnings.filterwarnings('ignore')\n  ```\n  2.绘图的时候因为字体因故加载不出来中文字体，可以用下面代码：\n  ```bash\n    import matplotlib.pyplot as plt\n    # 设置中文字体\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n  ```\n  3.读取数据：\n  ```bash\n    import pandas as pd #数据导入 \n    data = pd.read_csv('data.csv')\n  ```\n  4.数据探索：\n  ```bash\n    print(data.head()) # 查看数据前几行\n    print(data.describe())# 查看数据统计摘要\n    print(data.columns)# 查看数据列名\n  ```\n  5.数据处理的时候难免会遇到缺失值，这个时候我们可以进行之间删除，或者用均值进行填充：\n  ```bash\n    # 处理缺失值\n    data = data.dropna()  # 删除含有缺失值的行\n    # 或者\n    data = data.fillna(data.mean())  # 用特定值（这里是均值）填充缺失值\n  ```\n  6.在数据分析之中，绘图matplotlib是最为常见的一个库，可以绘画各种图像进行数据可视化帮助我们理解：\n  ```bash\n    import matplotlib.pyplot as plt\n    data['column_name'].hist()  \n    plt.show() # 绘制直方图   \n    plt.scatter(data['column_name1'], data['column_name2'])\n    plt.show()# 绘制散点图\n  ```\n  7.我们在处理一些数据的时候需要进行**标准化**，为什么呢，因为可以帮助不同的特征具有相似的尺度，提高模型的收敛速度，使特征更符合标准的正态分布，提高模型的准确性和可解释性：\n  ```bash\n    from sklearn.preprocessing import StandardScaler\n    scaler = StandardScaler()  \n    scaled_data = scaler.fit_transform(data)# 数据标准化\n    # 将标准化后的数据转换为DataFrame\n    scaled_data = pd.DataFrame(scaled_data, columns=data.columns)\n  ```\n  8.进行**特征选择**在数据挖掘和机器学习中是非常必要的，它有助于去除无关或冗余的特征，提升模型性能，并减少计算成本，而且过多的特征可能导致维度灾难，增加模型复杂度，引发过拟合，并增加时间成本：\n  ```bash\n    from sklearn.feature_selection import SelectKBest\n    from sklearn.feature_selection import chi2\n    # 使用卡方检验选择特征选择排名前 10 的特征\n    selector = SelectKBest(score_func=chi2, k=10)\n    selected_features = selector.fit_transform(data, target)\n  ```\n  9.**建模**更不用说了，是数据挖掘之中必不可少的组成部分：\n  ```bash\n    from sklearn.linear_model import LinearRegression\n    # 线性回归模型\n    model = LinearRegression()\n    model.fit(X_train, y_train)\n    predictions = model.predict(X_test)\n  ```\n  10.建模之后，还需要对模型进行**评估**，这样可以帮助我们优化模型参数，提高模型性能，选择最佳模型等：\n  ```bash\n    from sklearn.metrics import mean_squared_error\n    # 计算均方误差\n    mse = mean_squared_error(y_test, predictions)\n    print(\"MSE:\", mse))\n  ```\n  11.**聚类分析**是一种无监督学习方法，通过聚类，我们可以发现数据中相似的群组或簇，更好地理解数据之间的关系，还可以检测出异常值、噪声、离群点等：\n  ```bash\n    from sklearn.cluster import KMeans\n    # KMeans聚类\n    kmeans = KMeans(n_clusters=3)\n    kmeans.fit(data)\n    labels = kmeans.labels_\n  ```\n  12.分类任务常见的有**随机森林**、**决策树**、**逻辑回归**、**朴素贝叶斯**、**支持向量机**等，我们来简单介绍一下最常见的**SVM**，SVM适用于线性和非线性分类问题，还可以高效处理高维数据集，在多类别分类时具有独特的优势：\n  ```bash\n    from sklearn.svm import SVC\n    # 支持向量机分类\n    svm = SVC()\n    svm.fit(X_train, y_train)\n    predictions = svm.predict(X_test)\n  ```\n  这篇博文先写这些，后面有机会再拓展聊一下，下次见~","tags":["数据分析"],"categories":["learn"]},{"title":"docker食用指南","url":"/2024/05/18/learn/docker/","content":"\n## 什么是Docker？\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用及其依赖包到一个可移植的容器中，然后发布到任何支持 Docker 的平台上。它提供了简便的虚拟化解决方案，使得应用开发、测试和部署更加一致和高效。\n\n## Docker的应用场景\n- Web 应用的自动化打包和发布。\n- 自动化测试和持续集成、发布。\n- 在服务型环境中部署和调整数据库或其他的后台应用。\n- 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。\n## 基本概念\n- 镜像 (Image)：镜像是一个只读模板，包含了运行应用程序所需的所有内容（代码、库、配置等）。可以把镜像看作是一个蓝图，用于创建Docker容器。\n- 容器 (Container)：容器是镜像的运行实例，它是一个轻量级、独立的可执行软件包，包含了软件运行所需的所有内容。\n- Dockerfile：Dockerfile是一个文本文件，包含了一系列指令，告诉Docker如何构建镜像。\n- Docker Hub：这是一个云端的公共仓库，你可以在上面找到和共享Docker镜像\n\n## 安装 Docker\n### 1. Linux\n在Linux上，可以使用官方脚本来安装Docker。例如，在Ubuntu上：\n```bash\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh\n```\n### 2. Windows 和 macOS\n下载并安装Docker Desktop：\n- [Docker Desktop for Windows](https://www.docker.com/products/docker-desktop)\n- [Docker Desktop for macOS](https://www.docker.com/products/docker-desktop)\n\n## 基本命令\n### 下载镜像\n使用 `docker pull` 命令从 Docker Hub 下载镜像：\n```bash\ndocker pull <image_name>\n```\n### 创建并启动容器\n使用 `docker run` 命令创建并启动一个容器。例如，运行一个交互式的 Ubuntu 容器：\n```bash\ndocker run -it ubuntu bash\n```\n- `-it`：以交互模式运行，并分配一个伪 TTY。\n- `ubuntu`：指定使用的镜像。\n- `bash`：在容器内运行的命令。\n### 进入容器\n使用 `docker exec` 命令进入正在运行的容器：\n```bash\ndocker exec -it <container_id> bash\n```\n### 查看容器状态\n- 查看所有运行中的容器：\n  ```bash\n  docker ps\n  ```\n- 查看所有容器，包括已停止的：\n  ```bash\n  docker ps -a\n  ```\n### 停止容器\n使用 `docker stop` 命令停止一个运行中的容器：\n```bash\ndocker stop CONTAINER_ID\n```\n### 删除容器\n使用 `docker rm` 命令删除一个已停止的容器：\n```bash\ndocker rm CONTAINER_ID\n```\n### 导出和导入容器\n- 导出容器：\n  ```bash\n  docker export <container_id> > output.tar\n  ```\n- 导入容器：\n  ```bash\n  docker import output.tar <new_container_name>\n  ```\n### 构建镜像\n使用 `docker build` 命令从当前目录中的 Dockerfile 构建一个镜像：\n```bash\ndocker build -t TAG_NAME .\n```\n- `-t TAG_NAME`：为镜像指定一个标签。\n- `.`：指定 Dockerfile 所在的目录。\n\n通过这些命令，我们可以有效地管理和操作Docker容器和镜像，实现应用的快速部署和环境的统一管理。\n\n## Dockerfile 示例\nDockerfile 是用于构建Docker镜像的文本文件，包含一系列指令。例如，以下是一个简单的Dockerfile：\n```dockerfile\n# 使用官方的Python基础镜像\nFROM python:3.9-slim\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制当前目录内容到工作目录\nCOPY . /app\n\n# 安装依赖包\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 定义环境变量\nENV NAME World\n\n# 设置容器启动时运行的命令\nCMD [\"python\", \"app.py\"]\n```\n\n## 镜像管理\n### 1. 列出镜像\n列出本地所有镜像：\n```bash\ndocker images\n```\n### 2. 拉取镜像\n从Docker Hub拉取一个镜像：\n```bash\ndocker pull IMAGE_NAME\n```\n### 3. 删除镜像\n删除一个本地镜像：\n```bash\ndocker rmi IMAGE_ID\n```\n\n## 网络和数据卷\n### 网络\nDocker允许创建自定义网络，容器可以加入这些网络并相互通信。例如，创建一个网络：\n```bash\ndocker network create my-network\n```\n运行容器时加入网络：\n```bash\ndocker run -d --network=my-network --name my-container ubuntu\n```\n### 数据卷\n数据卷用于持久化数据，可以在容器之间共享和重用。例如，创建一个数据卷：\n```bash\ndocker volume create my-volume\n```\n运行容器时挂载数据卷：\n```bash\ndocker run -d -v my-volume:/app/data ubuntu\n```\n\n## 最佳实践\n1. **使用`.dockerignore`文件**：排除不需要的文件和目录，以减小镜像大小。\n2. **使用官方镜像**：尽量使用官方基础镜像，保证安全性和稳定性。\n3. **保持镜像小巧**：避免包含不必要的依赖，减小镜像大小。\n4. **使用多阶段构建**：通过多阶段构建来减少最终镜像的大小，优化构建过程。\n\n\nDocker 是一个功能强大的工具，上述指南仅涵盖了基础知识。深入学习 Docker 可以帮助你更好地理解容器化技术，并有效地管理应用部署。\n\n>注意在windows系统退出dockers的时候，可能会出现一种情况，后台的WSL没有退出并且占用大量内存，这个时候我们需要 `wsl --shutdown` 命令进行关闭","tags":["docker"],"categories":["learn"]},{"title":"linux食用指南","url":"/2024/05/15/learn/linuxone/","content":"\n## Linux 基本概念\n\n### 1. 什么是Linux\nLinux是一个开源的、类Unix操作系统，由Linus Torvalds于1991年首次发布。它有许多不同的发行版（例如Ubuntu、Red Hat、Fedora、Debian等），用于桌面、服务器和嵌入式系统。\n\n### 2. 文件系统结构\nLinux使用一种树状的文件系统结构，所有内容都从根目录（`/`）开始。常见的目录有：\n- `/bin`：基本命令二进制文件\n- `/etc`：配置文件\n- `/home`：用户主目录\n- `/var`：可变文件，如日志\n- `/usr`：用户程序和数据\n\n### 3. 权限和所有权\n每个文件和目录都有权限和所有权。权限分为三类：所有者、所属组和其他用户。每类权限分为读（r）、写（w）和执行（x）。\n\n### 4. 包管理\nUbuntu使用APT（Advanced Package Tool）来管理软件包。\n\n## 基本命令\n\n### 1. 显示当前路径\n```bash\npwd\n```\n显示当前工作目录的路径。\n\n### 2. 列出目录内容\n```bash\nls\n```\n常用选项：\n- `ls -l`：详细列表格式\n- `ls -a`：包括隐藏文件\n\n### 3. 更改目录\n```bash\ncd /path/to/directory\n```\n进入指定目录。\n\n### 4. 创建目录\n```bash\nmkdir new_directory\n```\n\n### 5. 删除文件或目录\n```bash\nrm file_name\nrm -r directory_name\n```\n`-r` 递归删除目录及其内容。\n\n### 6. 复制文件或目录\n```bash\ncp source_file target_file\ncp -r source_directory target_directory\n```\n\n### 7. 移动文件或重命名\n```bash\nmv old_name new_name\nmv file_name /path/to/new_directory\n```\n\n### 8. 查看文件内容\n```bash\ncat file_name\nless file_name\n```\n`less` 分页查看长文件。\n\n### 9. 编辑文件\n```bash\nnano file_name\nvim file_name\n```\n\n### 10. 查找文件\n```bash\nfind /path/to/search -name \"file_name\"\n```\n\n### 11. 搜索文件内容\n```bash\ngrep \"search_term\" file_name\n```\n\n## 用户管理\n\n### 1. 添加用户\n```bash\nsudo adduser new_user\n```\n\n### 2. 删除用户\n```bash\nsudo deluser user_name\n```\n\n### 3. 修改用户密码\n```bash\nsudo passwd user_name\n```\n\n### 4. 切换用户\n```bash\nsu - user_name\n```\n\n### 5. 查看当前用户\n```bash\nwhoami\n```\n\n## 软件管理\n\n### 1. 更新软件包列表\n```bash\nsudo apt update\n```\n\n### 2. 升级已安装的软件包\n```bash\nsudo apt upgrade\n```\n\n### 3. 安装新软件包\n```bash\nsudo apt install package_name\n```\n\n### 4. 删除软件包\n```bash\nsudo apt remove package_name\n```\n\n### 5. 清理不再需要的软件包\n```bash\nsudo apt autoremove\n```\n\n## 网络配置\n\n### 1. 查看网络接口信息\n```bash\nip addr\n```\n\n### 2. 查看网络连接状态\n```bash\nnetstat -tuln\n```\n\n### 3. 配置静态IP地址\n编辑 `/etc/netplan/*.yaml` 文件：\n```yaml\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      addresses:\n        - 192.168.1.100/24\n      gateway4: 192.168.1.1\n      nameservers:\n        addresses: [8.8.8.8, 8.8.4.4]\n```\n然后应用配置：\n```bash\nsudo netplan apply\n```\n\n## 系统管理\n\n### 1. 查看系统信息\n```bash\nuname -a\n```\n\n### 2. 查看磁盘使用情况\n```bash\ndf -h\n```\n\n### 3. 查看内存使用情况\n```bash\nfree -h\n```\n\n### 4. 查看系统日志\n```bash\nsudo journalctl -xe\n```\n\n### 5. 管理服务\n- 启动服务：\n  ```bash\n  sudo systemctl start service_name\n  ```\n- 停止服务：\n  ```bash\n  sudo systemctl stop service_name\n  ```\n- 重启服务：\n  ```bash\n  sudo systemctl restart service_name\n  ```\n- 查看服务状态：\n  ```bash\n  sudo systemctl status service_name\n  ```\n\n## 进阶操作\n\n### 1. 使用SSH连接远程服务器\n```bash\nssh user@remote_server\n```\n通过SSH安全地连接远程服务器。\n\n### 2. 设置防火墙\n```bash\nsudo ufw enable\nsudo ufw allow ssh\nsudo ufw allow 80/tcp\nsudo ufw status\n```\n`ufw`（Uncomplicated Firewall）是一个简化的防火墙管理工具。\n\n### 3. 配置自动更新\n编辑 `/etc/apt/apt.conf.d/50unattended-upgrades` 文件，启用自动更新。\n\n### 4. 设置定时任务（Cron Jobs）\n编辑用户的crontab：\n```bash\ncrontab -e\n```\n添加定时任务。例如，每天凌晨2点备份：\n```bash\n0 2 * * * /path/to/backup_script.sh\n```\n\n### 5. 安装和使用Docker\n安装Docker：\n```bash\nsudo apt update\nsudo apt install docker.io\n```\n启动Docker服务：\n```bash\nsudo systemctl start docker\nsudo systemctl enable docker\n```\n运行一个Docker容器：\n```bash\nsudo docker run hello-world\n```\n\n### 6. 使用Git进行版本控制\n安装Git：\n```bash\nsudo apt install git\n```\n配置Git：\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your_email@example.com\"\n```\n克隆一个Git仓库：\n```bash\ngit clone https://github.com/example/repo.git\n```\n\n以上内容涵盖了从基本概念到常用命令和进阶操作，希望能帮助初学者全面了解和使用Ubuntu Linux操作系统。","tags":["linux"],"categories":["learn"]},{"title":"GPT4与实用AI分享","url":"/2024/03/31/Tool/shareGPT/","content":"\n  >这篇博文里有免费的GPT4、音乐生成AI、AI搜索引擎，分为国内和国外两部分。\n\n  其中国内有两个：搜索引擎AI：[秘塔AI](https://metaso.cn/)；Claude平替：[KimiAI](https://kimi.moonshot.cn/)。\n  国外有七个：音乐生成AI：[Suno](https://app.suno.ai/)；GPT4的免费平替：[Coze](https://www.coze.com/)和[Claude](https://claude.ai/chats)还有[wrtn](https://wrtn.ai/)、[PopAi](https://www.popai.pro)；搜索引擎AI：[phind](https://www.phind.com/agent?home=true)和[perplexity](https://www.perplexity.ai/)。\n\n  至于[Copilot](https://copilot.microsoft.com/?culture=en-us&country=us)和[arena.lmsys.org](https://arena.lmsys.org/)就没提，不过你若是想要试试的话，可以直接点击红色字体进行跳转。\n  \n  >PS：**红色字体**是转跳链接哦，点击直接转跳到官网。\n\n## 国内AI\n### 秘塔AI\n1. 秘塔AI https://metaso.cn/\n\n  秘塔AI是一个AI搜索引擎，用户体验是很可以的，国产的可以做到这个水平说实话已经超出我的预料了，虽然国外的AI搜索引擎出来已经将近一年了，不过，在某些方面，拉姆还是支持国产的。\n\n  首先你需要进入官网，点击[秘塔AI](https://metaso.cn/)，进入页面就可以直接使用了。\n\n  这里面有学术模式（对写论文搞学术的很友好）\n\n  ![秘塔AI-0.png](https://www.qiuxs.cn/sharing-tools/img/read/ff6eed44cb8c5c23e6126f0582a48847)\n\n  还有一些如大纲、演示文稿一类的，使用起来很方便。\n\n  ![秘塔AI-1.png](https://www.qiuxs.cn/sharing-tools/img/read/3d653de7f589727eadcc0792240977dc)\n\n### KimiAI\n2. [KimiAI](https://kimi.moonshot.cn/)\n  KimiAI支持最多五十个文档的上传与分析，这点和claude3差不多，在某些方面上是对标GPT4的，在国内免费使用是很良心的。\n\n  点击[KimiAI](https://kimi.moonshot.cn/)可以进入注册使用。\n\n## 国外AI\n### Suno\n3. [Suno](https://app.suno.ai/)\n\n  Suno是一个生成音乐的AI，无论是你给他自己所作歌词还是给他一段描述，他都可以生成一首歌曲，支持各种语言，包括中文，还可以自定义曲风等，开会员还可以生成纯音乐一类的。\n\n  点击[Suno](https://app.suno.ai/)可以注册使用。\n\n  ![coze-0.png](https://www.qiuxs.cn/sharing-tools/img/read/81af18289f07204ce4e73ee88dfcb96f)\n  \n  ![coze-1.png](https://www.qiuxs.cn/sharing-tools/img/read/002da6e091f5014cef0feca58e152560)\n  \n### Coze  \n4. [Coze](https://www.coze.com/)\n\n  其实拉姆的一篇博文[GPT-4(8k)免费使用方法](https://6677677.xyz/2023/12/22/Tool/GPT4.0/)已经介绍过这个免费使用GPT4.0的方法了，而且24年年初还增加了超多插件和GPT4-128K模式，还有一些Skills、Memory、Advanced，总之是非常非常超级良心的。\n\n  点击[Coze](https://www.coze.com/)可以注册使用。\n\n  ![coze-0.png](https://www.qiuxs.cn/sharing-tools/img/read/d2d745b691da5b38f89b16b5bfe7675b)\n  \n  这里面的Persona和Prompt，也就是自定义角色和提示词，是很有意思的，拉姆的一个朋友把这个定义成他女朋友的名字和性格，然后发给他女朋友，还有定义猫娘什么的，这里等待你的开发哦😉\n### Claude\n5. [Claude](https://claude.ai/chats)\n\n  Claude AI尤其是Claude3已经是对标GPT4甚至碾压GPT4的存在，很好用，但是对于小白来说不推荐。\n\n  不是使用上不推荐，是因为现在注册账户目前是需要海外手机号接受验证码的，这个可以在SMS上购买，不过不划算，毕竟SMS一次至少充值2美金...坑人。\n\n  拉姆当时注册的时候，还不需要手机验证码，比较那时候Claude刚出来。\n\n  点击[Claude](https://claude.ai/chats)可以进行注册。\n### wrtn\n6. [wrtn](https://wrtn.ai/)\n\n  这是韩国的一个免费的公益性AI，内含GPT4等各种模型，而且无限制使用，但是这个底层逻辑好像都是用韩文进行的回答，不过你也可以欺骗他，让他用英语或者中文进行回答：\n\n  点击[wrtn](https://wrtn.ai/)可以进行注册。\n\n  ![wrtn-0.png](https://www.qiuxs.cn/sharing-tools/img/read/93edcb34931d01641cdb42af84342381)\n### PopAi\n7. [PopAi](https://www.popai.pro)\n  \n  PopAi可以和文档聊天，也可以做PPT，还有绘图，内置的大模型可以每天使用两次GPT4，对于免费用户而言，虽然有些鸡肋，浅浅得玩一下还是可以的。\n\n  点击[PopAi](https://www.popai.pro)可以进行注册。\n\n  ![Popai-0.png](https://www.qiuxs.cn/sharing-tools/img/read/c4107e9b00ed91e64a3c32f7a637c730)\n### phind\n8. [phind](https://www.phind.com/agent?home=true)\n\n  phind是一个AI搜索引擎，免费用户支持Chat和Search两者模式，Pro支持Code模式。\n\n  点击[phind](https://www.phind.com/agent?home=true)可以进行注册。\n  \n  ![phind-0.png](https://www.qiuxs.cn/sharing-tools/img/read/6b95d3ae7341ac3857fd1e73b7bdb673)\n\n  ![phind-1.png](https://www.qiuxs.cn/sharing-tools/img/read/dc1b8babc874448ed6700c47d6b613fa)\n### perplexity\n9. [perplexity](https://www.perplexity.ai/)\n\n  perplexity也是一个AI搜索引擎，免费用户可以开启pro搜索，一天免费五次，每四个小时恢复一次，基本上就是加强版的new bing，当然不开Pro搜索他所给的答案个人感觉也是可以的。\n\n  点击[perplexity](https://www.perplexity.ai/)可以进行注册。\n  \n  ![perplexity.png](https://www.qiuxs.cn/sharing-tools/img/read/412236785a617acd1bfc25009e177be8)\n","tags":["GPT"],"categories":["Tool"]},{"title":"Summary for 2021-2023","url":"/2024/03/30/diary/university/","content":"\n## 如果能重来\n\n  一眨眼就到大三下学期了，想想似乎是昨天才刚步入大学校园，急景流年，韶光如箭啊。\n\n  目前来看，大学生活虽谈不上颓废，也可以说得上是无所事事，说说比较后悔的几件事吧。\n\n  平心而论，比较**后悔的第一件事**，就是拉姆应该从大一便开始，积极参加各种竞赛项目的，不然也不至于现在连拿得出手的国奖都没几个。\n\n  >这点可以参考拉姆的班委，拿了二三十个竞赛奖项，还有一个大佬，拉姆只是见到过，大三上学期就拿到了几十个奖项，还有各种合作项目，真的真的太强了。\n\n  当然，说笑一下，90%以上的大学生都不知道也不会参与各种竞赛，有这种觉悟的人是很少的，毕竟一般来说你的辅导员催你搞创新学分都在大三大四。\n\n  前些时候在群里看到一个HR说，现在的小孩，**大一大二**就开始**卷实习**，大三秋招，然后月入过万起步，害，要不然每个人的认知水平是不同的，你看看人家，再看看拉姆，不能比不能比。\n\n  **其二**比较后悔的事情便是Java学得不怎么样，不过这点还好，目前已经决定不走后端，前端也不走，其实早知如此就应该报名**数据科学专业**的，刚好也和现如今的offer相匹配，再不然学学软件测试一类的也还好（毕竟在招聘会上看到招软件测试的比较多）\n\n  就是不知道以后ChatGPT这一类的AI对目前行业的影响了，毕竟前些时候世界上第一位完全自主运行的人工智能软件工程师**Devin**已经面世了（当然很多人对Devin提出的质疑咱暂且不提）。\n\n  **其三**嘛，这个博客应该大一就开始做的，无论是记录生活还是写写诗词，亦或者分享学习技术，都是可以的，大三做博客就有点晚了。\n\n  **其四**，虚度光阴，这点深有体会啊，拉姆平常就喜欢看看小说，但是一看便愈发不可收拾，说实在，看小说不如提高一下英语水平，说不准以后还能进个外企，但是现实嘛，不提也罢。\n\n  **其五**，拉姆在网上查了查，写到其四的时候就没有想到其他的，查到一个，认真说起来，拉姆不清楚算不算得遗憾，这更多的可能只是一种选择，那就是看见网上有好多人在说后悔没有体验一下校园恋爱，这点，拉姆不清楚，毕竟身处局中，非旁观者迷。\n\n  ~~不过前些时候拉姆的老大**SXH**，在qq上跟拉姆发癫，一直说他好想谈恋爱~~\n\n  ~~所以有想恋爱的童鞋，可以和拉姆联系哦，拉姆的老大可是**学历985**，身高**180**，五官端正立体，皮肤细腻如玉，平时动不动就脸红的单纯大男孩。~~\n  \n<!--   如果能重来，拉姆肯定大一就开始打竞赛。\n\n  说真的，你想想，大一就开始打各种竞赛，你到大三肯定得二三十个证书了（详细请参考拉姆的班委）\n\n  拉姆目前能拿出的竞赛证书证明只有六七八个，都是23年打下来的，但感觉竞赛知名度不怎么高，而且国奖只有三个，实际帮助可能并不大，现在再打的话就已经没那个精力了。\n\n  前些时候看到一个HR在群里说，现在大一大二的小孩好多都在卷实习，大三直接秋招，这简直...太厉害了，果然每个人的认知都是不同的。拉姆大一时候，似乎还在看小说，虽然现在也在看就是了。\n\n  你现在如果是在大一或者大二，真的可以考虑一下是否卷卷实习，打打竞赛，这样你会学到很多，而且到时候你的简历也很好看。\n\n  拉姆这个专业，到后面走人工智能是不可能的，走算法也不大可能，毕竟算法方面除非你大一大二就开始搞算法，不然你真的看不懂，算法实在是太抽象了（也可能拉姆比较笨）\n\n  刚刚和朋友聊了聊，他说算法岗不好走，对口专业的工作更不好走，他考研不走人工智能，走计科。其实也挺好，毕竟研究生现在那些搞AI的原先都是搞大数据和算法的，只不过这两年AI火起来了，只不过，拉姆这个学校的考研率只有10-15%嗯...上一年好像只有一个学生考到了985，其他的绝大部分都是双非，211也不多。\n\n  害其实最终目的都是为了就业，但是目前真的不如十年前甚至五年前，太饱和了，现在哪里像以前啊。 -->\n\n## 回归过去\n\n  ~~其实过去也没那么的烂，写过的诗词挺多~~\n\n  最起码还是参加过一些竞赛的，在简历上有项目经历和荣誉奖项可写。\n\n  还有认识了好多好多朋友（在大学貌似异性缘和同性缘都挺不错的，这点很开心）\n\n## 展望一下24年的未来\n\n  目前最要紧的事情是做算法题，毕竟蓝桥杯04-13要开始了，再不做就来不及了，还有就是学习实习那边要求的各种课程视频，毕竟实习什么都不会的话，就很说不过去。\n  \n  期待未来越来越好，拉姆，嗯！要越来越幸运！\n\n  下一篇博客应该是关于AI工具的分享，毕竟今天弄了一天了（好）","tags":["日记"],"categories":["dairy"]},{"title":"2023下半年之奇怪的散文总结","url":"/2024/01/08/diary/2023/","content":"\n## 其实时间过得很快\n\n  想起这个博客创建时还是在暑假学车那时候，计划中的GO语言也没怎么学，到现在都2024年了，碌碌无为啊。\n\n  也发生了很多事，有悲有喜，有痛苦也有快乐，印象最深刻的是梦与现实的纠缠，这并不好，因为会打扰到别人。\n\n  记录一下“有意思”的时刻吧，出门被绊已是家常便饭，上次计算智能张伟伟老师让做小组PPT讲解论文，拉姆那一组是拉姆上去演讲，然后bingo，组长选的论文是会议论文而且发布时间有点早，不符合要求，重新做（QAQ）。\n\n  这个其实还好，上次跟着钟佬打亚太数模才是真的痛苦，什么都不会，最后一天熬了通宵在早上八点半交上去了作品，距离截至时间就剩下了半个小时，然后回去的时候全宿舍还都在睡觉，被迫在宿舍门口等待，又困又累又冷，后来还是km醒了，给拉姆开得门，上床睡觉醒来就是晚上六七点了。\n\n  预约纪念币也是如此，地图上明明是中原区，拉姆预约网点当时很着急，看见带有中原的，就选了，结果那边距离这里很远，坐车要一个半小时起步，高新区才是距离拉姆最近的网点（QAQ）\n\n  让拉姆想想，还有被别人第n次当成女生，走错实验室，走错教室，一觉醒来七点五十八（有早八）等\n  ![第n次被当成女生](https://www.qiuxs.cn/sharing-tools/img/read/17c5e537b12f0be6f4d335031f710891)\n  其实也有幸运的时刻，比如在提前考试的那一周，和王振宇在背复习资料的时候，看到了奇妙君在送GPT4激活码，然后然后拉姆就抽到了！虽然是个阉割版，但是这很德克斯特！！\n\n  上面是一个幸运时刻，但下面的让拉姆觉得更幸运，就是和曾经的故人聊天，很开心。\n\n  虽然拉姆可能会打扰到别人，但是如果拉姆能提供情绪价值，这是很幸运且值得的。拉姆喜欢这种感觉。如果没有提供情绪价值，拉姆真的很抱歉，此非本愿，愿君谅解。\n\n  **旧日未见乱心神，因梦记君扰故人**\n\n  眨眼间，距离高二的转折点过了四年，距离最开心的七年级过了八年，其实时间过得很快。\n\n## 每个人时刻都在改变着自己\n\n  每个人或许都在变得陌生，时间是可怕的东西，不过在时光的洗礼之后，所记得的，才更加珍贵。\n\n  拉姆不知道未来，就像曾经不知道现在，愧疚解不开执念，念念不忘不一定会有回响，每一次的疑问不一定都有回应。\n\n  猫猫是可爱的动物，拉姆很喜欢。\n\n  拉姆有个奇怪的能力，动物化，有时候会把别人看成某些小动物，很有意思。\n\n  不过拉姆很少能把别人看成猫猫，如果拉姆把你看成猫猫了，那么可能，拉姆想要养你，毕竟猫猫那么可爱（bushi）\n\n  提前考试那一周，很痛苦，可以和上上学期备战四级的时候不小心闪到腰有的一拼，那时候躺了两三天，腰才好一点，谁家系个鞋带能闪到腰！\n\n  不气不气，明天还要去吹寒风排队，敲，倒霉...\n\n  不过今天还有个单项，起码( )还是赔钱了...\n\n  果然，拉姆是拉姆，不是德克斯特，也不是乔治戴诺<(＿　＿)>\n\n## 期待\n\n  每个人都会有期待吧，希望24年可以，不那么倒霉，hhhh说笑了，倒霉已经习惯了，争取以后当乔治戴诺O(∩_∩)O ","tags":["日记"],"categories":["dairy"]},{"title":"GPT-4(8k)免费使用方法","url":"/2023/12/22/Tool/GPT4.0/","content":"\n## 进入Coze\n\n  我们需要进入官网，点击[Coze官网接口](https://www.coze.com/)，进入注册页面。\n\n  ![Coze1.jpg](https://static.st.qiuxs.cn/image-bed/0/2023/12/22/03_01_09_da0c3f98bcded3d281867daf3adcbb15.jpg)\n  \n  这个时候有两种注册方法，一个是Google账号，还有一个是手机号，这个随便选择一个都可以的。\n\n  ![Coze2.jpg](https://static.st.qiuxs.cn/image-bed/0/2023/12/22/03_01_13_6a65a773ff9dc481ce00451580757148.jpg)\n\n  进入之后的页面如下图所示：\n\n  ![Coze3.jpg](https://static.st.qiuxs.cn/image-bed/0/2023/12/22/03_01_17_1bd6c31ed3ff7cccfae1c6dc2fb44a84.jpg)\n\n  点击Bots，进入之后Create Bots\n\n  ![Coze4.jpg](https://static.st.qiuxs.cn/image-bed/0/2023/12/22/03_01_21_9210b88bd19981b07521b1e2130b45a3.jpg)\n\n  这里面可以选择GPT-4(8k)和GPT-3.5(16k)，以及调节设置，这个时候就可以使用GPT4.0了，不过如果习惯使用openAI官网的chatGPT，那么可能这个界面的操作不会那么舒服。\n\n  ![Coze5.jpg](https://static.st.qiuxs.cn/image-bed/0/2023/12/22/03_01_25_fa82f3ba0ee592d6a1266c0800808527.jpg)\n\n  以上就是GPT-4的免费使用过程了，需要注意的是，应该是需要科学上网的，其他方面应该不会有问题，那么祝各位体验愉快。\n","tags":["GPT"],"categories":["Tool"]},{"title":"拾词-Two（补）","url":"/2023/08/30/Poem/two1/","content":"## 缘一\n\n  这是 [拉姆的小树屋](https://sherry14love.github.io/)的真正的第二篇诗词集哦 o(*￣▽￣*)o\n\n  纯诗词集，所以，没有什么可看性，是属于拉姆自己的诗词书屋————\n\n## 牡丹洛诗 雅客馨词\n\n1-5\n``` bash\n  记忆可以让瞬间化为永恒，\n  但遗忘能够保持心理健康。\n  2023.08.08\n```\n```bash\n   拾一枚铜钱笑春风，捡一片落叶知秋冬，\n   这一束花开予君梦，算一些美好在心中。\n   2023.08.03\n```\n```bash\n  仙姿佚貌人间留，一双瞳水剪清秋。\n  2023.07.22\n```\n```bash\n  你无意轻惹我的踟蹰，清秀却似眉眼如初，\n  辗转反侧是梦的归途，怎算不上相思入骨。\n  （这几句词有味道，小说的味道.23.05.29\n```\n```bash\n  秋日私语旧呢喃，树影星光夜相谈，\n  弱水三千时光慢，再梦当时素装颜。\n  2021.09.15\n```\n6-10\n```bash\n  此梦夕阳已下，不复春时醉花，\n  那时那人那夏，却是入了无涯。\n  2021.09.24\n```\n```bash\n           生日快乐\n  幽兰芳影任时流，玲珑淡颜自娇羞，\n  今夜无眠几杯酒，醉中愿君梦辞忧。\n```\n```bash\n  抚风揉记忆君笑.2021.10.01\n```\n```bash\n  此夜无忧花尽开，与君安祺此心安。\n   2021.10.22\n```\n```bash\n  花语君馨心心念.2021.11.24\n```\n11-15\n```bash\n  了无痕迹了无心，忘了昨日是非今。\n  2021.11.29\n```\n```bash\n  突然发觉学校里的夜晚并不美，\n  沉寂遮掩了星星，我也路过了清冷\n  2021.12.08\n```\n```bash\n  缘起缘灭，花开花落，\n  是非执着，皆是因果，\n  也无对错，虽是落寞，\n  如初持若，此世不说，\n  不煞今我，也煞昨我，\n  梦魂思魄，醉去淡漠，\n  非是罪过，也是错过。\n  阿弥陀佛，阿弥陀佛。\n  2021.12.16\n```\n```bash\n  碎成星空之零落，本就飘零不执着，\n  多情应笑我.2021.12.17\n```\n```bash \n  昨夜恋花花未开，今日恋花花却败，\n  如缘似水了无痕，花开无声将梦枕。\n  2021.12.19\n```\n16-20\n```bash\n  日落红颜醉，如梦伊人媚21.12.23\n```\n```bash  \n  那时入夜浅睡无梦寻，笑忘众生劫难\n  皆是因果痴贪叹我一时忘了悲欢\n  左了情感落寞心间乃我现在模样\n  三生灾厄不祥今生今世孕。\n  2022.01.21\n```\n```bash  \n  穿叶寻蝶惊鸿过，闻君语馨心中灼。\n  2022.05.27\n```\n```bash  \n  已是红尘是非心，欲忘浮生也忘今。\n  2022.05.25\n```\n```bash \n  落日余晖惜故人，抚风留馨扰心神。\n  2022.07.09\n```\n21-25\n```bash\n  百花酿成蜜，其中辛苦谁在意。\n  2022.07.21\n```\n```bash\n  尘世茫茫，这人间太过烦恼\n  听一首陈词滥调的各种评说\n  是非对错的纷纷扰扰不若\n  不再关心回归本心，远离纷扰\n  叽叽喳喳的麻雀抓枝而立\n  却浑然不觉得枝蔓的业火\n  扯扯拽拽这言论太过苍白\n  又看霍雀观凤鸟，最后笑了笑\n  瓦雀弄枝头，不知衔蝉在身后\n  哗众欲取宠，怎料回首是小丑\n  一曲是非忧，悠悠轻抚眉间愁\n  三尺一蜉蝣，只管自身醉与休\n  2022.07.23\n```\n```bash\n  无风落日灿烂，有蝉鸣叶眷念，\n  漫步踱行此曳，星星点点人间。\n  2022.08.12\n```\n```bash \n  寻常之时秋风落叶意如诗，\n  再见而思泯醉入梦我不知\n  2022.10.09\n```\n```bash\n  晚风拂去霞光，扫落惆怅，倾洒的暮色苍茫，\n  落木的枝叶忧伤，朦胧的月色，像是夕阳留\n  给尘世的浅浅吻痕，引人遐想，沉郁的夜空，\n  淡淡地印在这一颗暗红色的心上，这一切如若\n  初遇的侣人梦中相见，辗转思念，夏日揉碎的\n  余热消散在秋日推来的云雨中，或许，这就是\n  现在我的诗句。2022.10.09\n```\n26-30\n```bash \n  浮生梦，梦浮生，花开蝶念各无声\n  一袭醉，醉一袭，清风拂尘睡意归\n  2022.11.07\n```\n```bash\n  渐入佳境得一梦，未料转身错三生\n  2022.11.25\n```\n```bash  \n  忽言秋风已落叶，不知今已仲冬天\n  2022.11.26\n```\n```bash  \n  遇君子翩翩，颂书籍朗朗，伴微风轻轻，\n  邂细雨绵绵，见路边狸花\n  2022.11.27\n```\n```bash \n  佳人亭亭而玉立，檀郎见之梦思之，\n  虽诉轻语不饶时，倩影却是，入了少年夜\n  中喃喃语，颠了晦明将醉拾，辗转意难思\n  ᖗ乛◡乛ᖘ2022.12.19\n```\n31-34\n```bash \n  悲伤的痕迹，搁浅在回忆里。2022.12.28\n```\n```bash  \n  轻云闭月醉星尘，流风回雪初旧痕。\n  2023.01.12\n```\n```bash \n  群星伴明月，篝火暖风醉此阙。\n  2023.01.29\n```\n```bash  \n  夜风柔语诉今夜入梦时道君安。\n  2023.02.24\n```\n\n <!--  诗词本是小道尔，无堪大雅之物，犹如话本，多是夸张渲染，而此值中元七月半，地官出世定人间善恶，以脱困囚，普渡世人，压亡灵戾气，消弭心中烦闷，且河灯度善，万物皆欢。\n\n  东扯西扯，其实记录一下，或许偶尔看看，曾经的，也谈不上文采的，只是按词押韵的堆积，肤浅的青春，也不错。\n\n  拉姆在想，想过好多，在夜晚入梦前很认真的想，或许，应该找些事情干了，学学Java，做做项目，以后或许有机会可能去干程序员吧，其实也突然觉得机器这类专业可以直接进厂挺好的，起码投职压力没那么大。\n\n  而程序员，害，可能三十出头丢了工作，之后在大街上摆摊，维持生活，当然，也只是一番设想，可能活不到那个时候，如果能活到老的话，我一定要尝试写写一本故事，这一定很完美，属于拉姆自己的人生。\n\n  其他的，如诗词的璀璨与浪漫，世间的美好遇繁华，大都与我无关，看看书，听听歌，养只小猫，或者就是一个美好的奢求了。\n\n  幼时不知事，常羡古时礼，不识古人战乱事， 几人温饱佐以礼。\n\n  应当满足的，十年之后也不知这篇博客还会存在吗，如果存在且看到的话，去去母校，见见朋友，天南海北，看看曾经的老大，显豪同学，或许他应该生了一个可爱的女儿了，帅气的朋友生的女儿肯定可爱（bushi）\n\n  为什么会提到老大呢，因为他现在在埋怨我打扰他上课了（虽然我告诉他成事不足者善为自己开脱，而且我和他聊天一分钟都没到，竟然埋怨我（没有天理了）\n\n  不成不成，整体文笔充满暮气可不成，就这样，**记过往，留往昔尝。** -->\n\n\n## 短词绪，意长居\n\n  >礼颜画笑，以待君芳\n\n  >礼颜画笑，以待馨芳\n\n  **这两个曾经很长一段时间作为拉姆的个人签名，一者君，一者馨，都很有意思，不得优劣。**\n\n  **牡丹洛诗 雅客馨词**这篇博客的起头序也很有意思的哦\n  <!-- 哈哈哈哈，或许未来的我都想不到里面的内涵。 -->\n\n```bash\n  一介书生，随缘入梦\n  梦抚清风，风过无声\n```\n```bash\n  裘马去留，俗生欢休\n  一枕黄粱，美梦如酒\n```\n  \n  这是最后两首，个人感觉写得还不错，记录一下，拾词篇应该告一段落了，下一步计划，开始！","tags":["拾词"],"categories":["诗词"]},{"title":"无限流量","url":"/2023/08/13/Tool/WARP/","content":"\n## WARP+\n\n  首先去[WARP官网](https://1.1.1.1/) 下载软件\n\n  其次去[电报机器人](https://t.me/generatewarpplusbot )领取23PB的流量密钥（注：1PB=1000TB=1000 000GB流量）由此可以实现近乎无限流量的魔法，而且速度可以，畅看YouTube是没有任何压力的。\n\n  进入电报之后首先输入/start，再输入/generate，这个时候需要点进去并且关注这两个频道。\n  ![warpbot.jpg](https://www.qiuxs.cn/sharing-tools/img/174/read)\n  \n  然后再输入/generate，这个时候会弹出来简单的数字相加减，输入/generate 9（如图所示）\n  ![warpkey.jpg](https://www.qiuxs.cn/sharing-tools/img/175/read)\n\n  最后在软件的**偏好设置**里，点击**账户**，里面有个**使用其他密钥**，更换密钥就行了。\n  ![warps.jpg](https://www.qiuxs.cn/sharing-tools/img/176/read)\n\n## 没有电报怎么办\n\n  可以点击[这个](https://replit.com/@kelekekou8/WarpKey)，然后直接运行也可以生成一个密钥，从而进行使用。\n\n\n> 注意这里面的WARP虽然有两千多万GB流量，但是这个流量不能支持**Open AI**、**new bing**、**Netflix**、**tiktok**、**Disney**，但对于**YouTube**、**Facebook**、**Twitter**、**Discord**、**Tumblr**、**Mastodon**等网页是支持访问且无限制的，不过需注意这里的访问和你在国内一样，如果你平常不用**VPN**进行上网保护个人隐私的话（会暴露个人ip）。\n\n## 解锁ChatGPT和Netflix\n\n  这里会有朋友问怎么可以去Open AI、Netflix、tiktok、Disney这几个网站，这个的话，倒也是有几个方法，但是Sherry太垃圾了，这几天还在练车，没怎么有时间搞。\n  不过你去YouTube里搜索一下，一大堆利用WARP的解锁篇，解锁ChatGPT和Netflix的（多半是用VPS解锁，嗯~ o(*￣▽￣*)o）","tags":["魔法"],"categories":["Tool"]},{"title":"拾词-Two","url":"/2023/08/11/Poem/two/","content":"## 缘一\n\n  这是 [拉姆的小树屋](https://sherry14love.github.io/)的第二篇诗词文章 o(*￣▽￣*)o\n\n## 正文\n\n  咳咳咳，暂无内容，拉姆懒得写（虽说前几天就想写了）\n\n  ~~懒癌犯了~~\n\n  鸽掉先（bushi）\n\n  PS:后面一定补上！（私密马赛~）\n\n\n","tags":["拾词"],"categories":["诗词"]},{"title":"Google和GPT","url":"/2023/07/19/Tool/Google/","content":"\n## Google账号的免费创立\n\n  我这里以安卓手机为例：\n\n  1. 首先下载一个OurPlay加速器，这个可以在应用商店搜到，然后进入授权进行下载虚拟运行环境（这个会自动下载）\n  ![google1.jpg](https://www.qiuxs.cn/sharing-tools/img/168/read)\n  2. 然后点击选择线路加速，这里选择**中国台湾**。\n  ![google2.jpg](https://www.qiuxs.cn/sharing-tools/img/169/read)\n  3. 其次点击登录账号，点击＋号登录游戏账号。\n  ![google3.jpg](https://www.qiuxs.cn/sharing-tools/img/170/read)\n  4. 这个时候左下角并没有创建账号，这个时候输入自己的电话号，点击下一步，系统会反馈没有你的Google账号，再**返回**上一步；或者点击忘记电子邮箱，进入下一步，再**返回**上一步。\n  ![google4.jpg](https://www.qiuxs.cn/sharing-tools/img/171/read)\n  5. 这个时候左下角就有**创建账号**，点击创建账号，为我自己创建，然后输入自己的姓氏和名字出生日期等，跟着创建流程就行，这样可以解决因为中国手机号不能注册的难题了，但是一定要记住你自己设置的密码，千万不要忘记。\n  ![google5.jpg](https://www.qiuxs.cn/sharing-tools/img/172/read)\n  ![google6.jpg](https://www.qiuxs.cn/sharing-tools/img/173/read)\n  6. 安卓用户别把账号绑定手机，不然忘记密码一类的会很麻烦，因为那个Google的验证码通知栏不会在安卓手机上显示（因为需要google play服务，而安卓手机自带的没有这个功能）\n\n  7. 在管理Google账号里设置如绑定手机号、绑定邮箱一类的，这样账号就真正的属于你了！\n\n  > 请注意，创建账号完成之后，请在手机或者电脑里的邮箱软件，比如qq邮箱里添加自己的Google邮箱账号，这时候一般第一次输入你的密码那边会显示密码错误，应该多试两次，基本上就可以了，最后才可以删除这个OurPlay加速器，预防自己创立Google之后却把号给弄丢了。\n\n  > 但如果密码是记错了，就用手机号发验证码找回，记住，那个Google绑定别绑定手机，尤其是安卓手机，不然又会出现一点麻烦的事情，因为那样找回的时候需要点手机不在身边，然后才会有手机号验证码找回。\n\n<!-- ## VPN\n  \n  **声明：满足好奇心可以，但不能进行任何违法行为，任何行为与本小破博客无关**。\n\n  VPN一般都是付费的，当然也有免费的，不过好多免费的不好用。\n\n  首先，先推荐一下[低价机场](https://dawn-tango-a1e.notion.site/5f7c5d2f7a7747a6bc6541406cb022f5),这里面有好多可以的，可以根据说明筛选。\n\n### 免费VPN\n\n  免费的也是有一些，当然注册账号的时候好多时候都需要你自备魔法，不然不能注册，这里面选择还是有章法的，比如某些免费VPN会盗取你的个人信息，可以去[vpnoverview](https://vpnoverview.com/best-vpn/free-vpn)找找，下面给出两个免费VPN：\n\n  > 1. 首先需要可以下载[GreenHub](https://greenhubtx.ga)，这个只是应急用的，而且自从GPT大火之后，好多时候这里面的免费服务器都是爆满状态（这个可以在国内注册）\n\n  > 2. 这时候有了GreenHub就可以注册其他免费的VPN了，比如Privadio（[注册免费计划的页面](https://signup.privadovpn.com/fre)）这个是一个月10G，用完需要去官网刷新，可以用qq邮箱注册，如果给你邮箱频繁发消息，你可以点击邮件里最下面的Unsubscribe（也就是退订选项）\n\n  3. 如果是深度魔法用户，我还是推荐用一些付费的，如果只是偶尔用用GPT，可以使用免费的应付了事。\n\n  4. 如果操作不是很明白，可以和博主在qq/wx说明，或许会有小惊喜哦~\n\n### 付费VPN\n\n  [低价机场](https://dawn-tango-a1e.notion.site/5f7c5d2f7a7747a6bc6541406cb022f5)感觉完全可以了。\n -->\n\n## GPT\n\n  这东西很好用，如果你是写实验报告一类的，简直不要太轻松，但是因为未知因素，正常用户只能用一些镜像GPT，一些镜像GPT还是很好用的，甚至一些GPT3.5比正版的3.5好用（因为用户个人的训练）\n\n### 镜像GPT：\n  \n  > One：BAI GPT：https://chatbot.theb.ai/#/chat/1002\n  > Two：AI之眼：https://ai-eye.org\n  > Three：ohmy GPT：https://www.ohmygpt.com/chat\n  > Four：poe：https://poe.com \n  > Five：https://beta.chatmindai.net\n  > six：http://124.220.104.235:31105/web/chatgpt\n\n  这六个都还以当镜像，其中第三个是咱学校的学长搞的，里面的免费代币每天有一万，如果是使用3.5的话，一天可以使用一万次；\n\n  第四个poe，里面内置了好多市面上可用GPT，还可以体验4.0，但是美中不足的是，前四个都需要挂VPN。\n\n  第五个是国内的一个镜像软件网页版，3.5的话一个小时可以用25次，claude+每天可以用30次，4.0和Claude+100k一日一次。\n\n  第六个是免费的一个gpt聚合，有16个镜像，好多可以在国内登录。\n\n  如果你是使用edge浏览器的话，在[获取扩展](https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home) 里搜索Sider，然后找到 Sider: ChatGPT侧边栏 这个小插件，点击添加就行，一天可以用30次（用Google账号登录之后），而且不需要挂梯子。\n  \n  上面这些差不多有七个平替，还有GPT网页聚合，应该够用了。\n\n### 正版chatGPT：\n\n  如果是注册ChatGPT，这个的话比较麻烦，我可以推荐两个方法得到一个chatGPT账号，但不能完全确保。\n  \n  <!-- 方法一：方法比较复杂 -->\n  方法一：现如今注册挺简单的，和今年年初，以及今年七八月相比\n\n  > 1. 首先去[SMS官网](https://sms-activate.org/cn)注册账号，并且用支付宝最少充值2$（约和14.3人民币，150卢布）购买虚拟手机号接收验证码。\n\n  <!-- > 2. 然后用VPN去[openAI注册](chat.openai.com/auth/lo)，跟着流程来，最麻烦的是接收验证码，因为手机号被标记，甚至IP，账号被系统标记，导致接收不了验证码，很是麻烦，所以我推荐第二个方法。 -->\n\n  > 2. 然后用VPN去[openAI注册](chat.openai.com/auth/lo)，跟着流程来，最麻烦的是接收验证码，但是可能因为手机号、甚至IP、邮箱账号被系统标记，导致接收不了验证码，不过现在应该好多了，没那么严格了。\n\n  **博主推荐使用Google邮箱或者outlook邮箱进行注册，选一个好一点干净一点的ip，基本上问题不大**\n\n  相对于方法一，方法二很简单，那就是买成品号，但是一个账号动不动就买几十的，太不值了，但我知道一个很便宜的，使用住宅ip注册的。\n\n  方法二：购买\n\n  不过现在博主的渠道的已经失效了，所以就不告知了，可惜了，那个渠道挺便宜的，3元一个成品号。--2023/11/14\n\n  <!-- 点击[这里](https://fk.gpt0.icu/)购买，不贵，3元一个，比自己注册便宜很多，最后查询订单查看卡密就行。\n\n  > 这里说明一下，用这个方法注册的账号可以使用chatGPT，相对于第一种方法，这种方法所购买的直接是成品号，邮箱是对方的虚拟邮箱，而不是自己的邮箱。如果服务器到期了，这个邮箱就没了，但是，号还是会存在的，也就是说你的chatGPT账号还是能正常使用。 -->\n\n  **这两种方法，请自行判断（其实没必要用正版chatGPT，好多镜像都是很好用的，这个就看自己的选择了)**\n\n### new bing\n\n  [new bing](www.bing.com/new)的联网功能还是可以的，在某些方面比chatGPT好用，仁者见仁智者见智，我的话，都用 嗯哼~ o(*￣▽￣*)o\n\n  首先需要挂着梯子，点击[new bing](www.bing.com/new)，直接开始聊天就行\n\n  >如果使用GreenHub翻墙的话，需要点击设置，在智能模式代理设置中输入 www.bing.com 这样的话，去new bing就不会转跳，可以正常使用new bing\n\n### claude2.0\n\n  这个是**免费**开放的，可以**上传文件**，让AI帮你分析并回答你的问题，是**对标GPT4.0**存在的，其中分析你上传的文件，文件最多可以上传**5个**，每个最大**10mb**，而且支持用户在每个问答中输入**100K**的tokens。\n\n  注册方法：\n\n  1. 首先需要挂VPN，这个对VPN有要求，需要**美国**或者**英国**的节点。\n\n  2. 点击[claude](https://claude.ai/login)进行注册。\n\n### GPT-4\n\n  GPT4嘛，有一些免费的，但请注意，这种免费的一般来讲比正版要弱一些，比如上面说的，**poe、Claude2.0、new bing**，除此外还有两个方法：\n\n  1. [steamship.com](https://www.steamship.com)\n\n  > 用Google登录之后一直下一步就行，然后点击[这里](https://www.steamship.com/plugins/gpt-4/_create)\n\n  > 直接进入创建GPT-4实例的页面，这里可以点击Optional Configuration进行自定义配置或者直接默认配置，最后点击create按钮创建\n\n  2. [chat.forefront.ai](https://chat.forefront.ai)\n\n  > GPT-4：每三个小时五次\n  > Claude+：每三个小时五次\n  > Claude：不限制使用\n  > GPT-3.5：不限制使用\n\n说了这么多东西，突然想起来一个安卓软件，之前安利过，奇妙应用，很不错的一个应用库 https://magicalapp.lanzoul.com/iGrjf12m6agd\n\n对了，请注意，点击红色字体可以直接跳转，所以许多我没有直接放网址链接，那么，晚安啦~\n\n\n","tags":["魔法"],"categories":["Tool"]},{"title":"拾词-One","url":"/2023/07/14/Poem/one/","content":"## 缘启\n\n这是 [拉姆的小树屋](https://sherry14love.github.io/)的第一篇文章-缘起~ o(*￣▽￣*)o\n\n<!-- 仅仅是想到什么写什么，如有观感不佳，十分抱歉（小声）（bushi） -->\n\n## 桃花坞\n\n> 城市里的车水马龙，街道上的过往行人，不过是穿越时空的匆匆过客，无论多少次回眸，都只是一张张陌生的人脸，没有眷念与感情，最终化为梦的虚无，什么也没有。\n\n  前几天跑图书馆去看哲学书，结果脑袋要炸掉了，就随手拿了一本悬疑小说，里面的一句，感觉还不错。\n\n  过来人的劝诫，没事别看解构主义史...\n  <!-- 前几天跑图书馆看哲学书看懵了，便随手拿了一本书，借着书中意象，得了这一句，些许趣味，倒是有点像文青。 -->\n\n### 往日之词\n\n1-5\n``` bash  \n  轻云闭月醉星尘，流风回雪除旧痕。\n  2023.1.12\n```\n``` bash \n  碎步踏月梦留香，倾城一笑是姑娘。\n  2023.5.11\n```\n``` bash \n  细语低吟且为君，一阕轻言莫敢云。\n  2023.5.11\n```\n``` bash\n  夜语思梦至浮生，灯落三更入赤诚。\n  2023.6.24\n```\n``` bash\n  古人道，檀口微开皓齿香，眼波浮动脸生光，\n  怎料想，春风不见桃花落，频频入梦不可说，\n  半依墙，不语寻常也寻常。2023.5.22\n```\n6-9\n``` bash\n  轻言语，眉间几多柔许，了了，闲情我寄此句，\n  书瞳中颜色温如玉，音如宫商羽。2023.3.2\n```\n``` bash\n  抚风柳，白雪糅肤醉酒，些许，羞涩不善言语，\n  道尘露芳草落于秋，恬然心中留。2023.3.2\n```\n``` bash\n  晃晃如梦间，见朱颜倩影肌肤白，醉人眼，\n  玉容含笑柔情浅，桃花开，春风暖，眉梢\n  卧蚕似婉转，幸甚哉，识君面，淡妆由衷\n  之言妍。2023.3.25\n```\n``` bash\n  欲写妙笔几回言，姑娘素衣御翩跹，梦涟。\n  想是弱柳扶风施夷在，胜似相识缘由浅，\n  一时喃。几若妍，不分千百姿态，\n  醉了媚了几杯还（huai）。\n  痴笑却嫌，嗔我三分言语笨，\n  不知怎扣心门。启皓齿，朱唇玉面。\n  叫谁心中空空心中恐，缘法弄，花依旧，\n  蝶与柔风清香留。何来腼腆，书一笑莞尔\n  嫣然，如梦佳人重现，算今生，也结缘。\n  2023.5.4\n```\n\n  这些算得上是23年写的比较有感觉的几句,貌似不正经的诗有点多。\n  \n  咳，问题不大，毕竟诗词总不能是如此不便之物吧😏\n\n  <!-- 咳，不要在意，问题不大，仅仅是留作纪念的,里面好像还有写给别人的（bushi） -->\n\n## 花开盛夏绪-博客部署历程\n\n  昨天下雨，闷热的，拉姆做博客家里WiFi还不稳定，所以拖到今天才做（下雨天真的很适合睡觉）\n\n  然后一上午部署成功（突然想到八个月前弄博客弄了三四天都没弄好，怎么能搞那么久呢，而且好像是卡在了部署GitHub仓库里，唔，不理解）\n\n  午饭之前部署完主题，然后就出bug了，本地部署好好的，部署到GitHub仓库里布局不知怎得就乱了（痛）弄了一会没弄好，吃完饭再来弄，弄了半个多小时，搞不完，问[kmar](https://kmar.top \"空梦的博客\")（宿舍大佬）\n\n  结果布局却突然好了，但是源文件拉姆一点点都没碰，对拉姆这种菜鸟来说，简直百思不得其解。\n  <!-- 结果布局就很突然得好了，就很懵，因为那些文件拉姆一点点都没碰（对这种菜鸟来说，简直百思不得其解） -->\n\n  而且这几天不知怎得，家里WiFi一直不稳定，今天就好多次网络是不稳定的，啊啊啊令人抓狂（恼）\n\n  拉姆到最后都怀疑自己是不是前几天拆电脑装固态的时候不小心碰到了电脑网卡（ ）\n\n  好在到最后结果是好的————\n\n<!-- ### 绪One\n\n  思青告诉我他又被两个小姑娘要微信了，我表示，最好快点生个女娃，思青那么帅，生下的娃娃肯定卡哇伊！（老父亲思想作祟）\n\n  昨天和别的朋友聊了聊，貌似好像同龄人都不喜欢结婚，很难不赞同，毕竟现实的社会环境（ ）\n\n  希望未来有个富二代朋友带带我，我不想努力了（信誓旦旦） -->\n\n## 绪One\n\n  再不结束都十一点了快，现在晚上十点半（手打博客中，明天再学）\n\n  说到学拉姆想起来拉姆还得考科一，但是这几天都没怎么看过题，唔，过两天还得参加青训营笔试，拉姆这么菜这么倒霉，说不定连笔试都过不了，算了，过不了就开始认真备考科一（bushi）\n\n  ~~哦天哪，拉姆还忘记看GO语言了，啊啊啊这一天天的，太颓废了~~\n\n## 绪Two\n\n  嗯哼先这样，睡觉睡觉。\n \n  Darling, may you have a wonderful evening. \n\n  嗯~ o(*￣▽￣*)o\n","tags":["拾词"],"categories":["诗词"]}]